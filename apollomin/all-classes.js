var Ext = Ext || {};
if (!Ext.Direct) {
    Ext.Direct = {}
}
if (!Ext.Toolbar) {
    Ext.Toolbar = {}
}
if (!Ext.app) {
    Ext.app = {}
}
if (!Ext.app.domain) {
    Ext.app.domain = {}
}
if (!Ext.button) {
    Ext.button = {}
}
if (!Ext.chart) {
    Ext.chart = {}
}
if (!Ext.chart.axis) {
    Ext.chart.axis = {}
}
if (!Ext.chart.series) {
    Ext.chart.series = {}
}
if (!Ext.chart.theme) {
    Ext.chart.theme = {}
}
if (!Ext.container) {
    Ext.container = {}
}
if (!Ext.core) {
    Ext.core = {}
}
if (!Ext.data) {
    Ext.data = {}
}
if (!Ext.data.association) {
    Ext.data.association = {}
}
if (!Ext.data.flash) {
    Ext.data.flash = {}
}
if (!Ext.data.proxy) {
    Ext.data.proxy = {}
}
if (!Ext.data.reader) {
    Ext.data.reader = {}
}
if (!Ext.data.writer) {
    Ext.data.writer = {}
}
if (!Ext.dd) {
    Ext.dd = {}
}
if (!Ext.diag) {
    Ext.diag = {}
}
if (!Ext.diag.layout) {
    Ext.diag.layout = {}
}
if (!Ext.direct) {
    Ext.direct = {}
}
if (!Ext.dom) {
    Ext.dom = {}
}
if (!Ext.draw) {
    Ext.draw = {}
}
if (!Ext.draw.engine) {
    Ext.draw.engine = {}
}
if (!Ext.flash) {
    Ext.flash = {}
}
if (!Ext.form) {
    Ext.form = {}
}
if (!Ext.form.Action) {
    Ext.form.Action = {}
}
if (!Ext.form.action) {
    Ext.form.action = {}
}
if (!Ext.form.field) {
    Ext.form.field = {}
}
if (!Ext.fx) {
    Ext.fx = {}
}
if (!Ext.fx.target) {
    Ext.fx.target = {}
}
if (!Ext.grid) {
    Ext.grid = {}
}
if (!Ext.grid.column) {
    Ext.grid.column = {}
}
if (!Ext.grid.feature) {
    Ext.grid.feature = {}
}
if (!Ext.grid.header) {
    Ext.grid.header = {}
}
if (!Ext.grid.locking) {
    Ext.grid.locking = {}
}
if (!Ext.grid.plugin) {
    Ext.grid.plugin = {}
}
if (!Ext.grid.property) {
    Ext.grid.property = {}
}
if (!Ext.layout) {
    Ext.layout = {}
}
if (!Ext.layout.boxOverflow) {
    Ext.layout.boxOverflow = {}
}
if (!Ext.layout.component) {
    Ext.layout.component = {}
}
if (!Ext.layout.component.field) {
    Ext.layout.component.field = {}
}
if (!Ext.layout.container) {
    Ext.layout.container = {}
}
if (!Ext.layout.container.border) {
    Ext.layout.container.border = {}
}
if (!Ext.layout.container.boxOverflow) {
    Ext.layout.container.boxOverflow = {}
}
if (!Ext.list) {
    Ext.list = {}
}
if (!Ext.locale) {
    Ext.locale = {}
}
if (!Ext.locale.de) {
    Ext.locale.de = {}
}
if (!Ext.locale.de.form) {
    Ext.locale.de.form = {}
}
if (!Ext.locale.de.form.field) {
    Ext.locale.de.form.field = {}
}
if (!Ext.locale.de.grid) {
    Ext.locale.de.grid = {}
}
if (!Ext.locale.de.grid.header) {
    Ext.locale.de.grid.header = {}
}
if (!Ext.locale.de.grid.plugin) {
    Ext.locale.de.grid.plugin = {}
}
if (!Ext.locale.de.picker) {
    Ext.locale.de.picker = {}
}
if (!Ext.locale.de.tab) {
    Ext.locale.de.tab = {}
}
if (!Ext.locale.de.toolbar) {
    Ext.locale.de.toolbar = {}
}
if (!Ext.locale.de.view) {
    Ext.locale.de.view = {}
}
if (!Ext.locale.de.window) {
    Ext.locale.de.window = {}
}
if (!Ext.menu) {
    Ext.menu = {}
}
if (!Ext.panel) {
    Ext.panel = {}
}
if (!Ext.perf) {
    Ext.perf = {}
}
if (!Ext.picker) {
    Ext.picker = {}
}
if (!Ext.resizer) {
    Ext.resizer = {}
}
if (!Ext.rtl) {
    Ext.rtl = {}
}
if (!Ext.rtl.button) {
    Ext.rtl.button = {}
}
if (!Ext.rtl.dd) {
    Ext.rtl.dd = {}
}
if (!Ext.rtl.dom) {
    Ext.rtl.dom = {}
}
if (!Ext.rtl.form) {
    Ext.rtl.form = {}
}
if (!Ext.rtl.form.field) {
    Ext.rtl.form.field = {}
}
if (!Ext.rtl.grid) {
    Ext.rtl.grid = {}
}
if (!Ext.rtl.grid.column) {
    Ext.rtl.grid.column = {}
}
if (!Ext.rtl.grid.plugin) {
    Ext.rtl.grid.plugin = {}
}
if (!Ext.rtl.layout) {
    Ext.rtl.layout = {}
}
if (!Ext.rtl.layout.component) {
    Ext.rtl.layout.component = {}
}
if (!Ext.rtl.layout.component.field) {
    Ext.rtl.layout.component.field = {}
}
if (!Ext.rtl.layout.container) {
    Ext.rtl.layout.container = {}
}
if (!Ext.rtl.layout.container.boxOverflow) {
    Ext.rtl.layout.container.boxOverflow = {}
}
if (!Ext.rtl.panel) {
    Ext.rtl.panel = {}
}
if (!Ext.rtl.resizer) {
    Ext.rtl.resizer = {}
}
if (!Ext.rtl.selection) {
    Ext.rtl.selection = {}
}
if (!Ext.rtl.slider) {
    Ext.rtl.slider = {}
}
if (!Ext.rtl.tab) {
    Ext.rtl.tab = {}
}
if (!Ext.rtl.tip) {
    Ext.rtl.tip = {}
}
if (!Ext.rtl.tree) {
    Ext.rtl.tree = {}
}
if (!Ext.rtl.util) {
    Ext.rtl.util = {}
}
if (!Ext.rtl.view) {
    Ext.rtl.view = {}
}
if (!Ext.selection) {
    Ext.selection = {}
}
if (!Ext.slider) {
    Ext.slider = {}
}
if (!Ext.state) {
    Ext.state = {}
}
if (!Ext.tab) {
    Ext.tab = {}
}
if (!Ext.tip) {
    Ext.tip = {}
}
if (!Ext.toolbar) {
    Ext.toolbar = {}
}
if (!Ext.tree) {
    Ext.tree = {}
}
if (!Ext.tree.plugin) {
    Ext.tree.plugin = {}
}
if (!Ext.util) {
    Ext.util = {}
}
if (!Ext.ux) {
    Ext.ux = {}
}
if (!Ext.ux.DataView) {
    Ext.ux.DataView = {}
}
if (!Ext.ux.ajax) {
    Ext.ux.ajax = {}
}
if (!Ext.ux.data) {
    Ext.ux.data = {}
}
if (!Ext.ux.dd) {
    Ext.ux.dd = {}
}
if (!Ext.ux.event) {
    Ext.ux.event = {}
}
if (!Ext.ux.form) {
    Ext.ux.form = {}
}
if (!Ext.ux.form.field) {
    Ext.ux.form.field = {}
}
if (!Ext.ux.grid) {
    Ext.ux.grid = {}
}
if (!Ext.ux.grid.filter) {
    Ext.ux.grid.filter = {}
}
if (!Ext.ux.grid.menu) {
    Ext.ux.grid.menu = {}
}
if (!Ext.ux.layout) {
    Ext.ux.layout = {}
}
if (!Ext.ux.statusbar) {
    Ext.ux.statusbar = {}
}
if (!Ext.ux.upload) {
    Ext.ux.upload = {}
}
if (!Ext.ux.upload.data) {
    Ext.ux.upload.data = {}
}
if (!Ext.ux.upload.uploader) {
    Ext.ux.upload.uploader = {}
}
if (!Ext.view) {
    Ext.view = {}
}
if (!Ext.window) {
    Ext.window = {}
}
var ExtThemeNeptune = ExtThemeNeptune || {};
if (!ExtThemeNeptune.container) {
    ExtThemeNeptune.container = {}
}
if (!ExtThemeNeptune.form) {
    ExtThemeNeptune.form = {}
}
if (!ExtThemeNeptune.form.field) {
    ExtThemeNeptune.form.field = {}
}
if (!ExtThemeNeptune.grid) {
    ExtThemeNeptune.grid = {}
}
if (!ExtThemeNeptune.grid.column) {
    ExtThemeNeptune.grid.column = {}
}
if (!ExtThemeNeptune.layout) {
    ExtThemeNeptune.layout = {}
}
if (!ExtThemeNeptune.layout.component) {
    ExtThemeNeptune.layout.component = {}
}
if (!ExtThemeNeptune.menu) {
    ExtThemeNeptune.menu = {}
}
if (!ExtThemeNeptune.panel) {
    ExtThemeNeptune.panel = {}
}
if (!ExtThemeNeptune.picker) {
    ExtThemeNeptune.picker = {}
}
if (!ExtThemeNeptune.resizer) {
    ExtThemeNeptune.resizer = {}
}
if (!ExtThemeNeptune.tab) {
    ExtThemeNeptune.tab = {}
}
if (!ExtThemeNeptune.toolbar) {
    ExtThemeNeptune.toolbar = {}
}
var am = am || {};
if (!am.controller) {
    am.controller = {}
}
if (!am.model) {
    am.model = {}
}
if (!am.proxy) {
    am.proxy = {}
}
if (!am.store) {
    am.store = {}
}
if (!am.view) {
    am.view = {}
}
if (!am.view.component) {
    am.view.component = {}
}
if (!am.view.window) {
    am.view.window = {}
}
(function(h) {
    var j    = [], k = ["constructor", "toString", "valueOf", "toLocaleString"], i = {}, n = {}, b = 0, g, c, m, f, a = function() {
        var p, o;
        c = Ext.Base;
        m = Ext.ClassManager;
        for (p = k.length; p-- > 0;) {
            o              = (1 << p);
            n[i[o] = k[p]] = o
        }
        for (p in n) {
            b |= n[p]
        }
        b                              = ~b;
        Function.prototype.$isFunction = 1;
        f                              = Ext.Class.getPreprocessor("config").fn;
        for (g in c) {
            if (c.hasOwnProperty(g)) {
                j.push(g)
            }
        }
        h.derive = d;
        return d.apply(this, arguments)
    }, e     = function(w, s, v) {
        var p = v.enumerableMembers, t = w.prototype, r, u, q, o;
        if (!s) {
            return
        }
        for (r in s) {
            o = s[r];
            if (o && o.$isFunction && !o.$isClass && o !== Ext.emptyFn && o !== Ext.identityFn) {
                t[r] = u = o;
                u.$owner = w;
                u.$name  = r
            } else {
                t[r] = o
            }
        }
        for (q = 1; p; q <<= 1) {
            if (p & q) {
                p &= ~q;
                r    = i[q];
                t[r] = u = s[r];
                u.$owner = w;
                u.$name  = r
            }
        }
    }, l     = function(s) {
        var o       = function r() {
            return s.apply(this, arguments) || null
        }, q, p;
        o.prototype = Ext.Object.chain(s.prototype);
        for (q = j.length; q-- > 0;) {
            p    = j[q];
            o[p] = c[p]
        }
        return o
    }, d     = function(t, w, P, o, v, D, u, M, r, F, z) {
        var p = function y() {
            return this.constructor.apply(this, arguments) || null
        }, O  = p, q = {
            enumerableMembers: o & b,
            onCreated        : z,
            onBeforeCreated  : e,
            aliases          : M
        }, C  = P.alternateClassName || [], K = Ext.global, G, J, L, B, I, S, R, s, H, x, N, E, A, Q;
        for (L = j.length; L-- > 0;) {
            R    = j[L];
            p[R] = c[R]
        }
        if (P.$isFunction) {
            P = P(p)
        }
        q.data = P;
        x = P.statics, P.$className = t;
        if (P.$className) {
            p.$className = P.$className
        }
        p.extend(w);
        H       = p.prototype;
        p.xtype = P.xtype = v[0];
        if (v) {
            H.xtypes = v
        }
        H.xtypesChain = D;
        H.xtypesMap   = u;
        P.alias       = M;
        O.triggerExtended(p, P, q);
        if (P.onClassExtended) {
            p.onExtended(P.onClassExtended, p);
            delete P.onClassExtended
        }
        if (x) {
            for (N in x) {
                if (x.hasOwnProperty(N)) {
                    Q = x[N];
                    if (Q && Q.$isFunction && !Q.$isClass && Q !== Ext.emptyFn && Q !== Ext.identityFn) {
                        p[N] = A = Q;
                        A.$owner = p;
                        A.$name  = N
                    }
                    p[N] = Q
                }
            }
        }
        delete P.statics;
        if (P.inheritableStatics) {
            p.addInheritableStatics(P.inheritableStatics)
        }
        if (H.onClassExtended) {
            O.onExtended(H.onClassExtended, O);
            delete H.onClassExtended
        }
        if (P.config) {
            f(p, P)
        }
        q.onBeforeCreated(p, q.data, q);
        for (L = 0, I = r && r.length; L < I; ++L) {
            p.mixin.apply(p, r[L])
        }
        for (L = 0, I = M.length; L < I; L++) {
            G = M[L];
            m.setAlias(p, G)
        }
        if (P.singleton) {
            O = new p()
        }
        if (!(C instanceof Array)) {
            C = [C]
        }
        for (L = 0, B = C.length; L < B; L++) {
            J            = C[L];
            m.classes[J] = O;
            E            = m.getName(O);
            s            = m.maps.nameToAlternates;
            if (E && E !== J) {
                m.maps.alternateToName[J] = E;
                C                         = s[E] || (s[E] = []);
                C.push(J)
            }
        }
        for (L = 0, I = F.length; L < I; L += 2) {
            S = F[L];
            if (!S) {
                S = K
            }
            S[F[L + 1]] = O
        }
        m.classes[t] = O;
        E            = m.getName(O);
        s            = m.maps.nameToAlternates;
        if (E && E !== t) {
            m.maps.alternateToName[t] = E;
            C                         = s[E] || (s[E] = []);
            C.push(t)
        }
        delete H.alternateClassName;
        if (q.onCreated) {
            q.onCreated.call(O, O)
        }
        if (t) {
            m.triggerCreated(t)
        }
        return O
    };
    h.derive = a
}(Ext.cmd = {}));
Ext.define("Ext.AbstractPlugin", {
    disabled       : false,
    isPlugin       : true,
    constructor    : function(a) {
        this.pluginConfig = a;
        Ext.apply(this, a)
    },
    clonePlugin    : function(a) {
        return new this.self(Ext.apply({}, a, this.pluginConfig))
    },
    setCmp         : function(a) {
        this.cmp = a
    },
    getCmp         : function() {
        return this.cmp
    },
    init           : Ext.emptyFn,
    destroy        : Ext.emptyFn,
    enable         : function() {
        this.disabled = false
    },
    disable        : function() {
        this.disabled = true
    },
    onClassExtended: function(b, d, a) {
        var c = d.alias;
        if (c && !d.ptype) {
            if (Ext.isArray(c)) {
                c = c[0]
            }
            b.prototype.ptype = c.split("plugin.")[1]
        }
    }
});
Ext.define("Ext.Action", {
    constructor    : function(a) {
        this.initialConfig = a;
        this.itemId        = a.itemId = (a.itemId || a.id || Ext.id());
        this.items = []
    },
    isAction       : true,
    setText        : function(a) {
        this.initialConfig.text = a;
        this.callEach("setText", [a])
    },
    getText        : function() {
        return this.initialConfig.text
    },
    setIconCls     : function(a) {
        this.initialConfig.iconCls = a;
        this.callEach("setIconCls", [a])
    },
    getIconCls     : function() {
        return this.initialConfig.iconCls
    },
    setDisabled    : function(a) {
        this.initialConfig.disabled = a;
        this.callEach("setDisabled", [a])
    },
    enable         : function() {
        this.setDisabled(false)
    },
    disable        : function() {
        this.setDisabled(true)
    },
    isDisabled     : function() {
        return this.initialConfig.disabled
    },
    setHidden      : function(a) {
        this.initialConfig.hidden = a;
        this.callEach("setVisible", [!a])
    },
    show           : function() {
        this.setHidden(false)
    },
    hide           : function() {
        this.setHidden(true)
    },
    isHidden       : function() {
        return this.initialConfig.hidden
    },
    setHandler     : function(b, a) {
        this.initialConfig.handler = b;
        this.initialConfig.scope   = a;
        this.callEach("setHandler", [b, a])
    },
    each           : function(b, a) {
        Ext.each(this.items, b, a)
    },
    callEach       : function(f, c) {
        var b = this.items, d = 0, a = b.length, e;
        Ext.suspendLayouts();
        for (; d < a; d++) {
            e = b[d];
            e[f].apply(e, c)
        }
        Ext.resumeLayouts(true)
    },
    addComponent   : function(a) {
        this.items.push(a);
        a.on("destroy", this.removeComponent, this)
    },
    removeComponent: function(a) {
        Ext.Array.remove(this.items, a)
    },
    execute        : function() {
        this.initialConfig.handler.apply(this.initialConfig.scope || Ext.global, arguments)
    }
});
Ext.onReady(function() {
    if (Ext.Date) {
        Ext.Date.monthNames        = ["Januar", "Februar", "M\xe4rz", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"];
        Ext.Date.defaultFormat     = "d.m.Y";
        Ext.Date.getShortMonthName = function(a) {
            return Ext.Date.monthNames[a].substring(0, 3)
        };
        Ext.Date.monthNumbers      = {
            Jan     : 0,
            Feb     : 1,
            "M\xe4r": 2,
            Apr     : 3,
            Mai     : 4,
            Jun     : 5,
            Jul     : 6,
            Aug     : 7,
            Sep     : 8,
            Okt     : 9,
            Nov     : 10,
            Dez     : 11
        };
        Ext.Date.getMonthNumber    = function(a) {
            return Ext.Date.monthNumbers[a.substring(0, 1).toUpperCase() + a.substring(1, 3).toLowerCase()]
        };
        Ext.Date.dayNames          = ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"];
        Ext.Date.getShortDayName   = function(a) {
            return Ext.Date.dayNames[a].substring(0, 3)
        }
    }
    if (Ext.util && Ext.util.Format) {
        Ext.util.Format.__number = Ext.util.Format.number;
        Ext.util.Format.number   = function(a, b) {
            return Ext.util.Format.__number(a, b || "0.000,00/i")
        };
        Ext.apply(Ext.util.Format, {
            thousandSeparator: ".",
            decimalSeparator : ",",
            currencySign     : "\u20ac",
            dateFormat       : "d.m.Y"
        })
    }
});
Ext.define("Ext.locale.de.view.View", {
    override : "Ext.view.View",
    emptyText: ""
});
Ext.define("Ext.locale.de.grid.plugin.DragDrop", {
    override: "Ext.grid.plugin.DragDrop",
    dragText: "{0} Zeile(n) ausgew\xe4hlt"
});
Ext.define("Ext.locale.de.tab.Tab", {
    override : "Ext.tab.Tab",
    closeText: "Diesen Tab schlie\xdfen"
});
Ext.define("Ext.locale.de.form.Basic", {
    override : "Ext.form.Basic",
    waitTitle: "Bitte warten..."
});
Ext.define("Ext.locale.de.form.field.Base", {
    override   : "Ext.form.field.Base",
    invalidText: "Der Wert des Feldes ist nicht korrekt"
});
Ext.define("Ext.locale.de.LoadMask", {
    override   : "Ext.LoadMask",
    loadingText: "Lade Daten..."
});
Ext.define("Ext.locale.de.view.AbstractView", {
    override   : "Ext.view.AbstractView",
    loadingText: "Lade Daten..."
});
Ext.define("Ext.locale.de.picker.Date", {
    override         : "Ext.picker.Date",
    todayText        : "Heute",
    minText          : "Dieses Datum liegt von dem erstm\xf6glichen Datum",
    maxText          : "Dieses Datum liegt nach dem letztm\xf6glichen Datum",
    disabledDaysText : "",
    disabledDatesText: "",
    nextText         : "N\xe4chster Monat (Strg/Control + Rechts)",
    prevText         : "Vorheriger Monat (Strg/Control + Links)",
    monthYearText    : "Monat ausw\xe4hlen (Strg/Control + Hoch/Runter, um ein Jahr auszuw\xe4hlen)",
    todayTip         : "Heute ({0}) (Leertaste)",
    format           : "d.m.Y",
    startDay         : 1
});
Ext.define("Ext.locale.de.picker.Month", {
    override  : "Ext.picker.Month",
    okText    : "&#160;OK&#160;",
    cancelText: "Abbrechen"
});
Ext.define("Ext.locale.de.toolbar.Paging", {
    override      : "Ext.PagingToolbar",
    beforePageText: "Seite",
    afterPageText : "von {0}",
    firstText     : "Erste Seite",
    prevText      : "vorherige Seite",
    nextText      : "n\xe4chste Seite",
    lastText      : "letzte Seite",
    refreshText   : "Aktualisieren",
    displayMsg    : "Anzeige Eintrag {0} - {1} von {2}",
    emptyMsg      : "Keine Daten vorhanden"
});
Ext.define("Ext.locale.de.form.field.Text", {
    override     : "Ext.form.field.Text",
    minLengthText: "Bitte geben Sie mindestens {0} Zeichen ein",
    maxLengthText: "Bitte geben Sie maximal {0} Zeichen ein",
    blankText    : "Dieses Feld darf nicht leer sein",
    regexText    : "",
    emptyText    : null
});
Ext.define("Ext.locale.de.form.field.Number", {
    override        : "Ext.form.field.Number",
    minText         : "Der Mindestwert f\xfcr dieses Feld ist {0}",
    maxText         : "Der Maximalwert f\xfcr dieses Feld ist {0}",
    nanText         : "{0} ist keine Zahl",
    decimalSeparator: ","
});
Ext.define("Ext.locale.de.form.field.Date", {
    override         : "Ext.form.field.Date",
    disabledDaysText : "nicht erlaubt",
    disabledDatesText: "nicht erlaubt",
    minText          : "Das Datum in diesem Feld muss nach dem {0} liegen",
    maxText          : "Das Datum in diesem Feld muss vor dem {0} liegen",
    invalidText      : "{0} ist kein g\xfcltiges Datum - es muss im Format {1} eingegeben werden",
    format           : "d.m.Y",
    altFormats       : "j.n.Y|j.n.y|j.n.|j.|j/n/Y|j/n/y|j-n-y|j-n-Y|j/n|j-n|dm|dmy|dmY|j|Y-n-j|Y-m-d",
    startDay         : 1
});
Ext.define("Ext.locale.de.form.field.ComboBox", {
    override         : "Ext.form.field.ComboBox",
    valueNotFoundText: undefined
}, function() {
    Ext.apply(Ext.form.field.ComboBox.prototype.defaultListConfig, {loadingText: "Lade Daten ..."})
});
Ext.define("Ext.locale.de.form.field.VTypes", {
    override    : "Ext.form.field.VTypes",
    emailText   : 'Dieses Feld sollte eine E-Mail-Adresse enthalten. Format: "user@example.com"',
    urlText     : 'Dieses Feld sollte eine URL enthalten. Format: "http://www.example.com"',
    alphaText   : "Dieses Feld darf nur Buchstaben enthalten und _",
    alphanumText: "Dieses Feld darf nur Buchstaben und Zahlen enthalten und _"
});
Ext.define("Ext.locale.de.form.field.HtmlEditor", {
    override      : "Ext.form.field.HtmlEditor",
    createLinkText: "Bitte geben Sie die URL f\xfcr den Link ein:"
}, function() {
    Ext.apply(Ext.form.field.HtmlEditor.prototype, {
        buttonTips: {
            bold               : {
                title: "Fett (Ctrl+B)",
                text : "Erstellt den ausgew\xe4hlten Text in Fettschrift.",
                cls  : Ext.baseCSSPrefix + "html-editor-tip"
            },
            italic             : {
                title: "Kursiv (Ctrl+I)",
                text : "Erstellt den ausgew\xe4hlten Text in Schr\xe4gschrift.",
                cls  : Ext.baseCSSPrefix + "html-editor-tip"
            },
            underline          : {
                title: "Unterstrichen (Ctrl+U)",
                text : "Unterstreicht den ausgew\xe4hlten Text.",
                cls  : Ext.baseCSSPrefix + "html-editor-tip"
            },
            increasefontsize   : {
                title: "Text verg\xf6\xdfern",
                text : "Erh\xf6ht die Schriftgr\xf6\xdfe.",
                cls  : Ext.baseCSSPrefix + "html-editor-tip"
            },
            decreasefontsize   : {
                title: "Text verkleinern",
                text : "Verringert die Schriftgr\xf6\xdfe.",
                cls  : Ext.baseCSSPrefix + "html-editor-tip"
            },
            backcolor          : {
                title: "Text farblich hervorheben",
                text : "Hintergrundfarbe des ausgew\xe4hlten Textes \xe4ndern.",
                cls  : Ext.baseCSSPrefix + "html-editor-tip"
            },
            forecolor          : {
                title: "Schriftfarbe",
                text : "Farbe des ausgew\xe4hlten Textes \xe4ndern.",
                cls  : Ext.baseCSSPrefix + "html-editor-tip"
            },
            justifyleft        : {
                title: "Linksb\xfcndig",
                text : "Setzt den Text linksb\xfcndig.",
                cls  : Ext.baseCSSPrefix + "html-editor-tip"
            },
            justifycenter      : {
                title: "Zentrieren",
                text : "Zentriert den Text in Editor.",
                cls  : Ext.baseCSSPrefix + "html-editor-tip"
            },
            justifyright       : {
                title: "Rechtsb\xfcndig",
                text : "Setzt den Text rechtsb\xfcndig.",
                cls  : Ext.baseCSSPrefix + "html-editor-tip"
            },
            insertunorderedlist: {
                title: "Aufz\xe4hlungsliste",
                text : "Beginnt eine Aufz\xe4hlungsliste mit Spiegelstrichen.",
                cls  : Ext.baseCSSPrefix + "html-editor-tip"
            },
            insertorderedlist  : {
                title: "Numerierte Liste",
                text : "Beginnt eine numerierte Liste.",
                cls  : Ext.baseCSSPrefix + "html-editor-tip"
            },
            createlink         : {
                title: "Hyperlink",
                text : "Erstellt einen Hyperlink aus dem ausgew\xe4hlten text.",
                cls  : Ext.baseCSSPrefix + "html-editor-tip"
            },
            sourceedit         : {
                title: "Source bearbeiten",
                text : "Zur Bearbeitung des Quelltextes wechseln.",
                cls  : Ext.baseCSSPrefix + "html-editor-tip"
            }
        }
    })
});
Ext.define("Ext.locale.de.grid.header.Container", {
    override    : "Ext.grid.header.Container",
    sortAscText : "Aufsteigend sortieren",
    sortDescText: "Absteigend sortieren",
    lockText    : "Spalte sperren",
    unlockText  : "Spalte freigeben (entsperren)",
    columnsText : "Spalten"
});
Ext.define("Ext.locale.de.grid.GroupingFeature", {
    override      : "Ext.grid.feature.Grouping",
    emptyGroupText: "(Keine)",
    groupByText   : "Dieses Feld gruppieren",
    showGroupsText: "In Gruppen anzeigen"
});
Ext.define("Ext.locale.de.grid.PropertyColumnModel", {
    override  : "Ext.grid.PropertyColumnModel",
    nameText  : "Name",
    valueText : "Wert",
    dateFormat: "d.m.Y"
});
Ext.define("Ext.locale.de.grid.BooleanColumn", {
    override : "Ext.grid.BooleanColumn",
    trueText : "wahr",
    falseText: "falsch"
});
Ext.define("Ext.locale.de.grid.NumberColumn", {
    override: "Ext.grid.NumberColumn",
    format  : "0.000,00/i"
});
Ext.define("Ext.locale.de.grid.DateColumn", {
    override: "Ext.grid.DateColumn",
    format  : "d.m.Y"
});
Ext.define("Ext.locale.de.form.field.Time", {
    override   : "Ext.form.field.Time",
    minText    : "Die Zeit muss gleich oder nach {0} liegen",
    maxText    : "Die Zeit muss gleich oder vor {0} liegen",
    invalidText: "{0} ist keine g\xfcltige Zeit",
    format     : "H:i"
});
Ext.define("Ext.locale.de.form.CheckboxGroup", {
    override : "Ext.form.CheckboxGroup",
    blankText: "Du mu\xdft mehr als einen Eintrag aus der Gruppe ausw\xe4hlen"
});
Ext.define("Ext.locale.de.form.RadioGroup", {
    override : "Ext.form.RadioGroup",
    blankText: "Du mu\xdft einen Eintrag aus der Gruppe ausw\xe4hlen"
});
Ext.define("Ext.locale.de.window.MessageBox", {
    override  : "Ext.window.MessageBox",
    buttonText: {
        ok    : "OK",
        cancel: "Abbrechen",
        yes   : "Ja",
        no    : "Nein"
    }
});
Ext.define("Ext.locale.de.Component", {override: "Ext.Component"});
Ext.define("ExtThemeNeptune.Component", {
    override     : "Ext.Component",
    initComponent: function() {
        this.callParent();
        if (this.dock && this.border === undefined) {
            this.border = false
        }
    },
    initStyles   : function() {
        var b = this, a = b.border;
        if (b.dock) {
            b.border = null
        }
        b.callParent(arguments);
        b.border = a
    }
});
Ext.define("Ext.layout.container.border.Region", {
    override                : "Ext.Component",
    initBorderRegion        : function() {
        var a = this;
        if (!a._borderRegionInited) {
            a._borderRegionInited = true;
            a.addStateEvents(["changeregion", "changeweight"]);
            Ext.override(a, {
                getState: function() {
                    var b = a.callParent();
                    b     = a.addPropertyToState(b, "region");
                    b     = a.addPropertyToState(b, "weight");
                    return b
                }
            })
        }
    },
    getOwningBorderContainer: function() {
        var a = this.getOwningBorderLayout();
        return a && a.owner
    },
    getOwningBorderLayout   : function() {
        var a = this.ownerLayout;
        return (a && a.isBorderLayout) ? a : null
    },
    setBorderRegion         : function(j) {
        var i = this, c, d = i.region;
        if (j !== d) {
            c = i.getOwningBorderLayout();
            if (c) {
                var f = c.regionFlags[j], k = i.placeholder, a = i.splitter, b = c.owner, m = c.regionMeta, e = i.collapsed || i.floated, l, h, g;
                if (i.fireEventArgs("beforechangeregion", [i, j]) === false) {
                    return d
                }
                Ext.suspendLayouts();
                i.region = j;
                Ext.apply(i, f);
                if (i.updateCollapseTool) {
                    i.updateCollapseTool()
                }
                if (a) {
                    Ext.apply(a, f);
                    a.updateOrientation();
                    h = b.items;
                    g = h.indexOf(i);
                    if (g >= 0) {
                        l = m[j].splitterDelta;
                        if (h.getAt(g + l) !== a) {
                            h.remove(a);
                            g = h.indexOf(i);
                            if (l > 0) {
                                ++g
                            }
                            h.insert(g, a)
                        }
                    }
                }
                if (k) {
                    if (e) {
                        i.expand(false)
                    }
                    b.remove(k);
                    i.placeholder = null;
                    if (e) {
                        i.collapse(null, false)
                    }
                }
                b.updateLayout();
                Ext.resumeLayouts(true);
                i.fireEventArgs("changeregion", [i, d])
            } else {
                i.region = j
            }
        }
        return d
    },
    setRegionWeight         : function(d) {
        var c = this, b = c.getOwningBorderContainer(), e = c.placeholder, a = c.weight;
        if (d !== a) {
            if (c.fireEventArgs("beforechangeweight", [c, d]) !== false) {
                c.weight = d;
                if (e) {
                    e.weight = d
                }
                if (b) {
                    b.updateLayout()
                }
                c.fireEventArgs("changeweight", [c, a])
            }
        }
        return a
    }
});
Ext.define("Ext.app.EventDomain", {
    requires     : ["Ext.util.Event"],
    statics      : {instances: {}},
    isEventDomain: true,
    constructor  : function() {
        var a                                 = this;
        Ext.app.EventDomain.instances[a.type] = a;
        a.bus                                 = {};
        a.monitoredClasses                    = []
    },
    dispatch     : function(f, l, j) {
        var k = this, g = k.bus, m = g[l], d, c, b, n, a, e, h;
        if (!m) {
            return true
        }
        for (d in m) {
            if (m.hasOwnProperty(d) && k.match(f, d)) {
                c = m[d];
                for (b in c) {
                    if (c.hasOwnProperty(b)) {
                        n = c[b];
                        for (e = 0, h = n.length; e < h; e++) {
                            a = n[e];
                            if (a.fire.apply(a, j) === false) {
                                return false
                            }
                        }
                    }
                }
            }
        }
        return true
    },
    listen       : function(m, f) {
        var k = this, h = k.bus, p = k.idProperty, o = k.monitoredClasses, e = o.length, d, r, g, c, q, b, n, a, j, l;
        for (c in m) {
            if (m.hasOwnProperty(c) && (j = m[c])) {
                if (p) {
                    c = c === "*" ? c : c.substring(1)
                }
                for (l in j) {
                    if (j.hasOwnProperty(l)) {
                        q = null;
                        b = j[l];
                        n = f;
                        a = new Ext.util.Event(f, l);
                        if (Ext.isObject(b)) {
                            q = b;
                            b = q.fn;
                            n = q.scope || f;
                            delete q.fn;
                            delete q.scope
                        }
                        if (typeof b === "string") {
                            b = n[b]
                        }
                        a.addListener(b, n, q);
                        for (d = e; d-- > 0;) {
                            o[d].hasListeners._incr_(l)
                        }
                        r = h[l] || (h[l] = {});
                        r = r[c] || (r[c] = {});
                        g = r[f.id] || (r[f.id] = []);
                        g.push(a)
                    }
                }
            }
        }
    },
    match        : function(c, a) {
        var b = this.idProperty;
        if (b) {
            return a === "*" || c[b] === a
        }
        return false
    },
    monitor      : function(d) {
        var b = this, a = d.isInstance ? d : d.prototype, c = a.fireEventArgs;
        b.monitoredClasses.push(d);
        a.fireEventArgs = function(g, f) {
            var e = c.apply(this, arguments);
            if (e !== false) {
                e = b.dispatch(this, g, f)
            }
            return e
        }
    },
    unlisten     : function(e) {
        var b = this.bus, f, d, a, c;
        for (d in b) {
            if (b.hasOwnProperty(d) && (c = b[d])) {
                for (a in c) {
                    f = c[a];
                    delete f[e]
                }
            }
        }
    }
});
Ext.define("Ext.app.domain.Component", {
    extend     : "Ext.app.EventDomain",
    singleton  : true,
    requires   : ["Ext.Component"],
    type       : "component",
    constructor: function() {
        var a = this;
        a.callParent();
        a.monitor(Ext.Component)
    },
    match      : function(b, a) {
        return b.is(a)
    }
});
Ext.define("Ext.app.EventBus", {
    singleton  : true,
    requires   : ["Ext.app.domain.Component"],
    constructor: function() {
        var b = this, a = Ext.app.EventDomain.instances;
        b.callParent();
        b.domains = a;
        b.bus     = a.component.bus
    },
    control    : function(b, a) {
        return this.domains.component.listen(b, a)
    },
    listen     : function(d, b) {
        var a = this.domains, c;
        for (c in d) {
            if (d.hasOwnProperty(c)) {
                a[c].listen(d[c], b)
            }
        }
    },
    unlisten   : function(c) {
        var a = Ext.app.EventDomain.instances, b;
        for (b in a) {
            a[b].unlisten(c)
        }
    }
});
Ext.define("Ext.app.domain.Global", {
    extend     : "Ext.app.EventDomain",
    singleton  : true,
    type       : "global",
    constructor: function() {
        var a = this;
        a.callParent();
        a.monitor(Ext.globalEvents)
    },
    listen     : function(b, a) {
        this.callParent([{global: b}, a])
    },
    match      : function() {
        return true
    }
});
Ext.define("Ext.app.domain.Store", {
    extend     : "Ext.app.EventDomain",
    singleton  : true,
    requires   : ["Ext.data.AbstractStore"],
    type       : "store",
    idProperty : "storeId",
    constructor: function() {
        var a = this;
        a.callParent();
        a.monitor(Ext.data.AbstractStore)
    }
});
Ext.define("Ext.app.Controller", {
    requires       : ["Ext.app.EventBus", "Ext.ModelManager", "Ext.data.StoreManager", "Ext.ComponentManager", "Ext.app.domain.Global", "Ext.app.domain.Component", "Ext.app.domain.Store"],
    uses           : ["Ext.app.domain.Controller"],
    mixins         : {observable: "Ext.util.Observable"},
    statics        : {
        strings            : {
            model     : {
                getter: "getModel",
                upper : "Model"
            },
            view      : {
                getter: "getView",
                upper : "View"
            },
            controller: {
                getter: "getController",
                upper : "Controller"
            },
            store     : {
                getter: "getStore",
                upper : "Store"
            }
        },
        controllerRegex    : /^(.*)\.controller\./,
        createGetter       : function(a, b) {
            return function() {
                return this[a](b)
            }
        },
        getGetterName      : function(c, a) {
            var d = "get", e = c.split("."), f = e.length, b;
            for (b = 0; b < f; b++) {
                d += Ext.String.capitalize(e[b])
            }
            d += a;
            return d
        },
        processDependencies: function(p, q, c, d, h) {
            if (!h || !h.length) {
                return
            }
            var i = this, n = i.strings[d], b, m, l, a, e, f, k, g;
            if (!Ext.isArray(h)) {
                h = [h]
            }
            for (e = 0, f = h.length; e < f; e++) {
                a = h[e];
                b = i.getFullName(a, d, c);
                m = b.absoluteName;
                l = b.shortName;
                q.push(m);
                k    = i.getGetterName(l, n.upper);
                p[k] = g = i.createGetter(n.getter, a);
                if (d !== "controller") {
                    g["Ext.app.getter"] = true
                }
            }
        },
        getFullName        : function(c, e, d) {
            var a = c, b, f;
            if ((b = c.indexOf("@")) > 0) {
                a = c.substring(0, b);
                f = c.substring(b + 1) + "." + a
            } else {
                if (c.indexOf(".") > 0 && (Ext.ClassManager.isCreated(c) || Ext.Loader.isAClassNameWithAKnownPrefix(c))) {
                    f = c
                } else {
                    if (d) {
                        f = d + "." + e + "." + c;
                        a = c
                    } else {
                        f = c
                    }
                }
            }
            return {
                absoluteName: f,
                shortName   : a
            }
        }
    },
    application    : null,
    onClassExtended: function(b, c, a) {
        var d             = a.onBeforeCreated;
        a.onBeforeCreated = function(l, g) {
            var f = Ext.app.Controller, j = f.controllerRegex, m = [], k, e, m, i, h;
            i     = l.prototype;
            k     = Ext.getClassName(l);
            e     = g.$namespace || Ext.app.getNamespace(k) || ((h = j.exec(k)) && h[1]);
            if (e) {
                i.$namespace = e
            }
            f.processDependencies(i, m, e, "model", g.models);
            f.processDependencies(i, m, e, "view", g.views);
            f.processDependencies(i, m, e, "store", g.stores);
            f.processDependencies(i, m, e, "controller", g.controllers);
            Ext.require(m, Ext.Function.pass(d, arguments, this))
        }
    },
    constructor    : function(a) {
        var b = this;
        b.mixins.observable.constructor.call(b, a);
        if (b.refs) {
            b.ref(b.refs)
        }
        b.eventbus = Ext.app.EventBus;
        b.initAutoGetters()
    },
    initAutoGetters: function() {
        var b = this.self.prototype, c, a;
        for (c in b) {
            a = b[c];
            if (a && a["Ext.app.getter"]) {
                a.call(this)
            }
        }
    },
    doInit         : function(b) {
        var a = this;
        if (!a._initialized) {
            a.init(b);
            a._initialized = true
        }
    },
    finishInit     : function(f) {
        var d = this, e = d.controllers, b, c, a;
        if (d._initialized && e && e.length) {
            for (c = 0, a = e.length; c < a; c++) {
                b = d.getController(e[c]);
                b.finishInit(f)
            }
        }
    },
    init           : Ext.emptyFn,
    onLaunch       : Ext.emptyFn,
    ref            : function(a) {
        var f        = this, b = 0, e = a.length, g, d, c;
        a            = Ext.Array.from(a);
        f.references = f.references || [];
        for (; b < e; b++) {
            g = a[b];
            d = g.ref;
            c = "get" + Ext.String.capitalize(d);
            if (!f[c]) {
                f[c] = Ext.Function.pass(f.getRef, [d, g], f)
            }
            f.references.push(d.toLowerCase())
        }
    },
    addRef         : function(a) {
        this.ref(a)
    },
    getRef         : function(d, f, a) {
        var c = this, e = c.refCache || (c.refCache = {}), b = e[d];
        f     = f || {};
        a     = a || {};
        Ext.apply(f, a);
        if (f.forceCreate) {
            return Ext.ComponentManager.create(f, "component")
        }
        if (!b) {
            if (f.selector) {
                e[d] = b = Ext.ComponentQuery.query(f.selector)[0]
            }
            if (!b && f.autoCreate) {
                e[d] = b = Ext.ComponentManager.create(f, "component")
            }
            if (b) {
                b.on("beforedestroy", function() {
                    e[d] = null
                })
            }
        }
        return b
    },
    hasRef         : function(b) {
        var a = this.references;
        return a && Ext.Array.indexOf(a, b.toLowerCase()) !== -1
    },
    control        : function(b, c, a) {
        var d = this, e = a, f;
        if (Ext.isString(b)) {
            f    = {};
            f[b] = c
        } else {
            f = b;
            e = c
        }
        d.eventbus.control(f, e || d)
    },
    listen         : function(b, a) {
        this.eventbus.listen(b, a || this)
    },
    getController  : function(c) {
        var a = this, b = a.application;
        if (c === a.id) {
            return a
        }
        return b && b.getController(c)
    },
    getStore       : function(c) {
        var a, b;
        a = (c.indexOf("@") == -1) ? c : c.split("@")[0];
        b = Ext.StoreManager.get(a);
        if (!b) {
            c = Ext.app.Controller.getFullName(c, "store", this.$namespace);
            if (c) {
                b = Ext.create(c.absoluteName, {storeId: a})
            }
        }
        return b
    },
    getModel       : function(b) {
        var a = Ext.app.Controller.getFullName(b, "model", this.$namespace);
        return a && Ext.ModelManager.getModel(a.absoluteName)
    },
    getView        : function(a) {
        var b = Ext.app.Controller.getFullName(a, "view", this.$namespace);
        return b && Ext.ClassManager.get(b.absoluteName)
    },
    getApplication : function() {
        return this.application
    }
});
Ext.define("Ext.app.Application", {
    extend               : "Ext.app.Controller",
    requires             : ["Ext.tip.QuickTipManager"],
    scope                : undefined,
    enableQuickTips      : true,
    appFolder            : "app",
    appProperty          : "app",
    namespaces           : [],
    autoCreateViewport   : false,
    paths                : null,
    onClassExtended      : function(i, c, h) {
        var b = Ext.app.Controller, d = i.prototype, k = [], e, j, a, f, g;
        a     = c.name || i.superclass.name;
        g     = c.appFolder || i.superclass.appFolder;
        if (a) {
            c.$namespace = a;
            Ext.app.addNamespaces(a)
        }
        if (c.namespaces) {
            Ext.app.addNamespaces(c.namespaces)
        }
        if (!c["paths processed"]) {
            if (a && g) {
                Ext.Loader.setPath(a, g)
            }
            j = c.paths;
            if (j) {
                for (f in j) {
                    if (j.hasOwnProperty(f)) {
                        Ext.Loader.setPath(f, j[f])
                    }
                }
            }
        } else {
            delete c["paths processed"]
        }
        if (c.autoCreateViewport) {
            b.processDependencies(d, k, a, "view", ["Viewport"])
        }
        if (k.length) {
            e                 = h.onBeforeCreated;
            h.onBeforeCreated = function(l, n) {
                var m = Ext.Array.clone(arguments);
                Ext.require(k, function() {
                    return e.apply(this, m)
                })
            }
        }
    },
    constructor          : function(a) {
        var b = this;
        b.callParent(arguments);
        b.doInit(b);
        b.initNamespace();
        b.initControllers();
        b.onBeforeLaunch();
        b.finishInitControllers()
    },
    initNamespace        : function() {
        var c = this, a = c.appProperty, b;
        b     = Ext.namespace(c.name);
        if (b) {
            b.getApplication = function() {
                return c
            };
            if (a) {
                if (!b[a]) {
                    b[a] = c
                }
            }
        }
    },
    initControllers      : function() {
        var c         = this, d = Ext.Array.from(c.controllers);
        c.controllers = new Ext.util.MixedCollection();
        for (var a = 0, b = d.length; a < b; a++) {
            c.getController(d[a])
        }
    },
    finishInitControllers: function() {
        var c = this, d, b, a;
        d     = c.controllers.getRange();
        for (b = 0, a = d.length; b < a; b++) {
            d[b].finishInit(c)
        }
    },
    launch               : Ext.emptyFn,
    onBeforeLaunch       : function() {
        var b = this, e, f, d, a;
        if (b.enableQuickTips) {
            b.initQuickTips()
        }
        if (b.autoCreateViewport) {
            b.initViewport()
        }
        b.launch.call(b.scope || b);
        b.launched = true;
        b.fireEvent("launch", b);
        e = b.controllers.items;
        d = e.length;
        for (f = 0; f < d; f++) {
            a = e[f];
            a.onLaunch(b)
        }
    },
    getModuleClassName   : function(a, b) {
        return Ext.app.Controller.getFullName(a, b, this.name).absoluteName
    },
    initQuickTips        : function() {
        Ext.tip.QuickTipManager.init()
    },
    initViewport         : function() {
        var a = this.getView("Viewport");
        if (a) {
            a.create()
        }
    },
    getController        : function(b) {
        var d = this, e = d.controllers, c, a;
        a     = e.get(b);
        if (!a) {
            c = d.getModuleClassName(b, "controller");
            a = Ext.create(c, {
                application: d,
                id         : b
            });
            e.add(a);
            if (d._initialized) {
                a.doInit(d)
            }
        }
        return a
    },
    getApplication       : function() {
        return this
    }
});
Ext.define("ExtThemeNeptune.panel.Panel", {
    override       : "Ext.panel.Panel",
    border         : false,
    bodyBorder     : false,
    initBorderProps: Ext.emptyFn,
    initBodyBorder : function() {
        if (this.bodyBorder !== true) {
            this.callParent()
        }
    }
});
Ext.define("ExtThemeNeptune.layout.component.Dock", {
    override          : "Ext.layout.component.Dock",
    noBorderClassTable: [0, Ext.baseCSSPrefix + "noborder-l", Ext.baseCSSPrefix + "noborder-b", Ext.baseCSSPrefix + "noborder-bl", Ext.baseCSSPrefix + "noborder-r", Ext.baseCSSPrefix + "noborder-rl", Ext.baseCSSPrefix + "noborder-rb", Ext.baseCSSPrefix + "noborder-rbl", Ext.baseCSSPrefix + "noborder-t", Ext.baseCSSPrefix + "noborder-tl", Ext.baseCSSPrefix + "noborder-tb", Ext.baseCSSPrefix + "noborder-tbl", Ext.baseCSSPrefix + "noborder-tr", Ext.baseCSSPrefix + "noborder-trl", Ext.baseCSSPrefix + "noborder-trb", Ext.baseCSSPrefix + "noborder-trbl"],
    edgeMasks         : {
        top   : 8,
        right : 4,
        bottom: 2,
        left  : 1
    },
    handleItemBorders : function() {
        var y = this, f = 0, z = 8, A = 4, l = 2, e = 1, a = y.owner, s = a.bodyBorder, n = a.border, j = y.collapsed, p = y.edgeMasks, k = y.noBorderClassTable, x = a.dockedItems.generation, w, d, v, h, r, m, u, o, g, q, t, c;
        if (y.initializedBorders === x) {
            return
        }
        t                    = [];
        c                    = [];
        d                    = y.getBorderCollapseTable();
        k                    = y.getBorderClassTable ? y.getBorderClassTable() : k;
        y.initializedBorders = x;
        y.collapsed          = false;
        v                    = y.getDockedItems();
        y.collapsed          = j;
        for (r = 0, m = v.length; r < m; r++) {
            u = v[r];
            if (u.ignoreBorderManagement) {
                continue
            }
            o = u.dock;
            q = h = 0;
            t.length = 0;
            c.length = 0;
            if (o !== "bottom") {
                if (f & z) {
                    w = u.border
                } else {
                    w = n;
                    if (w !== false) {
                        h += z
                    }
                }
                if (w === false) {
                    q += z
                }
            }
            if (o !== "left") {
                if (f & A) {
                    w = u.border
                } else {
                    w = n;
                    if (w !== false) {
                        h += A
                    }
                }
                if (w === false) {
                    q += A
                }
            }
            if (o !== "top") {
                if (f & l) {
                    w = u.border
                } else {
                    w = n;
                    if (w !== false) {
                        h += l
                    }
                }
                if (w === false) {
                    q += l
                }
            }
            if (o !== "right") {
                if (f & e) {
                    w = u.border
                } else {
                    w = n;
                    if (w !== false) {
                        h += e
                    }
                }
                if (w === false) {
                    q += e
                }
            }
            if ((g = u.lastBorderMask) !== q) {
                u.lastBorderMask = q;
                if (g) {
                    c[0] = k[g]
                }
                if (q) {
                    t[0] = k[q]
                }
            }
            if ((g = u.lastBorderCollapse) !== h) {
                u.lastBorderCollapse = h;
                if (g) {
                    c[c.length] = d[g]
                }
                if (h) {
                    t[t.length] = d[h]
                }
            }
            if (c.length) {
                u.removeCls(c)
            }
            if (t.length) {
                u.addCls(t)
            }
            f |= p[o]
        }
        q = h = 0;
        t.length = 0;
        c.length = 0;
        if (f & z) {
            w = s
        } else {
            w = n;
            if (w !== false) {
                h += z
            }
        }
        if (w === false) {
            q += z
        }
        if (f & A) {
            w = s
        } else {
            w = n;
            if (w !== false) {
                h += A
            }
        }
        if (w === false) {
            q += A
        }
        if (f & l) {
            w = s
        } else {
            w = n;
            if (w !== false) {
                h += l
            }
        }
        if (w === false) {
            q += l
        }
        if (f & e) {
            w = s
        } else {
            w = n;
            if (w !== false) {
                h += e
            }
        }
        if (w === false) {
            q += e
        }
        if ((g = y.lastBodyBorderMask) !== q) {
            y.lastBodyBorderMask = q;
            if (g) {
                c[0] = k[g]
            }
            if (q) {
                t[0] = k[q]
            }
        }
        if ((g = y.lastBodyBorderCollapse) !== h) {
            y.lastBodyBorderCollapse = h;
            if (g) {
                c[c.length] = d[g]
            }
            if (h) {
                t[t.length] = d[h]
            }
        }
        if (c.length) {
            a.removeBodyCls(c)
        }
        if (t.length) {
            a.addBodyCls(t)
        }
    },
    onRemove          : function(b) {
        var a = b.lastBorderMask;
        if (!b.isDestroyed && !b.ignoreBorderManagement && a) {
            b.lastBorderMask = 0;
            b.removeCls(this.noBorderClassTable[a])
        }
        this.callParent([b])
    }
});
Ext.define("ExtThemeNeptune.toolbar.Toolbar", {
    override       : "Ext.toolbar.Toolbar",
    usePlainButtons: false,
    border         : false
});
Ext.define("Ext.app.domain.Controller", {
    extend     : "Ext.app.EventDomain",
    singleton  : true,
    requires   : ["Ext.app.Controller"],
    type       : "controller",
    idProperty : "id",
    constructor: function() {
        var a = this;
        a.callParent();
        a.monitor(Ext.app.Controller)
    }
});
Ext.define("Ext.button.Split", {
    alias             : "widget.splitbutton",
    extend            : "Ext.button.Button",
    alternateClassName: "Ext.SplitButton",
    arrowCls          : "split",
    split             : true,
    initComponent     : function() {
        this.callParent();
        this.addEvents("arrowclick")
    },
    setArrowHandler   : function(b, a) {
        this.arrowHandler = b;
        this.scope        = a
    },
    onClick           : function(c, a) {
        var b = this;
        c.preventDefault();
        if (!b.disabled) {
            if (b.overMenuTrigger) {
                b.maybeShowMenu();
                b.fireEvent("arrowclick", b, c);
                if (b.arrowHandler) {
                    b.arrowHandler.call(b.scope || b, b, c)
                }
            } else {
                b.doToggle();
                b.fireHandler(c)
            }
        }
    }
});
Ext.define("Ext.data.NodeInterface", {
    requires: ["Ext.data.Field", "Ext.data.writer.Json"],
    statics : {
        decorate        : function(b) {
            var a, c, d;
            if (typeof b == "string") {
                b = Ext.ModelManager.getModel(b)
            } else {
                if (b.isModel) {
                    b = Ext.ModelManager.getModel(b.modelName)
                }
            }
            if (b.prototype.isNode) {
                return
            }
            a = b.prototype.idProperty;
            c = b.prototype.fields.get(a);
            d = b.prototype.fields.get(a).type.type;
            b.override(this.getPrototypeBody());
            this.applyFields(b, [{
                name        : "parentId",
                type        : d,
                defaultValue: null,
                useNull     : c.useNull
            }, {
                name        : "index",
                type        : "int",
                defaultValue: 0,
                persist     : false,
                convert     : null
            }, {
                name        : "depth",
                type        : "int",
                defaultValue: 0,
                persist     : false,
                convert     : null
            }, {
                name        : "expanded",
                type        : "bool",
                defaultValue: false,
                persist     : false,
                convert     : null
            }, {
                name        : "expandable",
                type        : "bool",
                defaultValue: true,
                persist     : false,
                convert     : null
            }, {
                name        : "checked",
                type        : "auto",
                defaultValue: null,
                persist     : false,
                convert     : null
            }, {
                name        : "leaf",
                type        : "bool",
                defaultValue: false
            }, {
                name        : "cls",
                type        : "string",
                defaultValue: "",
                persist     : false,
                convert     : null
            }, {
                name        : "iconCls",
                type        : "string",
                defaultValue: "",
                persist     : false,
                convert     : null
            }, {
                name        : "icon",
                type        : "string",
                defaultValue: "",
                persist     : false,
                convert     : null
            }, {
                name        : "root",
                type        : "boolean",
                defaultValue: false,
                persist     : false,
                convert     : null
            }, {
                name        : "isLast",
                type        : "boolean",
                defaultValue: false,
                persist     : false,
                convert     : null
            }, {
                name        : "isFirst",
                type        : "boolean",
                defaultValue: false,
                persist     : false,
                convert     : null
            }, {
                name        : "allowDrop",
                type        : "boolean",
                defaultValue: true,
                persist     : false,
                convert     : null
            }, {
                name        : "allowDrag",
                type        : "boolean",
                defaultValue: true,
                persist     : false,
                convert     : null
            }, {
                name        : "loaded",
                type        : "boolean",
                defaultValue: false,
                persist     : false,
                convert     : null
            }, {
                name        : "loading",
                type        : "boolean",
                defaultValue: false,
                persist     : false,
                convert     : null
            }, {
                name        : "href",
                type        : "string",
                defaultValue: "",
                persist     : false,
                convert     : null
            }, {
                name        : "hrefTarget",
                type        : "string",
                defaultValue: "",
                persist     : false,
                convert     : null
            }, {
                name        : "qtip",
                type        : "string",
                defaultValue: "",
                persist     : false,
                convert     : null
            }, {
                name        : "qtitle",
                type        : "string",
                defaultValue: "",
                persist     : false,
                convert     : null
            }, {
                name        : "qshowDelay",
                type        : "int",
                defaultValue: 0,
                persist     : false,
                convert     : null
            }, {
                name        : "children",
                type        : "auto",
                defaultValue: null,
                persist     : false,
                convert     : null
            }])
        },
        applyFields     : function(c, b) {
            var g = c.prototype, a = g.fields, f = a.keys, e = b.length, h, d;
            for (d = 0; d < e; d++) {
                h = b[d];
                if (!Ext.Array.contains(f, h.name)) {
                    a.add(new Ext.data.Field(h))
                }
            }
        },
        getPrototypeBody: function() {
            var a = {
                idchanged     : true,
                append        : true,
                remove        : true,
                move          : true,
                insert        : true,
                beforeappend  : true,
                beforeremove  : true,
                beforemove    : true,
                beforeinsert  : true,
                expand        : true,
                collapse      : true,
                beforeexpand  : true,
                beforecollapse: true,
                sort          : true,
                rootchange    : true
            };
            return {
                isNode               : true,
                constructor          : function() {
                    var b = this;
                    b.callParent(arguments);
                    b.firstChild = b.lastChild = b.parentNode = b.previousSibling = b.nextSibling = null;
                    b.childNodes = [];
                    return b
                },
                createNode           : function(b) {
                    if (!b.isModel) {
                        b = Ext.ModelManager.create(b, this.modelName)
                    }
                    if (!b.childNodes) {
                        b.firstChild = b.lastChild = b.parentNode = b.previousSibling = b.nextSibling = null;
                        b.childNodes = []
                    }
                    return b
                },
                isLeaf               : function() {
                    return this.get("leaf") === true
                },
                setFirstChild        : function(b) {
                    this.firstChild = b
                },
                setLastChild         : function(b) {
                    this.lastChild = b
                },
                updateInfo           : function(h, d) {
                    var m = this, l = m.data.depth, o = {}, c = m.childNodes, g = c.length, j, f = m.phantom, e = m[m.persistenceProperty], k, b, n;
                    if (!d) {
                        Ext.Error.raise("NodeInterface expects update info to be passed")
                    }
                    for (k in d) {
                        n = m.fields.get(k);
                        b = d[k];
                        if (n && n.persist) {
                            m.dirty = m.dirty || !m.isEqual(e[k], b)
                        }
                        e[k] = b
                    }
                    if (h) {
                        m.commit();
                        m.phantom = f
                    }
                    if (m.data.depth !== l) {
                        o = {depth: m.data.depth + 1};
                        for (j = 0; j < g; j++) {
                            c[j].updateInfo(h, o)
                        }
                    }
                },
                isLast               : function() {
                    return this.get("isLast")
                },
                isFirst              : function() {
                    return this.get("isFirst")
                },
                hasChildNodes        : function() {
                    return !this.isLeaf() && this.childNodes.length > 0
                },
                isExpandable         : function() {
                    var b = this;
                    if (b.get("expandable")) {
                        return !(b.isLeaf() || (b.isLoaded() && !b.hasChildNodes()))
                    }
                    return false
                },
                triggerUIUpdate      : function() {
                    this.afterEdit([])
                },
                appendChild          : function(c, k, d) {
                    var h = this, e, g, f, j, b, l = {
                        isLast  : true,
                        parentId: h.getId(),
                        depth   : (h.data.depth || 0) + 1
                    };
                    if (Ext.isArray(c)) {
                        h.callStore("suspendAutoSync");
                        for (e = 0, g = c.length - 1; e < g; e++) {
                            h.appendChild(c[e], k, d)
                        }
                        h.callStore("resumeAutoSync");
                        h.appendChild(c[g], k, d)
                    } else {
                        c = h.createNode(c);
                        if (k !== true && h.fireEventArgs("beforeappend", [h, c]) === false) {
                            return false
                        }
                        f = h.childNodes.length;
                        j = c.parentNode;
                        if (j) {
                            if (k !== true && c.fireEventArgs("beforemove", [c, j, h, f]) === false) {
                                return false
                            }
                            j.removeChild(c, false, false, true)
                        }
                        Ext.suspendLayouts();
                        f = h.childNodes.length;
                        if (f === 0) {
                            h.setFirstChild(c)
                        }
                        h.childNodes[f] = c;
                        c.parentNode    = h;
                        c.nextSibling   = null;
                        h.setLastChild(c);
                        b = h.childNodes[f - 1];
                        if (b) {
                            c.previousSibling = b;
                            b.nextSibling     = c;
                            b.updateInfo(d, {isLast: false});
                            b.triggerUIUpdate()
                        } else {
                            c.previousSibling = null
                        }
                        l.isFirst = f === 0;
                        l.index   = f;
                        c.updateInfo(d, l);
                        if (!h.isLoaded()) {
                            h.set("loaded", true)
                        } else {
                            if (h.childNodes.length === 1) {
                                h.triggerUIUpdate()
                            }
                        }
                        if (f && h.childNodes[f - 1].isExpanded()) {
                            h.childNodes[f - 1].cascadeBy(h.triggerUIUpdate)
                        }
                        if (!c.isLeaf() && c.phantom) {
                            c.set("loaded", true)
                        }
                        Ext.resumeLayouts(true);
                        if (k !== true) {
                            h.fireEventArgs("append", [h, c, f]);
                            if (j) {
                                c.fireEventArgs("move", [c, j, h, f])
                            }
                        }
                        return c
                    }
                },
                getOwnerTree         : function() {
                    var c = this, b;
                    while (c.parentNode) {
                        c = c.parentNode
                    }
                    b = c.store;
                    if (b) {
                        if (b.treeStore) {
                            b = b.treeStore
                        }
                        if (b.tree) {
                            return b.ownerTree
                        }
                    }
                    return undefined
                },
                removeChild          : function(c, h, k, j) {
                    var g = this, f = g.indexOf(c), e, d, b;
                    if (f === -1 || (k !== true && g.fireEventArgs("beforeremove", [g, c, !!j]) === false)) {
                        return false
                    }
                    Ext.suspendLayouts();
                    Ext.Array.erase(g.childNodes, f, 1);
                    if (g.firstChild === c) {
                        g.setFirstChild(c.nextSibling)
                    }
                    if (g.lastChild === c) {
                        g.setLastChild(c.previousSibling)
                    }
                    if (b = c.previousSibling) {
                        c.previousSibling.nextSibling = c.nextSibling
                    }
                    if (c.nextSibling) {
                        c.nextSibling.previousSibling = c.previousSibling;
                        if (f === 0) {
                            c.nextSibling.updateInfo(false, {isFirst: true})
                        }
                        for (e = f, d = g.childNodes.length; e < d; e++) {
                            g.childNodes[e].updateInfo(false, {index: e})
                        }
                    } else {
                        if (b) {
                            b.updateInfo(false, {isLast: true});
                            if (b.isExpanded()) {
                                b.cascadeBy(g.triggerUIUpdate)
                            } else {
                                b.triggerUIUpdate()
                            }
                        }
                    }
                    if (!g.childNodes.length) {
                        g.triggerUIUpdate()
                    }
                    Ext.resumeLayouts(true);
                    if (k !== true) {
                        c.removeContext   = {
                            parentNode     : c.parentNode,
                            previousSibling: c.previousSibling,
                            nextSibling    : c.nextSibling
                        };
                        c.previousSibling = c.nextSibling = c.parentNode = null;
                        g.fireEventArgs("remove", [g, c, !!j]);
                        c.removeContext = null
                    }
                    if (h) {
                        c.destroy(true)
                    } else {
                        c.clear()
                    }
                    return c
                },
                copy                 : function(e, d) {
                    var g = this, c = g.callParent(arguments), b = g.childNodes ? g.childNodes.length : 0, f;
                    if (d) {
                        for (f = 0; f < b; f++) {
                            c.appendChild(g.childNodes[f].copy(undefined, true))
                        }
                    }
                    return c
                },
                clear                : function(b) {
                    var c        = this;
                    c.parentNode = c.previousSibling = c.nextSibling = null;
                    if (b) {
                        c.firstChild = c.lastChild = null
                    }
                },
                destroy              : function(c) {
                    var e = this, d = e.destroyOptions, b = e.childNodes, f = b.length, g;
                    if (c === true) {
                        e.clear(true);
                        for (g = 0; g < f; g++) {
                            b[g].destroy(true)
                        }
                        e.childNodes = null;
                        delete e.destroyOptions;
                        e.callParent([d])
                    } else {
                        e.destroyOptions = c;
                        e.remove(true)
                    }
                },
                insertBefore         : function(c, g, l) {
                    var h = this, f = h.indexOf(g), j = c.parentNode, k = f, d, b, e;
                    if (!g) {
                        return h.appendChild(c)
                    }
                    if (c === g) {
                        return false
                    }
                    c = h.createNode(c);
                    if (l !== true && h.fireEventArgs("beforeinsert", [h, c, g]) === false) {
                        return false
                    }
                    if (j === h && h.indexOf(c) < f) {
                        k--
                    }
                    if (j) {
                        if (l !== true && c.fireEventArgs("beforemove", [c, j, h, f, g]) === false) {
                            return false
                        }
                        j.removeChild(c, false, false, true)
                    }
                    if (k === 0) {
                        h.setFirstChild(c)
                    }
                    Ext.Array.splice(h.childNodes, k, 0, c);
                    c.parentNode      = h;
                    c.nextSibling     = g;
                    g.previousSibling = c;
                    b                 = h.childNodes[k - 1];
                    if (b) {
                        c.previousSibling = b;
                        b.nextSibling     = c
                    } else {
                        c.previousSibling = null
                    }
                    c.updateInfo(false, {
                        parentId: h.getId(),
                        index   : k,
                        isFirst : k === 0,
                        isLast  : false,
                        depth   : (h.data.depth || 0) + 1
                    });
                    for (e = k + 1, d = h.childNodes.length; e < d; e++) {
                        h.childNodes[e].updateInfo(false, {index: e})
                    }
                    if (!h.isLoaded()) {
                        h.set("loaded", true)
                    } else {
                        if (h.childNodes.length === 1) {
                            h.triggerUIUpdate()
                        }
                    }
                    if (!c.isLeaf() && c.phantom) {
                        c.set("loaded", true)
                    }
                    if (l !== true) {
                        h.fireEventArgs("insert", [h, c, g]);
                        if (j) {
                            c.fireEventArgs("move", [c, j, h, k, g])
                        }
                    }
                    return c
                },
                insertChild          : function(b, d) {
                    var c = this.childNodes[b];
                    if (c) {
                        return this.insertBefore(d, c)
                    } else {
                        return this.appendChild(d)
                    }
                },
                remove               : function(c, d) {
                    var e = this, b = e.parentNode;
                    if (b) {
                        b.removeChild(e, c, d)
                    } else {
                        if (c) {
                            e.destroy(true)
                        }
                    }
                    return e
                },
                removeAll            : function(d, e, j) {
                    var g = this, h = g.childNodes, c = 0, b = h.length, f;
                    if (!b) {
                        return
                    }
                    g.fireEventArgs("bulkremove", [g, h, false]);
                    for (; c < b; ++c) {
                        f                 = h[c];
                        f.removeContext   = {
                            parentNode     : f.parentNode,
                            previousSibling: f.previousSibling,
                            nextSibling    : f.nextSibling
                        };
                        f.previousSibling = f.nextSibling = f.parentNode = null;
                        g.fireEventArgs("remove", [g, f, false]);
                        f.removeContext = null;
                        if (d) {
                            f.destroy(true)
                        } else {
                            f.removeAll(false, e, true)
                        }
                    }
                    g.firstChild = g.lastChild = null;
                    if (j) {
                        g.childNodes = null
                    } else {
                        g.childNodes.length = 0;
                        g.triggerUIUpdate()
                    }
                    return g
                },
                getChildAt           : function(b) {
                    return this.childNodes[b]
                },
                replaceChild         : function(b, e, d) {
                    var c = e ? e.nextSibling : null;
                    this.removeChild(e, false, d);
                    this.insertBefore(b, c, d);
                    return e
                },
                indexOf              : function(b) {
                    return Ext.Array.indexOf(this.childNodes, b)
                },
                indexOfId            : function(e) {
                    var d = this.childNodes, b = d.length, c = 0;
                    for (; c < b; ++c) {
                        if (d[c].getId() === e) {
                            return c
                        }
                    }
                    return -1
                },
                getPath              : function(e, d) {
                    e     = e || this.idProperty;
                    d     = d || "/";
                    var c = [this.get(e)], b = this.parentNode;
                    while (b) {
                        c.unshift(b.get(e));
                        b = b.parentNode
                    }
                    return d + c.join(d)
                },
                getDepth             : function() {
                    return this.get("depth")
                },
                bubble               : function(d, c, b) {
                    var e = this;
                    while (e) {
                        if (d.apply(c || e, b || [e]) === false) {
                            break
                        }
                        e = e.parentNode
                    }
                },
                cascade              : function() {
                    if (Ext.isDefined(Ext.global.console)) {
                        Ext.global.console.warn("Ext.data.Node: cascade has been deprecated. Please use cascadeBy instead.")
                    }
                    return this.cascadeBy.apply(this, arguments)
                },
                cascadeBy            : function(e, d, b) {
                    if (e.apply(d || this, b || [this]) !== false) {
                        var g = this.childNodes, f = g.length, c;
                        for (c = 0; c < f; c++) {
                            g[c].cascadeBy(e, d, b)
                        }
                    }
                },
                eachChild            : function(e, d, b) {
                    var g = this.childNodes, f = g.length, c;
                    for (c = 0; c < f; c++) {
                        if (e.apply(d || this, b || [g[c]]) === false) {
                            break
                        }
                    }
                },
                findChild            : function(c, d, b) {
                    return this.findChildBy(function() {
                        return this.get(c) == d
                    }, null, b)
                },
                findChildBy          : function(h, g, c) {
                    var f = this.childNodes, b = f.length, e = 0, j, d;
                    for (; e < b; e++) {
                        j = f[e];
                        if (h.call(g || j, j) === true) {
                            return j
                        } else {
                            if (c) {
                                d = j.findChildBy(h, g, c);
                                if (d !== null) {
                                    return d
                                }
                            }
                        }
                    }
                    return null
                },
                contains             : function(b) {
                    return b.isAncestor(this)
                },
                isAncestor           : function(b) {
                    var c = this.parentNode;
                    while (c) {
                        if (c === b) {
                            return true
                        }
                        c = c.parentNode
                    }
                    return false
                },
                sort                 : function(g, c, b) {
                    var e = this.childNodes, f = e.length, d, j, h = {isFirst: true};
                    if (f > 0) {
                        Ext.Array.sort(e, g);
                        this.setFirstChild(e[0]);
                        this.setLastChild(e[f - 1]);
                        for (d = 0; d < f; d++) {
                            j                 = e[d];
                            j.previousSibling = e[d - 1];
                            j.nextSibling     = e[d + 1];
                            h.isLast          = (d === f - 1);
                            h.index           = d;
                            j.updateInfo(false, h);
                            h.isFirst = false;
                            if (c && !j.isLeaf()) {
                                j.sort(g, true, true)
                            }
                        }
                        if (b !== true) {
                            this.fireEventArgs("sort", [this, e])
                        }
                    }
                },
                isExpanded           : function() {
                    return this.get("expanded")
                },
                isLoaded             : function() {
                    return this.get("loaded")
                },
                isLoading            : function() {
                    return this.get("loading")
                },
                isRoot               : function() {
                    return !this.parentNode
                },
                isVisible            : function() {
                    var b = this.parentNode;
                    while (b) {
                        if (!b.isExpanded()) {
                            return false
                        }
                        b = b.parentNode
                    }
                    return true
                },
                expand               : function(c, f, d) {
                    var e = this, b;
                    if (!e.isLeaf()) {
                        if (e.isLoading()) {
                            e.on("expand", function() {
                                e.expand(c, f, d)
                            }, e, {single: true})
                        } else {
                            if (!e.isExpanded()) {
                                e.fireEventArgs("beforeexpand", [e, e.onChildNodesAvailable, e, [c, f, d]])
                            } else {
                                if (c) {
                                    b = e.getOwnerTree();
                                    e.expandChildren(true, b ? b.singleExpand : false, f, d)
                                } else {
                                    Ext.callback(f, d || e, [e.childNodes])
                                }
                            }
                        }
                    } else {
                        Ext.callback(f, d || e)
                    }
                },
                onChildNodesAvailable: function(c, d, g, e) {
                    var f = this, b;
                    Ext.suspendLayouts();
                    f.set("expanded", true);
                    f.fireEventArgs("expand", [f, f.childNodes, false]);
                    if (d) {
                        b = f.getOwnerTree();
                        f.expandChildren(true, b ? b.singleExpand : false, g, e)
                    } else {
                        Ext.callback(g, e || f, [f.childNodes])
                    }
                    Ext.resumeLayouts(true)
                },
                expandChildren       : function(e, f, k, l) {
                    var j = this, g, c = j.childNodes, b = [], h = f ? Math.min(c.length, 1) : c.length, d;
                    for (g = 0; g < h; ++g) {
                        d = c[g];
                        if (!d.isLeaf()) {
                            b[b.length] = d
                        }
                    }
                    h = b.length;
                    for (g = 0; g < h; ++g) {
                        b[g].expand(e)
                    }
                    if (k) {
                        Ext.callback(k, l || j, [j.childNodes])
                    }
                },
                collapse             : function(d, j, f) {
                    var g = this, c = g.isExpanded(), b = g.childNodes.length, e, h;
                    if (!g.isLeaf() && ((!c && d) || g.fireEventArgs("beforecollapse", [g]) !== false)) {
                        Ext.suspendLayouts();
                        if (g.isExpanded()) {
                            if (d) {
                                h = function() {
                                    for (e = 0; e < b; e++) {
                                        g.childNodes[e].setCollapsed(true)
                                    }
                                };
                                if (j) {
                                    j = Ext.Function.createSequence(h, j)
                                } else {
                                    j = h
                                }
                            }
                            g.set("expanded", false);
                            g.fireEventArgs("collapse", [g, g.childNodes, false, j ? Ext.Function.bind(j, f, [g.childNodes]) : null, null]);
                            j = null
                        } else {
                            if (d) {
                                for (e = 0; e < b; e++) {
                                    g.childNodes[e].setCollapsed(true)
                                }
                            }
                        }
                        Ext.resumeLayouts(true)
                    }
                    Ext.callback(j, f || g, [g.childNodes])
                },
                setCollapsed         : function(c) {
                    var e = this, b = e.childNodes.length, d;
                    if (!e.isLeaf() && e.fireEventArgs("beforecollapse", [e, Ext.emptyFn]) !== false) {
                        e.data.expanded = false;
                        e.fireEventArgs("collapse", [e, e.childNodes, false, null, null]);
                        if (c) {
                            for (d = 0; d < b; d++) {
                                e.childNodes[d].setCollapsed(true)
                            }
                        }
                    }
                },
                collapseChildren     : function(d, j, k) {
                    var h = this, f, b = h.childNodes, g = b.length, e = [], c;
                    for (f = 0; f < g; ++f) {
                        c = b[f];
                        if (!c.isLeaf() && c.isLoaded() && c.isExpanded()) {
                            e.push(c)
                        }
                    }
                    g = e.length;
                    for (f = 0; f < g; ++f) {
                        c = e[f];
                        if (f === g - 1) {
                            c.collapse(d, j, k)
                        } else {
                            c.collapse(d)
                        }
                    }
                },
                fireEventArgs        : function(e, f) {
                    var i = Ext.data.Model.prototype.fireEventArgs, c, h, b, g, d;
                    if (a[e]) {
                        for (h = this; c !== false && h; h = (d = h).parentNode) {
                            if (h.hasListeners[e]) {
                                c = i.call(h, e, f)
                            }
                        }
                        b = d.rootOf;
                        if (c !== false && b) {
                            g = b.treeStore;
                            if (g && g.hasListeners[e]) {
                                c = g.fireEventArgs.call(g, e, f)
                            }
                            if (c !== false && b.hasListeners[e]) {
                                c = b.fireEventArgs.call(b, e, f)
                            }
                        }
                        return c
                    } else {
                        return i.apply(this, arguments)
                    }
                },
                serialize            : function() {
                    var c = Ext.data.writer.Json.prototype.getRecordData(this), f = this.childNodes, b = f.length, e, d;
                    if (b > 0) {
                        e = [];
                        for (d = 0; d < b; d++) {
                            e.push(f[d].serialize())
                        }
                        c.children = e
                    }
                    return c
                }
            }
        }
    }
});
Ext.define("Ext.data.NodeStore", {
    extend                 : "Ext.data.Store",
    alias                  : "store.node",
    requires               : ["Ext.data.NodeInterface"],
    isNodeStore            : true,
    node                   : null,
    recursive              : false,
    rootVisible            : false,
    isExpandingOrCollapsing: 0,
    constructor            : function(a) {
        var c = this, b;
        a     = a || {};
        Ext.apply(c, a);
        a.proxy = {type: "proxy"};
        c.callParent([a]);
        b = c.node;
        if (b) {
            c.node = null;
            c.setNode(b)
        }
    },
    getTotalCount          : function() {
        return this.getCount()
    },
    setNode                : function(b) {
        var a = this;
        if (a.node && a.node != b) {
            a.mun(a.node, {
                expand    : a.onNodeExpand,
                collapse  : a.onNodeCollapse,
                append    : a.onNodeAppend,
                insert    : a.onNodeInsert,
                bulkremove: a.onBulkRemove,
                remove    : a.onNodeRemove,
                sort      : a.onNodeSort,
                scope     : a
            });
            a.node = null
        }
        if (b) {
            Ext.data.NodeInterface.decorate(b.self);
            a.removeAll();
            if (a.rootVisible) {
                a.add(b)
            } else {
                if (!b.isExpanded() && a.treeStore.autoLoad !== false) {
                    b.expand()
                }
            }
            a.mon(b, {
                expand    : a.onNodeExpand,
                collapse  : a.onNodeCollapse,
                append    : a.onNodeAppend,
                insert    : a.onNodeInsert,
                bulkremove: a.onBulkRemove,
                remove    : a.onNodeRemove,
                sort      : a.onNodeSort,
                scope     : a
            });
            a.node = b;
            if (b.isExpanded() && b.isLoaded()) {
                a.onNodeExpand(b, b.childNodes, true)
            }
        }
    },
    onNodeSort             : function(b, c) {
        var a = this;
        if ((a.indexOf(b) !== -1 || (b === a.node && !a.rootVisible) && b.isExpanded())) {
            Ext.suspendLayouts();
            a.onNodeCollapse(b, c, true);
            a.onNodeExpand(b, c, true);
            Ext.resumeLayouts(true)
        }
    },
    onNodeExpand           : function(e, c, b) {
        var f = this, a = f.indexOf(e) + 1, d = [];
        if (!b) {
            f.fireEvent("beforeexpand", e, c, a)
        }
        f.handleNodeExpand(e, c, d);
        f.insert(a, d);
        if (!b) {
            f.fireEvent("expand", e, c)
        }
    },
    handleNodeExpand       : function(e, b, d) {
        var g = this, f = b ? b.length : 0, c, a;
        if (!g.recursive && e !== g.node) {
            return
        }
        if (e !== this.node && !g.isVisible(e)) {
            return
        }
        if (f) {
            for (c = 0; c < f; c++) {
                a = b[c];
                d.push(a);
                if (a.isExpanded()) {
                    if (a.isLoaded()) {
                        g.handleNodeExpand(a, a.childNodes, d)
                    } else {
                        a.set("expanded", false);
                        a.expand()
                    }
                }
            }
        }
    },
    onBulkRemove           : function(b, c, a) {
        this.onNodeCollapse(b, c, true)
    },
    onNodeCollapse         : function(e, c, i, h, j) {
        var d = this, g = d.indexOf(e) + 1, b, a, f, k;
        if (!d.recursive && e !== d.node) {
            return
        }
        if (!i) {
            d.fireEvent("beforecollapse", e, c, g, h, j)
        }
        if (c.length && d.data.contains(c[0])) {
            b = e;
            while (b.parentNode) {
                f = b.nextSibling;
                if (f) {
                    k = true;
                    a = d.indexOf(f);
                    break
                } else {
                    b = b.parentNode
                }
            }
            if (!k) {
                a = d.getCount()
            }
            d.removeAt(g, a - g)
        }
        if (!i) {
            d.fireEvent("collapse", e, c, g)
        }
    },
    onNodeAppend           : function(d, f, b) {
        var e = this, a, c;
        if (e.isVisible(f)) {
            if (b === 0) {
                a = d
            } else {
                c = f.previousSibling;
                while (c.isExpanded() && c.lastChild) {
                    c = c.lastChild
                }
                a = c
            }
            e.insert(e.indexOf(a) + 1, f);
            if (!f.isLeaf() && f.isExpanded()) {
                if (f.isLoaded()) {
                    e.onNodeExpand(f, f.childNodes, true)
                } else {
                    if (!e.treeStore.fillCount) {
                        f.set("expanded", false);
                        f.expand()
                    }
                }
            }
        }
    },
    onNodeInsert           : function(c, e, a) {
        var d = this, b = this.indexOf(a);
        if (b != -1 && d.isVisible(e)) {
            d.insert(b, e);
            if (!e.isLeaf() && e.isExpanded()) {
                if (e.isLoaded()) {
                    d.onNodeExpand(e, e.childNodes, true)
                } else {
                    e.set("expanded", false);
                    e.expand()
                }
            }
        }
    },
    onNodeRemove           : function(b, d, a) {
        var c = this;
        if (c.indexOf(d) != -1) {
            if (!d.isLeaf() && d.isExpanded()) {
                d.parentNode  = d.removeContext.parentNode;
                d.nextSibling = d.removeContext.nextSibling;
                c.onNodeCollapse(d, d.childNodes, true);
                d.parentNode = d.nextSibling = null
            }
            c.remove(d)
        }
    },
    isVisible              : function(b) {
        var a = b.parentNode;
        while (a) {
            if (a === this.node && a.data.expanded) {
                return true
            }
            if (!a.data.expanded) {
                return false
            }
            a = a.parentNode
        }
        return false
    }
});
Ext.define("Ext.data.Tree", {
    alias          : "data.tree",
    mixins         : {observable: "Ext.util.Observable"},
    root           : null,
    constructor    : function(a) {
        var b = this;
        b.mixins.observable.constructor.call(b);
        if (a) {
            b.setRootNode(a)
        }
        b.on({
            scope    : b,
            idchanged: b.onNodeIdChanged,
            insert   : b.onNodeInsert,
            append   : b.onNodeAppend,
            remove   : b.onNodeRemove
        })
    },
    getRootNode    : function() {
        return this.root
    },
    setRootNode    : function(b) {
        var a  = this;
        a.root = b;
        if (b.rootOf) {
            b.rootOf.removeRootNode()
        } else {
            if (b.parentNode) {
                b.parentNode.removeChild(b)
            }
        }
        b.rootOf = a;
        if (b.fireEventArgs("beforeappend", [null, b]) !== false) {
            b.set("root", true);
            b.updateInfo(true, {
                isFirst : true,
                isLast  : true,
                depth   : 0,
                index   : 0,
                parentId: null
            });
            a.nodeHash = {};
            b.fireEvent("append", null, b);
            b.fireEvent("rootchange", b)
        }
        return b
    },
    removeRootNode : function() {
        var b = this, a = b.root;
        a.set("root", false);
        a.fireEvent("remove", null, a, false);
        a.fireEvent("rootchange", null);
        a.rootOf = b.root = null;
        return a
    },
    flatten        : function() {
        return Ext.Object.getValues(this.nodeHash)
    },
    onNodeInsert   : function(a, b) {
        this.registerNode(b, true)
    },
    onNodeAppend   : function(a, b) {
        this.registerNode(b, true)
    },
    onNodeRemove   : function(a, b) {
        this.unregisterNode(b, true)
    },
    onNodeIdChanged: function(d, e, b, a) {
        var c           = this.nodeHash;
        c[d.internalId] = d;
        delete c[a]
    },
    getNodeById    : function(a) {
        return this.nodeHash[a]
    },
    registerNode   : function(f, a) {
        var e                    = this, c, d, b;
        e.nodeHash[f.internalId] = f;
        if (a === true) {
            c = f.childNodes;
            d = c.length;
            for (b = 0; b < d; b++) {
                e.registerNode(c[b], true)
            }
        }
    },
    unregisterNode : function(f, a) {
        var e = this, c, d, b;
        delete e.nodeHash[f.internalId];
        if (a === true) {
            c = f.childNodes;
            d = c.length;
            for (b = 0; b < d; b++) {
                e.unregisterNode(c[b], true)
            }
        }
    },
    sort           : function(b, a) {
        this.getRootNode().sort(b, a)
    },
    filter         : function(b, a) {
        this.getRootNode().filter(b, a)
    }
});
Ext.define("Ext.data.TreeStore", {
    extend             : "Ext.data.AbstractStore",
    alias              : "store.tree",
    requires           : ["Ext.util.Sorter", "Ext.data.Tree", "Ext.data.NodeInterface"],
    clearOnLoad        : true,
    clearRemovedOnLoad : true,
    nodeParam          : "node",
    defaultRootId      : "root",
    defaultRootText    : "Root",
    defaultRootProperty: "children",
    rootProperty       : "children",
    fillCount          : 0,
    folderSort         : false,
    constructor        : function(c) {
        var e = this, b, a, d;
        c     = Ext.apply({}, c);
        a     = c.fields || e.fields;
        if (!a) {
            c.fields = [{
                name: "text",
                type: "string"
            }];
            d        = c.defaultRootProperty || e.defaultRootProperty;
            if (d !== e.defaultRootProperty) {
                c.fields.push({
                    name        : d,
                    type        : "auto",
                    defaultValue: null,
                    persist     : false
                })
            }
        }
        e.callParent([c]);
        e.tree           = new Ext.data.Tree();
        e.tree.treeStore = e;
        e.tree.on({
            scope       : e,
            remove      : e.onNodeRemove,
            beforeexpand: e.onBeforeNodeExpand,
            append      : e.onNodeAdded,
            insert      : e.onNodeAdded,
            sort        : e.onNodeSort
        });
        e.onBeforeSort();
        b = e.root;
        if (b) {
            delete e.root;
            e.setRootNode(b)
        }
        if (Ext.isDefined(e.nodeParameter)) {
            if (Ext.isDefined(Ext.global.console)) {
                Ext.global.console.warn("Ext.data.TreeStore: nodeParameter has been deprecated. Please use nodeParam instead.")
            }
            e.nodeParam = e.nodeParameter;
            delete e.nodeParameter
        }
    },
    setProxy           : function(c) {
        var a, b;
        if (c instanceof Ext.data.proxy.Proxy) {
            b = Ext.isEmpty(c.getReader().root)
        } else {
            if (Ext.isString(c)) {
                b = true
            } else {
                a = c.reader;
                b = !(a && !Ext.isEmpty(a.root))
            }
        }
        c         = this.callParent(arguments);
        c.idParam = this.nodeParam;
        if (b) {
            a      = c.getReader();
            a.root = this.defaultRootProperty;
            a.buildExtractors(true)
        }
        return c
    },
    onBeforeSort       : function() {
        if (this.folderSort) {
            this.sort({
                property : "leaf",
                direction: "ASC"
            }, "prepend", false)
        }
    },
    onBeforeNodeExpand : function(a, h, i, e) {
        var f = this, d, g, c, b;
        if (a.isLoaded()) {
            b = [a.childNodes];
            if (e) {
                b.push.apply(b, e)
            }
            Ext.callback(h, i || a, b)
        } else {
            if (g = (c = (a.raw || a[a.persistenceProperty])[(d = f.getProxy().getReader()).root])) {
                f.fillNode(a, d.extractData(g));
                delete c[d.root];
                b = [a.childNodes];
                if (e) {
                    b.push.apply(b, e)
                }
                Ext.callback(h, i || a, b)
            } else {
                if (a.isLoading()) {
                    f.on("load", function() {
                        b = [a.childNodes];
                        if (e) {
                            b.push.apply(b, e)
                        }
                        Ext.callback(h, i || a, b)
                    }, f, {single: true})
                } else {
                    f.read({
                        node    : a,
                        callback: function() {
                            delete f.lastOptions.callback;
                            b = [a.childNodes];
                            if (e) {
                                b.push.apply(b, e)
                            }
                            Ext.callback(h, i || a, b)
                        }
                    })
                }
            }
        }
    },
    getNewRecords      : function() {
        return Ext.Array.filter(this.tree.flatten(), this.filterNew)
    },
    getUpdatedRecords  : function() {
        return Ext.Array.filter(this.tree.flatten(), this.filterUpdated)
    },
    onNodeRemove       : function(b, d, a) {
        var c = this;
        d.unjoin(c);
        if (!d.phantom && !a) {
            Ext.Array.include(c.removed, d)
        }
        if (c.autoSync && !c.autoSyncSuspended && !a) {
            c.sync()
        }
    },
    onNodeAdded        : function(c, e) {
        var d = this, b = d.getProxy(), a = b.getReader(), f = e.raw || e[e.persistenceProperty], g;
        Ext.Array.remove(d.removed, e);
        e.join(d);
        if (!e.isLeaf() && !d.lazyFill) {
            g = a.getRoot(f);
            if (g) {
                d.fillNode(e, a.extractData(g));
                delete f[a.root]
            }
        }
        if (d.autoSync && !d.autoSyncSuspended && (e.phantom || e.dirty)) {
            d.sync()
        }
    },
    onNodeSort         : function() {
        if (this.autoSync && !this.autoSyncSuspended) {
            this.sync()
        }
    },
    setRootNode        : function(a, e) {
        var d = this, c = d.model, b = c.prototype.idProperty;
        a     = a || {};
        if (!a.isModel) {
            a = Ext.apply({}, a);
            Ext.applyIf(a, {
                id       : d.defaultRootId,
                text     : d.defaultRootText,
                allowDrag: false
            });
            if (a[b] === undefined) {
                a[b] = d.defaultRootId
            }
            Ext.data.NodeInterface.decorate(c);
            a = Ext.ModelManager.create(a, c)
        } else {
            if (a.isModel && !a.isNode) {
                Ext.data.NodeInterface.decorate(c)
            }
        }
        d.getProxy().getReader().buildExtractors(true);
        d.tree.setRootNode(a);
        if (e !== true && !a.isLoaded() && (d.autoLoad === true || a.isExpanded())) {
            a.data.expanded = false;
            a.expand()
        }
        return a
    },
    getRootNode        : function() {
        return this.tree.getRootNode()
    },
    getNodeById        : function(a) {
        return this.tree.getNodeById(a)
    },
    getById            : function(a) {
        return this.getNodeById(a)
    },
    load               : function(a) {
        a        = a || {};
        a.params = a.params || {};
        var c    = this, b = a.node || c.tree.getRootNode();
        if (!b) {
            b = c.setRootNode({expanded: true}, true)
        }
        a.id = b.getId();
        if (c.clearOnLoad) {
            if (c.clearRemovedOnLoad) {
                c.clearRemoved(b)
            }
            c.tree.un("remove", c.onNodeRemove, c);
            b.removeAll(false);
            c.tree.on("remove", c.onNodeRemove, c)
        }
        Ext.applyIf(a, {node: b});
        c.callParent([a]);
        if (c.loading && b) {
            b.set("loading", true)
        }
        return c
    },
    clearRemoved       : function(b) {
        var j = this, e = j.removed, a = b.getId(), d = e.length, c = d, m = {}, g = [], l = {}, h, f, k;
        if (b === j.getRootNode()) {
            j.removed = [];
            return
        }
        for (; c--;) {
            h            = e[c];
            l[h.getId()] = h
        }
        for (c = d; c--;) {
            h = e[c];
            f = h;
            while (f && f.getId() !== a) {
                k = f.get("parentId");
                f = f.parentNode || j.getNodeById(k) || l[k]
            }
            if (f) {
                m[h.getId()] = h
            }
        }
        for (c = 0; c < d; c++) {
            h = e[c];
            if (!m[h.getId()]) {
                g.push(h)
            }
        }
        j.removed = g
    },
    fillNode           : function(b, c) {
        var g = this, e = c ? c.length : 0, f = g.sorters, d, j, h = false, a = e && g.sortOnLoad && !g.remoteSort && f && f.items && f.items.length, m, l, k;
        for (d = 1; d < e; d++) {
            m = c[d];
            l = c[d - 1];
            h = m[m.persistenceProperty].index != l[l.persistenceProperty].index;
            if (h) {
                break
            }
        }
        if (a) {
            if (h) {
                g.sorters.insert(0, g.indexSorter)
            }
            j = new Ext.util.MixedCollection();
            j.addAll(c);
            j.sort(g.sorters.items);
            c = j.items;
            g.sorters.remove(g.indexSorter)
        } else {
            if (h) {
                Ext.Array.sort(c, g.sortByIndex)
            }
        }
        b.set("loaded", true);
        k = g.fillCount === 0;
        if (k) {
            g.fireEvent("beforefill", g, b, c)
        }
        ++g.fillCount;
        if (c.length) {
            b.appendChild(c, undefined, true)
        }
        if (k) {
            g.fireEvent("fillcomplete", g, b, c)
        }
        --g.fillCount;
        return c
    },
    sortByIndex        : function(b, a) {
        return b[b.persistenceProperty].index - a[a.persistenceProperty].index
    },
    onIdChanged        : function(c, d, b, a) {
        this.tree.onNodeIdChanged(c, d, b, a);
        this.callParent(arguments)
    },
    onProxyLoad        : function(b) {
        var d     = this, e = b.wasSuccessful(), a = b.getRecords(), c = b.node;
        d.loading = false;
        c.set("loading", false);
        if (e) {
            if (!d.clearOnLoad) {
                a = d.cleanRecords(c, a)
            }
            a = d.fillNode(c, a)
        }
        d.fireEvent("read", d, b.node, a, e);
        d.fireEvent("load", d, b.node, a, e);
        Ext.callback(b.callback, b.scope || d, [a, b, e])
    },
    cleanRecords       : function(f, b) {
        var e = {}, h = f.childNodes, d = 0, a = h.length, c = [], g;
        for (; d < a; ++d) {
            e[h[d].getId()] = true
        }
        for (d = 0, a = b.length; d < a; ++d) {
            g = b[d];
            if (!e[g.getId()]) {
                c.push(g)
            }
        }
        return c
    },
    removeAll          : function() {
        var a = this.getRootNode();
        if (a) {
            a.destroy(true)
        }
        this.fireEvent("clear", this)
    },
    doSort             : function(a) {
        var b = this;
        if (b.remoteSort) {
            b.load()
        } else {
            b.tree.sort(a, true);
            b.fireEvent("datachanged", b);
            b.fireEvent("refresh", b)
        }
        b.fireEvent("sort", b, b.sorters.getRange())
    }
}, function() {
    var a         = this.prototype;
    a.indexSorter = new Ext.util.Sorter({sorterFn: a.sortByIndex})
});
Ext.define("Ext.dd.DragZone", {
    extend     : "Ext.dd.DragSource",
    constructor: function(c, b) {
        var d = this, a = d.containerScroll;
        d.callParent([c, b]);
        if (a) {
            c = d.scrollEl || c;
            c = Ext.get(c);
            if (Ext.isObject(a)) {
                c.ddScrollConfig = a
            }
            Ext.dd.ScrollManager.register(c)
        }
    },
    getDragData: function(a) {
        return Ext.dd.Registry.getHandleFromEvent(a)
    },
    onInitDrag : function(a, b) {
        this.proxy.update(this.dragData.ddel.cloneNode(true));
        this.onStartDrag(a, b);
        return true
    },
    getRepairXY: function(a) {
        return Ext.fly(this.dragData.ddel).getXY()
    },
    destroy    : function() {
        this.callParent();
        if (this.containerScroll) {
            Ext.dd.ScrollManager.unregister(this.scrollEl || this.el)
        }
    }
});
Ext.define("Ext.dd.ScrollManager", {
    singleton     : true,
    requires      : ["Ext.dd.DragDropManager"],
    constructor   : function() {
        var a            = Ext.dd.DragDropManager;
        a.fireEvents     = Ext.Function.createSequence(a.fireEvents, this.onFire, this);
        a.stopDrag       = Ext.Function.createSequence(a.stopDrag, this.onStop, this);
        this.doScroll    = Ext.Function.bind(this.doScroll, this);
        this.ddmInstance = a;
        this.els         = {};
        this.dragEl      = null;
        this.proc        = {}
    },
    onStop        : function(a) {
        var b    = Ext.dd.ScrollManager;
        b.dragEl = null;
        b.clearProc()
    },
    triggerRefresh: function() {
        if (this.ddmInstance.dragCurrent) {
            this.ddmInstance.refreshCache(this.ddmInstance.dragCurrent.groups)
        }
    },
    doScroll      : function() {
        if (this.ddmInstance.dragCurrent) {
            var a = this.proc, b = a.el, c = a.el.ddScrollConfig, d = c ? c.increment : this.increment;
            if (!this.animate) {
                if (b.scroll(a.dir, d)) {
                    this.triggerRefresh()
                }
            } else {
                b.scroll(a.dir, d, true, this.animDuration, this.triggerRefresh)
            }
        }
    },
    clearProc     : function() {
        var a = this.proc;
        if (a.id) {
            clearInterval(a.id)
        }
        a.id  = 0;
        a.el  = null;
        a.dir = ""
    },
    startProc     : function(b, a) {
        this.clearProc();
        this.proc.el  = b;
        this.proc.dir = a;
        var d         = b.ddScrollConfig ? b.ddScrollConfig.ddGroup : undefined, c = (b.ddScrollConfig && b.ddScrollConfig.frequency) ? b.ddScrollConfig.frequency : this.frequency;
        if (d === undefined || this.ddmInstance.dragCurrent.ddGroup == d) {
            this.proc.id = setInterval(this.doScroll, c)
        }
    },
    onFire        : function(g, j) {
        if (j || !this.ddmInstance.dragCurrent) {
            return
        }
        if (!this.dragEl || this.dragEl != this.ddmInstance.dragCurrent) {
            this.dragEl = this.ddmInstance.dragCurrent;
            this.refreshCache()
        }
        var k = g.getXY(), l = g.getPoint(), h = this.proc, f = this.els, b, d, a, i;
        for (b in f) {
            d = f[b];
            a = d._region;
            i = d.ddScrollConfig ? d.ddScrollConfig : this;
            if (a && a.contains(l) && d.isScrollable()) {
                if (a.bottom - l.y <= i.vthresh) {
                    if (h.el != d) {
                        this.startProc(d, "down")
                    }
                    return
                } else {
                    if (a.right - l.x <= i.hthresh) {
                        if (h.el != d) {
                            this.startProc(d, "left")
                        }
                        return
                    } else {
                        if (l.y - a.top <= i.vthresh) {
                            if (h.el != d) {
                                this.startProc(d, "up")
                            }
                            return
                        } else {
                            if (l.x - a.left <= i.hthresh) {
                                if (h.el != d) {
                                    this.startProc(d, "right")
                                }
                                return
                            }
                        }
                    }
                }
            }
        }
        this.clearProc()
    },
    register      : function(c) {
        if (Ext.isArray(c)) {
            for (var b = 0, a = c.length; b < a; b++) {
                this.register(c[b])
            }
        } else {
            c              = Ext.get(c);
            this.els[c.id] = c
        }
    },
    unregister    : function(c) {
        if (Ext.isArray(c)) {
            for (var b = 0, a = c.length; b < a; b++) {
                this.unregister(c[b])
            }
        } else {
            c = Ext.get(c);
            delete this.els[c.id]
        }
    },
    vthresh       : 25,
    hthresh       : 25,
    increment     : 100,
    frequency     : 500,
    animate       : true,
    animDuration  : 0.4,
    ddGroup       : undefined,
    refreshCache  : function() {
        var a = this.els, b;
        for (b in a) {
            if (typeof a[b] == "object") {
                a[b]._region = a[b].getRegion()
            }
        }
    }
});
Ext.define("Ext.dd.DropTarget", {
    extend        : "Ext.dd.DDTarget",
    requires      : ["Ext.dd.ScrollManager"],
    constructor   : function(b, a) {
        this.el = Ext.get(b);
        Ext.apply(this, a);
        if (this.containerScroll) {
            Ext.dd.ScrollManager.register(this.el)
        }
        this.callParent([this.el.dom, this.ddGroup || this.group, {isTarget: true}])
    },
    dropAllowed   : Ext.baseCSSPrefix + "dd-drop-ok",
    dropNotAllowed: Ext.baseCSSPrefix + "dd-drop-nodrop",
    isTarget      : true,
    isNotifyTarget: true,
    notifyEnter   : function(a, c, b) {
        if (this.overClass) {
            this.el.addCls(this.overClass)
        }
        return this.dropAllowed
    },
    notifyOver    : function(a, c, b) {
        return this.dropAllowed
    },
    notifyOut     : function(a, c, b) {
        if (this.overClass) {
            this.el.removeCls(this.overClass)
        }
    },
    notifyDrop    : function(a, c, b) {
        return false
    },
    destroy       : function() {
        this.callParent();
        if (this.containerScroll) {
            Ext.dd.ScrollManager.unregister(this.el)
        }
    }
});
Ext.define("Ext.dd.Registry", {
    singleton         : true,
    constructor       : function() {
        this.elements   = {};
        this.handles    = {};
        this.autoIdSeed = 0
    },
    getId             : function(b, a) {
        if (typeof b == "string") {
            return b
        }
        var c = b.id;
        if (!c && a !== false) {
            c    = "extdd-" + (++this.autoIdSeed);
            b.id = c
        }
        return c
    },
    register          : function(d, e) {
        e = e || {};
        if (typeof d == "string") {
            d = document.getElementById(d)
        }
        e.ddel                       = d;
        this.elements[this.getId(d)] = e;
        if (e.isHandle !== false) {
            this.handles[e.ddel.id] = e
        }
        if (e.handles) {
            var c = e.handles, b, a;
            for (b = 0, a = c.length; b < a; b++) {
                this.handles[this.getId(c[b])] = e
            }
        }
    },
    unregister        : function(d) {
        var f = this.getId(d, false), e = this.elements[f], c, b, a;
        if (e) {
            delete this.elements[f];
            if (e.handles) {
                c = e.handles;
                for (b = 0, a = c.length; b < a; b++) {
                    delete this.handles[this.getId(c[b], false)]
                }
            }
        }
    },
    getHandle         : function(a) {
        if (typeof a != "string") {
            a = a.id
        }
        return this.handles[a]
    },
    getHandleFromEvent: function(b) {
        var a = b.getTarget();
        return a ? this.handles[a.id] : null
    },
    getTarget         : function(a) {
        if (typeof a != "string") {
            a = a.id
        }
        return this.elements[a]
    },
    getTargetFromEvent: function(b) {
        var a = b.getTarget();
        return a ? this.elements[a.id] || this.handles[a.id] : null
    }
});
Ext.define("Ext.dd.DropZone", {
    extend             : "Ext.dd.DropTarget",
    requires           : ["Ext.dd.Registry"],
    getTargetFromEvent : function(a) {
        return Ext.dd.Registry.getTargetFromEvent(a)
    },
    onNodeEnter        : function(d, a, c, b) {
    },
    onNodeOver         : function(d, a, c, b) {
        return this.dropAllowed
    },
    onNodeOut          : function(d, a, c, b) {
    },
    onNodeDrop         : function(d, a, c, b) {
        return false
    },
    onContainerOver    : function(a, c, b) {
        return this.dropNotAllowed
    },
    onContainerDrop    : function(a, c, b) {
        return false
    },
    notifyEnter        : function(a, c, b) {
        return this.dropNotAllowed
    },
    notifyOver         : function(a, c, b) {
        var d = this.getTargetFromEvent(c);
        if (!d) {
            if (this.lastOverNode) {
                this.onNodeOut(this.lastOverNode, a, c, b);
                this.lastOverNode = null
            }
            return this.onContainerOver(a, c, b)
        }
        if (this.lastOverNode != d) {
            if (this.lastOverNode) {
                this.onNodeOut(this.lastOverNode, a, c, b)
            }
            this.onNodeEnter(d, a, c, b);
            this.lastOverNode = d
        }
        return this.onNodeOver(d, a, c, b)
    },
    notifyOut          : function(a, c, b) {
        if (this.lastOverNode) {
            this.onNodeOut(this.lastOverNode, a, c, b);
            this.lastOverNode = null
        }
    },
    notifyDrop         : function(b, f, d) {
        var c = this, g = c.getTargetFromEvent(f), a = g ? c.onNodeDrop(g, b, f, d) : c.onContainerDrop(b, f, d);
        if (c.lastOverNode) {
            c.onNodeOut(c.lastOverNode, b, f, d);
            c.lastOverNode = null
        }
        return a
    },
    triggerCacheRefresh: function() {
        Ext.dd.DDM.refreshCache(this.groups)
    }
});
Ext.define("Ext.layout.component.field.FieldContainer", {
    extend                 : "Ext.layout.component.field.Field",
    alias                  : "layout.fieldcontainer",
    type                   : "fieldcontainer",
    waitForOuterHeightInDom: true,
    waitForOuterWidthInDom : true,
    beginLayout            : function(b) {
        var a = this.owner;
        this.callParent(arguments);
        b.hasRawContent = true;
        a.bodyEl.setStyle("height", "");
        a.containerEl.setStyle("height", "");
        b.containerElContext = b.getEl("containerEl")
    },
    measureContentHeight   : function(a) {
        return a.hasDomProp("containerLayoutDone") ? this.callParent(arguments) : NaN
    },
    measureContentWidth    : function(a) {
        return a.hasDomProp("containerLayoutDone") ? this.callParent(arguments) : NaN
    },
    publishInnerWidth      : function(c, b) {
        var d = c.bodyCellContext, a = d.el.getWidth();
        d.setWidth(a, false);
        c.containerElContext.setWidth(a, false)
    },
    publishInnerHeight     : function(b, a) {
        var c = b.bodyCellContext, d = b.containerElContext;
        a -= this.measureLabelErrorHeight(b);
        c.setHeight(a);
        d.setHeight(a)
    }
});
Ext.define("Ext.form.FieldContainer", {
    extend            : "Ext.container.Container",
    mixins            : {
        labelable    : "Ext.form.Labelable",
        fieldAncestor: "Ext.form.FieldAncestor"
    },
    requires          : "Ext.layout.component.field.FieldContainer",
    alias             : "widget.fieldcontainer",
    componentLayout   : "fieldcontainer",
    componentCls      : Ext.baseCSSPrefix + "form-fieldcontainer",
    customOverflowEl  : "containerEl",
    childEls          : ["containerEl"],
    combineLabels     : false,
    labelConnector    : ", ",
    combineErrors     : false,
    maskOnDisable     : false,
    invalidCls        : "",
    fieldSubTpl       : '<div id="{id}-containerEl" class="{containerElCls}">{%this.renderContainer(out,values)%}</div>',
    initComponent     : function() {
        var a = this;
        a.initLabelable();
        a.initFieldAncestor();
        a.callParent();
        a.initMonitor()
    },
    getOverflowEl     : function() {
        return this.containerEl
    },
    onAdd             : function(a) {
        var b = this;
        if (Ext.isGecko && b.layout.type === "absolute" && !b.hideLabel && b.labelAlign !== "top") {
            a.x += (b.labelWidth + b.labelPad)
        }
        b.callParent(arguments);
        if (b.combineLabels) {
            a.oldHideLabel = a.hideLabel;
            a.hideLabel    = true
        }
        b.updateLabel()
    },
    onRemove          : function(a, b) {
        var c = this;
        c.callParent(arguments);
        if (!b) {
            if (c.combineLabels) {
                a.hideLabel = a.oldHideLabel
            }
            c.updateLabel()
        }
    },
    initRenderTpl     : function() {
        var a = this;
        if (!a.hasOwnProperty("renderTpl")) {
            a.renderTpl = a.getTpl("labelableRenderTpl")
        }
        return a.callParent()
    },
    initRenderData    : function() {
        var a            = this, b = a.callParent();
        b.containerElCls = a.containerElCls;
        return Ext.applyIf(b, a.getLabelableRenderData())
    },
    getFieldLabel     : function() {
        var a = this.fieldLabel || "";
        if (!a && this.combineLabels) {
            a = Ext.Array.map(this.query("[isFieldLabelable]"), function(b) {
                return b.getFieldLabel()
            }).join(this.labelConnector)
        }
        return a
    },
    getSubTplData     : function() {
        var a = this.initRenderData();
        Ext.apply(a, this.subTplData);
        return a
    },
    getSubTplMarkup   : function() {
        var c = this, a = c.getTpl("fieldSubTpl"), b;
        if (!a.renderContent) {
            c.setupRenderTpl(a)
        }
        b = a.apply(c.getSubTplData());
        return b
    },
    updateLabel       : function() {
        var b = this, a = b.labelEl;
        if (a) {
            b.setFieldLabel(b.getFieldLabel())
        }
    },
    onFieldErrorChange: function(e, b) {
        if (this.combineErrors) {
            var d = this, f = d.getActiveError(), c = Ext.Array.filter(d.query("[isFormField]"), function(g) {
                return g.hasActiveError()
            }), a = d.getCombinedErrors(c);
            if (a) {
                d.setActiveErrors(a)
            } else {
                d.unsetActiveError()
            }
            if (f !== d.getActiveError()) {
                d.doComponentLayout()
            }
        }
    },
    getCombinedErrors : function(e) {
        var k = [], c, l = e.length, i, d, j, b, g, h;
        for (c = 0; c < l; c++) {
            i = e[c];
            d = i.getActiveErrors();
            b = d.length;
            for (j = 0; j < b; j++) {
                g = d[j];
                h = i.getFieldLabel();
                k.push((h ? h + ": " : "") + g)
            }
        }
        return k
    },
    getTargetEl       : function() {
        return this.containerEl
    },
    applyTargetCls    : function(b) {
        var a               = this.containerElCls;
        this.containerElCls = a ? a + " " + b : b
    }
});
Ext.define("Ext.layout.component.field.Trigger", {
    alias                : "layout.triggerfield",
    extend               : "Ext.layout.component.field.Field",
    type                 : "triggerfield",
    borderWidths         : {},
    beginLayout          : function(d) {
        var c         = this, a = c.owner, b;
        d.triggerWrap = d.getEl("triggerWrap");
        c.callParent(arguments);
        b = a.getTriggerStateFlags();
        if (b != a.lastTriggerStateFlags) {
            a.lastTriggerStateFlags = b;
            c.updateEditState()
        }
    },
    beginLayoutCycle     : function(a) {
        this.callParent(arguments);
        if (a.widthModel.shrinkWrap && !this.owner.inputWidth) {
            a.inputContext.el.setStyle("width", "")
        }
    },
    beginLayoutFixed     : function(f, c, g) {
        var d = this, a = f.target, e = d.ieInputWidthAdjustment || 0, h = "100%", b = a.triggerWrap;
        d.callParent(arguments);
        a.inputCell.setStyle("width", "100%");
        if (e) {
            d.adjustIEInputPadding(f);
            if (g === "px") {
                if (a.inputWidth) {
                    h = a.inputWidth - d.getExtraWidth(f)
                } else {
                    h = c - e - d.getExtraWidth(f)
                }
                h += "px"
            }
        }
        a.inputEl.setStyle("width", h);
        h = a.inputWidth;
        if (h) {
            b.setStyle("width", h + (e) + "px")
        } else {
            b.setStyle("width", c + g)
        }
        b.setStyle("table-layout", "fixed")
    },
    adjustIEInputPadding : function(a) {
        this.owner.inputCell.setStyle("padding-right", this.ieInputWidthAdjustment + "px")
    },
    getExtraWidth        : function(d) {
        var b = this, a = b.owner, e = b.borderWidths, c = a.ui + a.triggerEl.getCount();
        if (!(c in e)) {
            e[c] = d.triggerWrap.getBorderInfo().width
        }
        return e[c] + a.getTriggerWidth()
    },
    beginLayoutShrinkWrap: function(c) {
        var a = c.target, e = "", d = a.inputWidth, b = a.triggerWrap;
        this.callParent(arguments);
        if (d) {
            b.setStyle("width", d + "px");
            d = (d - this.getExtraWidth(c)) + "px";
            a.inputEl.setStyle("width", d);
            a.inputCell.setStyle("width", d)
        } else {
            a.inputCell.setStyle("width", e);
            a.inputEl.setStyle("width", e);
            b.setStyle("width", e);
            b.setStyle("table-layout", "auto")
        }
    },
    getTextWidth         : function() {
        var b = this, a = b.owner, d = a.inputEl, c;
        c     = (d.dom.value || (a.hasFocus ? "" : a.emptyText) || "") + a.growAppend;
        return d.getTextWidth(c)
    },
    publishOwnerWidth    : function(c, b) {
        var a = this.owner;
        this.callParent(arguments);
        if (!a.grow && !a.inputWidth) {
            b -= this.getExtraWidth(c);
            if (a.labelAlign != "top") {
                b -= a.getLabelWidth()
            }
            c.inputContext.setWidth(b)
        }
    },
    publishInnerHeight   : function(b, a) {
        b.inputContext.setHeight(a - this.measureLabelErrorHeight(b))
    },
    measureContentWidth  : function(g) {
        var f = this, b = f.owner, e = f.callParent(arguments), h = g.inputContext, d, a, c;
        if (b.grow && !g.state.growHandled) {
            d = f.getTextWidth() + g.inputContext.getFrameInfo().width;
            a = b.growMax;
            c = Math.min(a, e);
            a = Math.max(b.growMin, a, c);
            d = Ext.Number.constrain(d, b.growMin, a);
            h.setWidth(d);
            g.state.growHandled = true;
            h.domBlock(f, "width");
            e = NaN
        } else {
            if (!b.inputWidth) {
                e -= f.getExtraWidth(g)
            }
        }
        return e
    },
    updateEditState      : function() {
        var c = this, a = c.owner, e = a.inputEl, d = Ext.baseCSSPrefix + "trigger-noedit", b, f;
        if (c.owner.readOnly) {
            e.addCls(d);
            f = true;
            b = false
        } else {
            if (c.owner.editable) {
                e.removeCls(d);
                f = false
            } else {
                e.addCls(d);
                f = true
            }
            b = !c.owner.hideTrigger
        }
        a.triggerCell.setDisplayed(b);
        e.dom.readOnly = f
    }
});
Ext.define("Ext.form.field.Trigger", {
    extend                : "Ext.form.field.Text",
    alias                 : ["widget.triggerfield", "widget.trigger"],
    requires              : ["Ext.dom.Helper", "Ext.util.ClickRepeater", "Ext.layout.component.field.Trigger"],
    alternateClassName    : ["Ext.form.TriggerField", "Ext.form.TwinTriggerField", "Ext.form.Trigger"],
    childEls              : [{
        name  : "triggerCell",
        select: "." + Ext.baseCSSPrefix + "trigger-cell"
    }, {
        name  : "triggerEl",
        select: "." + Ext.baseCSSPrefix + "form-trigger"
    }, "triggerWrap", "inputCell"],
    triggerBaseCls        : Ext.baseCSSPrefix + "form-trigger",
    triggerWrapCls        : Ext.baseCSSPrefix + "form-trigger-wrap",
    triggerNoEditCls      : Ext.baseCSSPrefix + "trigger-noedit",
    hideTrigger           : false,
    editable              : true,
    readOnly              : false,
    repeatTriggerClick    : false,
    autoSize              : Ext.emptyFn,
    monitorTab            : true,
    mimicing              : false,
    triggerIndexRe        : /trigger-index-(\d+)/,
    extraTriggerCls       : "",
    componentLayout       : "triggerfield",
    initComponent         : function() {
        this.wrapFocusCls = this.triggerWrapCls + "-focus";
        this.callParent(arguments)
    },
    getSubTplMarkup       : function(b) {
        var c = this, a = b.childElCls, d = c.callParent(arguments);
        return '<table id="' + c.id + '-triggerWrap" class="' + Ext.baseCSSPrefix + "form-trigger-wrap" + a + '" cellpadding="0" cellspacing="0"><tbody><tr><td id="' + c.id + '-inputCell" class="' + Ext.baseCSSPrefix + "form-trigger-input-cell" + a + '">' + d + "</td>" + c.getTriggerMarkup() + "</tr></tbody></table>"
    },
    getSubTplData         : function() {
        var b = this, c = b.callParent(), d = b.readOnly === true, a = b.editable !== false;
        return Ext.apply(c, {
            editableCls: (d || !a) ? " " + b.triggerNoEditCls : "",
            readOnly   : !a || d
        })
    },
    getLabelableRenderData: function() {
        var b = this, c = b.triggerWrapCls, a = b.callParent(arguments);
        return Ext.applyIf(a, {
            triggerWrapCls: c,
            triggerMarkup : b.getTriggerMarkup()
        })
    },
    getTriggerMarkup      : function() {
        var e = this, c = 0, h = (e.readOnly || e.hideTrigger), a, f = e.triggerBaseCls, g = [], d = Ext.dom.Element.unselectableCls, b = "width:" + e.triggerWidth + "px;" + (h ? "display:none;" : ""), j = e.extraTriggerCls + " " + Ext.baseCSSPrefix + "trigger-cell " + d;
        if (!e.trigger1Cls) {
            e.trigger1Cls = e.triggerCls
        }
        for (c = 0; (a = e["trigger" + (c + 1) + "Cls"]) || c < 1; c++) {
            g.push({
                tag   : "td",
                valign: "top",
                cls   : j,
                style : b,
                cn    : {
                    cls : [Ext.baseCSSPrefix + "trigger-index-" + c, f, a].join(" "),
                    role: "button"
                }
            })
        }
        g[0].cn.cls += " " + f + "-first";
        return Ext.DomHelper.markup(g)
    },
    disableCheck          : function() {
        return !this.disabled
    },
    beforeRender          : function() {
        var a = this, b = a.triggerBaseCls, c;
        if (!a.triggerWidth) {
            c                                             = Ext.getBody().createChild({
                style: "position: absolute;",
                cls  : Ext.baseCSSPrefix + "form-trigger"
            });
            Ext.form.field.Trigger.prototype.triggerWidth = c.getWidth();
            c.remove()
        }
        a.callParent();
        if (b != Ext.baseCSSPrefix + "form-trigger") {
            a.addChildEls({
                name  : "triggerEl",
                select: "." + b
            })
        }
        a.lastTriggerStateFlags = a.getTriggerStateFlags()
    },
    onRender              : function() {
        var a = this;
        a.callParent(arguments);
        a.doc = Ext.getDoc();
        a.initTrigger()
    },
    getTriggerWidth       : function() {
        var b = this, a = 0;
        if (b.triggerWrap && !b.hideTrigger && !b.readOnly) {
            a = b.triggerEl.getCount() * b.triggerWidth
        }
        return a
    },
    setHideTrigger        : function(a) {
        if (a != this.hideTrigger) {
            this.hideTrigger = a;
            this.updateLayout()
        }
    },
    setEditable           : function(a) {
        if (a != this.editable) {
            this.editable = a;
            this.updateLayout()
        }
    },
    setReadOnly           : function(c) {
        var b = this, a = b.readOnly;
        b.callParent(arguments);
        if (c != a) {
            b.updateLayout()
        }
    },
    initTrigger           : function() {
        var g = this, h = g.triggerWrap, j = g.triggerEl, a = g.disableCheck, d, c, b, f, i;
        if (g.repeatTriggerClick) {
            g.triggerRepeater = new Ext.util.ClickRepeater(h, {
                preventDefault: true,
                handler       : g.onTriggerWrapClick,
                listeners     : {
                    mouseup: g.onTriggerWrapMouseup,
                    scope  : g
                },
                scope         : g
            })
        } else {
            g.mon(h, {
                click  : g.onTriggerWrapClick,
                mouseup: g.onTriggerWrapMouseup,
                scope  : g
            })
        }
        j.setVisibilityMode(Ext.Element.DISPLAY);
        j.addClsOnOver(g.triggerBaseCls + "-over", a, g);
        d = j.elements;
        c = d.length;
        for (f = 0; f < c; f++) {
            b = d[f];
            i = f + 1;
            b.addClsOnOver(g["trigger" + (i) + "Cls"] + "-over", a, g);
            b.addClsOnClick(g["trigger" + (i) + "Cls"] + "-click", a, g)
        }
        j.addClsOnClick(g.triggerBaseCls + "-click", a, g)
    },
    onDestroy             : function() {
        var a = this;
        Ext.destroyMembers(a, "triggerRepeater", "triggerWrap", "triggerEl");
        delete a.doc;
        a.callParent()
    },
    onFocus               : function() {
        var a = this;
        a.callParent(arguments);
        if (!a.mimicing) {
            a.bodyEl.addCls(a.wrapFocusCls);
            a.mimicing = true;
            a.mon(a.doc, "mousedown", a.mimicBlur, a, {delay: 10});
            if (a.monitorTab) {
                a.on("specialkey", a.checkTab, a)
            }
        }
    },
    checkTab              : function(a, b) {
        if (!this.ignoreMonitorTab && b.getKey() == b.TAB) {
            this.triggerBlur()
        }
    },
    getTriggerStateFlags  : function() {
        var a = this, b = 0;
        if (a.readOnly) {
            b += 1
        }
        if (a.editable) {
            b += 2
        }
        if (a.hideTrigger) {
            b += 4
        }
        return b
    },
    onBlur                : Ext.emptyFn,
    mimicBlur             : function(a) {
        if (!this.isDestroyed && !this.bodyEl.contains(a.target) && this.validateBlur(a)) {
            this.triggerBlur(a)
        }
    },
    triggerBlur           : function(b) {
        var a      = this;
        a.mimicing = false;
        a.mun(a.doc, "mousedown", a.mimicBlur, a);
        if (a.monitorTab && a.inputEl) {
            a.un("specialkey", a.checkTab, a)
        }
        Ext.form.field.Trigger.superclass.onBlur.call(a, b);
        if (a.bodyEl) {
            a.bodyEl.removeCls(a.wrapFocusCls)
        }
    },
    validateBlur          : function(a) {
        return true
    },
    onTriggerWrapClick    : function() {
        var d = this, e, b, a, c;
        c     = arguments[d.triggerRepeater ? 1 : 0];
        if (c && !d.readOnly && !d.disabled) {
            e = c.getTarget("." + d.triggerBaseCls, null);
            b = e && e.className.match(d.triggerIndexRe);
            if (b) {
                a = d["onTrigger" + (parseInt(b[1], 10) + 1) + "Click"] || d.onTriggerClick;
                if (a) {
                    a.call(d, c)
                }
            }
        }
    },
    onTriggerWrapMouseup  : Ext.emptyFn,
    onTriggerClick        : Ext.emptyFn
});
Ext.define("Ext.form.field.Picker", {
    extend                     : "Ext.form.field.Trigger",
    alias                      : "widget.pickerfield",
    alternateClassName         : "Ext.form.Picker",
    requires                   : ["Ext.util.KeyNav"],
    matchFieldWidth            : true,
    pickerAlign                : "tl-bl?",
    openCls                    : Ext.baseCSSPrefix + "pickerfield-open",
    editable                   : true,
    initComponent              : function() {
        this.callParent();
        this.addEvents("expand", "collapse", "select")
    },
    initEvents                 : function() {
        var a = this;
        a.callParent();
        a.keyNav = new Ext.util.KeyNav(a.inputEl, {
            down        : a.onDownArrow,
            esc         : {
                handler           : a.onEsc,
                scope             : a,
                defaultEventAction: false
            },
            scope       : a,
            forceKeyDown: true
        });
        if (!a.editable) {
            a.mon(a.inputEl, "click", a.onTriggerClick, a)
        }
        if (Ext.isGecko) {
            a.inputEl.dom.setAttribute("autocomplete", "off")
        }
    },
    onEsc                      : function(a) {
        if (Ext.isIE) {
            a.preventDefault()
        }
        if (this.isExpanded) {
            this.collapse();
            a.stopEvent()
        }
    },
    onDownArrow                : function(a) {
        if (!this.isExpanded) {
            this.onTriggerClick()
        }
    },
    expand                     : function() {
        var c = this, a, b, d;
        if (c.rendered && !c.isExpanded && !c.isDestroyed) {
            c.expanding = true;
            a           = c.bodyEl;
            b           = c.getPicker();
            d           = c.collapseIf;
            b.show();
            c.isExpanded = true;
            c.alignPicker();
            a.addCls(c.openCls);
            c.mon(Ext.getDoc(), {
                mousewheel: d,
                mousedown : d,
                scope     : c
            });
            Ext.EventManager.onWindowResize(c.alignPicker, c);
            c.fireEvent("expand", c);
            c.onExpand();
            delete c.expanding
        }
    },
    onExpand                   : Ext.emptyFn,
    alignPicker                : function() {
        var b = this, a = b.getPicker();
        if (b.isExpanded) {
            if (b.matchFieldWidth) {
                a.setWidth(b.bodyEl.getWidth())
            }
            if (a.isFloating()) {
                b.doAlign()
            }
        }
    },
    doAlign                    : function() {
        var d = this, c = d.picker, a = "-above", b;
        d.picker.alignTo(d.triggerWrap, d.pickerAlign, d.pickerOffset);
        b = c.el.getY() < d.inputEl.getY();
        d.bodyEl[b ? "addCls" : "removeCls"](d.openCls + a);
        c[b ? "addCls" : "removeCls"](c.baseCls + a)
    },
    collapse                   : function() {
        if (this.isExpanded && !this.isDestroyed) {
            var d = this, c = d.openCls, b = d.picker, e = Ext.getDoc(), f = d.collapseIf, a = "-above";
            b.hide();
            d.isExpanded = false;
            d.bodyEl.removeCls([c, c + a]);
            b.el.removeCls(b.baseCls + a);
            e.un("mousewheel", f, d);
            e.un("mousedown", f, d);
            Ext.EventManager.removeResizeListener(d.alignPicker, d);
            d.fireEvent("collapse", d);
            d.onCollapse()
        }
    },
    onCollapse                 : Ext.emptyFn,
    collapseIf                 : function(b) {
        var a = this;
        if (!a.isDestroyed && !b.within(a.bodyEl, false, true) && !b.within(a.picker.el, false, true) && !a.isEventWithinPickerLoadMask(b)) {
            a.collapse()
        }
    },
    getPicker                  : function() {
        var a = this;
        return a.picker || (a.picker = a.createPicker())
    },
    createPicker               : Ext.emptyFn,
    onTriggerClick             : function() {
        var a = this;
        if (!a.readOnly && !a.disabled) {
            if (a.isExpanded) {
                a.collapse()
            } else {
                a.expand()
            }
            a.inputEl.focus()
        }
    },
    triggerBlur                : function() {
        var a = this.picker;
        this.callParent(arguments);
        if (a && a.isVisible()) {
            a.hide()
        }
    },
    mimicBlur                  : function(c) {
        var b = this, a = b.picker;
        if (!a || !c.within(a.el, false, true) && !b.isEventWithinPickerLoadMask(c)) {
            b.callParent(arguments)
        }
    },
    onDestroy                  : function() {
        var b = this, a = b.picker;
        Ext.EventManager.removeResizeListener(b.alignPicker, b);
        Ext.destroy(b.keyNav);
        if (a) {
            delete a.pickerField;
            a.destroy()
        }
        b.callParent()
    },
    isEventWithinPickerLoadMask: function(b) {
        var a = this.picker.loadMask;
        return a ? b.within(a.maskEl, false, true) || b.within(a.el, false, true) : false
    }
});
Ext.define("Ext.selection.Model", {
    extend                  : "Ext.util.Observable",
    alternateClassName      : "Ext.AbstractSelectionModel",
    requires                : ["Ext.data.StoreManager"],
    mixins                  : {bindable: "Ext.util.Bindable"},
    allowDeselect           : undefined,
    toggleOnClick           : true,
    selected                : null,
    pruneRemoved            : true,
    suspendChange           : 0,
    constructor             : function(a) {
        var b = this;
        a     = a || {};
        Ext.apply(b, a);
        b.addEvents("selectionchange", "focuschange");
        b.modes = {
            SINGLE: true,
            SIMPLE: true,
            MULTI : true
        };
        b.setSelectionMode(a.mode || b.mode);
        b.selected = new Ext.util.MixedCollection(null, b.getSelectionId);
        b.callParent(arguments)
    },
    bindStore               : function(a, b) {
        var c = this;
        c.mixins.bindable.bindStore.apply(c, arguments);
        if (c.store && !b) {
            c.refresh()
        }
    },
    getStoreListeners       : function() {
        var a = this;
        return {
            add       : a.onStoreAdd,
            clear     : a.onStoreClear,
            bulkremove: a.onStoreRemove,
            update    : a.onStoreUpdate,
            load      : a.onStoreLoad,
            idchanged : a.onModelIdChanged,
            refresh   : a.onStoreRefresh
        }
    },
    suspendChanges          : function() {
        ++this.suspendChange
    },
    resumeChanges           : function() {
        if (this.suspendChange) {
            --this.suspendChange
        }
    },
    selectAll               : function(b) {
        var e = this, d = e.store.getRange(), c = 0, a = d.length, f = e.getSelection().length;
        e.suspendChanges();
        for (; c < a; c++) {
            e.doSelect(d[c], true, b)
        }
        e.resumeChanges();
        if (!b) {
            e.maybeFireSelectionChange(e.getSelection().length !== f)
        }
    },
    deselectAll             : function(j) {
        var f = this, b = f.getSelection(), g = {}, h = f.store, a = b.length, e, c, d;
        for (e = 0, c = b.length; e < c; e++) {
            d               = b[e];
            g[d.internalId] = h.indexOf(d)
        }
        b = Ext.Array.sort(b, function(l, i) {
            var m = g[l.internalId], k = g[i.internalId];
            return m < k ? -1 : 1
        });
        f.suspendChanges();
        f.doDeselect(b, j);
        f.resumeChanges();
        if (!j) {
            f.maybeFireSelectionChange(f.getSelection().length !== a)
        }
    },
    selectWithEvent         : function(j, l) {
        var m = this, d = m.isSelected(j), f = l.shiftKey, a = l.ctrlKey, c = m.selectionStart, g = m.getSelection(), k = g.length, n = m.allowDeselect, b, h, o;
        switch (m.selectionMode) {
            case"MULTI":
                if (f && c) {
                    m.selectRange(c, j, a)
                } else {
                    if (a && d) {
                        m.doDeselect(j, false)
                    } else {
                        if (a) {
                            m.doSelect(j, true, false)
                        } else {
                            if (d && !f && !a && k > 1) {
                                b = [];
                                for (h = 0; h < k; ++h) {
                                    o = g[h];
                                    if (o !== j) {
                                        b.push(o)
                                    }
                                }
                                m.doDeselect(b)
                            } else {
                                if (!d) {
                                    m.doSelect(j, false)
                                }
                            }
                        }
                    }
                }
                break;
            case"SIMPLE":
                if (d) {
                    m.doDeselect(j)
                } else {
                    m.doSelect(j, true)
                }
                break;
            case"SINGLE":
                if (n && !a) {
                    n = m.toggleOnClick
                }
                if (n && d) {
                    m.doDeselect(j)
                } else {
                    m.doSelect(j, false)
                }
                break
        }
        if (!f) {
            if (m.isSelected(j)) {
                m.selectionStart = j
            } else {
                m.selectionStart = null
            }
        }
    },
    afterKeyNavigate        : function(f, d) {
        var g = this, c, a, b = g.isSelected(d), i = (g.selectionStart && g.isSelected(g.lastFocused)) ? g.selectionStart : (g.selectionStart = g.lastFocused), j = f.getCharCode(), k = j === f.SPACE, h = j === f.UP || j === f.PAGE_UP ? "up" : (j === f.DOWN || j === f.DOWN ? "down" : null);
        switch (g.selectionMode) {
            case"MULTI":
                if (k) {
                    if (f.shiftKey) {
                        g.selectRange(i, d, f.ctrlKey)
                    } else {
                        if (b) {
                            g.doDeselect(d, f.ctrlKey);
                            g.setLastFocused(null);
                            g.setLastFocused(d)
                        } else {
                            g.doSelect(d, f.ctrlKey)
                        }
                    }
                } else {
                    if (f.shiftKey && i) {
                        a = g.store.indexOf(i);
                        c = g.store.indexOf(d);
                        if (h === "up" && a <= c) {
                            g.deselectRange(g.lastFocused, c + 1)
                        } else {
                            if (h === "down" && a >= c) {
                                g.deselectRange(g.lastFocused, c - 1)
                            } else {
                                if (i !== d) {
                                    g.selectRange(i, d, f.ctrlKey)
                                }
                            }
                        }
                        g.lastSelected = d;
                        g.setLastFocused(d)
                    } else {
                        if (f.ctrlKey && b) {
                            g.setLastFocused(d)
                        } else {
                            if (f.ctrlKey) {
                                g.setLastFocused(d)
                            } else {
                                g.doSelect(d, false)
                            }
                        }
                    }
                }
                break;
            case"SIMPLE":
                if (b) {
                    g.doDeselect(d)
                } else {
                    g.doSelect(d, true)
                }
                break;
            case"SINGLE":
                if (k) {
                    if (b) {
                        g.doDeselect(d);
                        g.setLastFocused(d)
                    } else {
                        g.doSelect(d)
                    }
                } else {
                    if (f.ctrlKey) {
                        g.setLastFocused(d)
                    } else {
                        if (g.allowDeselect && b) {
                            g.doDeselect(d)
                        } else {
                            g.doSelect(d, false)
                        }
                    }
                }
                break
        }
        if (!f.shiftKey) {
            if (g.isSelected(d)) {
                g.selectionStart = d
            }
        }
    },
    selectRange             : function(l, d, m) {
        var h = this, k = h.store, c = h.selected.items, n, f, g, e, a, j, b;
        if (h.isLocked()) {
            return
        }
        n = h.normalizeRowRange(l, d);
        l = n[0];
        d = n[1];
        e = [];
        for (f = l; f <= d; f++) {
            if (!h.isSelected(k.getAt(f))) {
                e.push(k.getAt(f))
            }
        }
        if (!m) {
            a = [];
            h.suspendChanges();
            for (f = 0, g = c.length; f < g; ++f) {
                b = c[f];
                j = k.indexOf(b);
                if (j < l || j > d) {
                    a.push(b)
                }
            }
            for (f = 0, g = a.length; f < g; ++f) {
                h.doDeselect(a[f])
            }
            h.resumeChanges()
        }
        h.doMultiSelect(e, true)
    },
    deselectRange           : function(e, d) {
        var h = this, c = h.store, a, g, f, b;
        if (h.isLocked()) {
            return
        }
        a = h.normalizeRowRange(e, d);
        e = a[0];
        d = a[1];
        f = [];
        for (g = e; g <= d; g++) {
            b = c.getAt(g);
            if (h.isSelected(b)) {
                f.push(b)
            }
        }
        h.doDeselect(f)
    },
    normalizeRowRange       : function(c, b) {
        var a = this.store, d;
        if (!Ext.isNumber(c)) {
            c = a.indexOf(c)
        }
        c = Math.max(0, c);
        if (!Ext.isNumber(b)) {
            b = a.indexOf(b)
        }
        b = Math.min(b, a.getCount() - 1);
        if (c > b) {
            d = b;
            b = c;
            c = d
        }
        return [c, b]
    },
    onModelIdChanged        : function(a, d, e, c, b) {
        this.selected.updateKey(b, c)
    },
    select                  : function(b, c, a) {
        if (Ext.isDefined(b)) {
            this.doSelect(b, c, a)
        }
    },
    deselect                : function(b, a) {
        this.doDeselect(b, a)
    },
    doSelect                : function(c, e, b) {
        var d = this, a;
        if (d.locked || !d.store) {
            return
        }
        if (typeof c === "number") {
            a = d.store.getAt(c);
            if (!a) {
                return
            }
            c = [a]
        }
        if (d.selectionMode == "SINGLE" && c) {
            a = c.length ? c[0] : c;
            d.doSingleSelect(a, b)
        } else {
            d.doMultiSelect(c, e, b)
        }
    },
    doMultiSelect           : function(a, k, j) {
        var g = this, b = g.selected, h = false, l, d, f, e, c;
        if (g.locked) {
            return
        }
        a = !Ext.isArray(a) ? [a] : a;
        f = a.length;
        if (!k && b.getCount() > 0) {
            l = g.deselectDuringSelect(a, b.getRange(), j);
            if (l[0]) {
                g.maybeFireSelectionChange(l[1] > 0 && !j);
                return
            }
        }
        c = function() {
            b.add(e);
            h = true
        };
        for (d = 0; d < f; d++) {
            e = a[d];
            if (g.isSelected(e)) {
                continue
            }
            g.lastSelected = e;
            g.onSelectChange(e, true, j, c)
        }
        if (!g.preventFocus) {
            g.setLastFocused(e, j)
        }
        g.maybeFireSelectionChange(h && !j)
    },
    deselectDuringSelect    : function(d, a, h) {
        var g = this, f = a.length, c = 0, e = false, j, b;
        g.suspendChanges();
        for (b = 0; b < f; ++b) {
            j = a[b];
            if (!Ext.Array.contains(d, j)) {
                if (g.doDeselect(j, h)) {
                    ++c
                } else {
                    e = true
                }
            }
        }
        g.resumeChanges();
        return [e, c]
    },
    doDeselect              : function(a, j) {
        var h = this, b = h.selected, d = 0, g, e, k = 0, f = 0, c;
        if (h.locked || !h.store) {
            return false
        }
        if (typeof a === "number") {
            e = h.store.getAt(a);
            if (!e) {
                return false
            }
            a = [e]
        } else {
            if (!Ext.isArray(a)) {
                a = [a]
            }
        }
        c = function() {
            ++f;
            b.remove(e)
        };
        g = a.length;
        h.suspendChanges();
        for (; d < g; d++) {
            e = a[d];
            if (h.isSelected(e)) {
                if (h.lastSelected === e) {
                    h.lastSelected = b.last();
                    if (h.lastFocused === e) {
                        h.setLastFocused(null)
                    }
                }
                ++k;
                h.onSelectChange(e, false, j, c)
            }
        }
        h.resumeChanges();
        h.maybeFireSelectionChange(f > 0 && !j);
        return f === k
    },
    doSingleSelect          : function(a, b) {
        var d = this, f = false, c = d.selected, e;
        if (d.locked) {
            return
        }
        if (d.isSelected(a)) {
            return
        }
        if (c.getCount()) {
            d.suspendChanges();
            if (!d.doDeselect(d.lastSelected, b)) {
                d.resumeChanges();
                return
            }
            d.resumeChanges()
        }
        e = function() {
            c.add(a);
            d.lastSelected = a;
            f              = true
        };
        d.onSelectChange(a, true, b, e);
        if (f) {
            if (!b && !d.preventFocus) {
                d.setLastFocused(a)
            }
            d.maybeFireSelectionChange(!b)
        }
    },
    setLastFocused          : function(c, b) {
        var d = this, a = d.lastFocused;
        if (c !== a) {
            d.lastFocused = c;
            d.onLastFocusChanged(a, c, b)
        }
    },
    isFocused               : function(a) {
        return a === this.getLastFocused()
    },
    maybeFireSelectionChange: function(a) {
        var b = this;
        if (a && !b.suspendChange) {
            b.fireEvent("selectionchange", b, b.getSelection())
        }
    },
    getLastSelected         : function() {
        return this.lastSelected
    },
    getLastFocused          : function() {
        return this.lastFocused
    },
    getSelection            : function() {
        return this.selected.getRange()
    },
    getSelectionMode        : function() {
        return this.selectionMode
    },
    setSelectionMode        : function(a) {
        a                  = a ? a.toUpperCase() : "SINGLE";
        this.selectionMode = this.modes[a] ? a : "SINGLE"
    },
    isLocked                : function() {
        return this.locked
    },
    setLocked               : function(a) {
        this.locked = !!a
    },
    isRangeSelected         : function(d, c) {
        var f = this, b = f.store, e, a;
        a     = f.normalizeRowRange(d, c);
        d     = a[0];
        c     = a[1];
        for (e = d; e <= c; e++) {
            if (!f.isSelected(b.getAt(e))) {
                return false
            }
        }
        return true
    },
    isSelected              : function(a) {
        a = Ext.isNumber(a) ? this.store.getAt(a) : a;
        return this.selected.contains(a)
    },
    hasSelection            : function() {
        return this.selected.getCount() > 0
    },
    getSelectionId          : function(a) {
        return a.internalId
    },
    pruneIf                 : function() {
        var f = this, d = f.selected, c = [], a = d.length, b, e;
        if (f.pruneRemoved) {
            for (b = 0; b < a; b++) {
                e = d.getAt(b);
                if (!this.storeHasSelected(e)) {
                    c.push(e)
                }
            }
            if (c.length) {
                for (b = 0, a = c.length; b < a; b++) {
                    d.remove(c[b])
                }
                f.maybeFireSelectionChange(true)
            }
        }
    },
    storeHasSelected        : function(b) {
        var d = this.store, c, a, f, e;
        if (b.hasId() && d.getById(b)) {
            return true
        } else {
            c = d.data.items;
            a = c.length;
            f = b.internalId;
            for (e = 0; e < a; ++e) {
                if (f === c[e].internalId) {
                    return true
                }
            }
        }
        return false
    },
    refresh                 : function() {
        var g = this, k = g.store, a, d = [], f = [], c = g.getSelection(), e = c.length, j, h, b = 0, l = g.getLastFocused();
        if (!k) {
            return
        }
        for (; b < e; b++) {
            j = c[b];
            if (k.indexOf(j) !== -1) {
                d.push(j)
            } else {
                if (!g.pruneRemoved) {
                    a = k.getById(j.getId());
                    if (a) {
                        d.push(a)
                    } else {
                        f.push(j)
                    }
                }
            }
            if (g.mode === "SINGLE" && f.length) {
                break
            }
        }
        if (g.selected.getCount() != (d.length + f.length)) {
            h = true
        }
        g.clearSelections();
        if (k.indexOf(l) !== -1) {
            g.setLastFocused(l, true)
        }
        if (d.length) {
            g.doSelect(d, false, true)
        }
        if (f.length) {
            g.selected.addAll(f);
            if (!g.lastSelected) {
                g.lastSelected = f[f.length - 1]
            }
        }
        g.maybeFireSelectionChange(h)
    },
    clearSelections         : function() {
        this.selected.clear();
        this.lastSelected = null;
        this.setLastFocused(null)
    },
    onStoreAdd              : Ext.emptyFn,
    onStoreClear            : function() {
        if (this.selected.getCount() > 0) {
            this.clearSelections();
            this.maybeFireSelectionChange(true)
        }
    },
    onStoreRemove           : function(c, b, d, a) {
        var e = this;
        if (e.selectionStart && Ext.Array.contains(b, e.selectionStart)) {
            e.selectionStart = null
        }
        if (a || e.locked || !e.pruneRemoved) {
            return
        }
        e.deselectDeletedRecords(b)
    },
    deselectDeletedRecords  : function(b) {
        var f = this, d = f.selected, c, e = b.length, g = 0, a;
        for (c = 0; c < e; c++) {
            a = b[c];
            if (d.remove(a)) {
                if (f.lastSelected == a) {
                    f.lastSelected = null
                }
                if (f.getLastFocused() == a) {
                    f.setLastFocused(null)
                }
                ++g
            }
        }
        if (g) {
            f.maybeFireSelectionChange(true)
        }
    },
    getCount                : function() {
        return this.selected.getCount()
    },
    onUpdate                : Ext.emptyFn,
    destroy                 : function() {
        this.clearListeners()
    },
    onStoreUpdate           : Ext.emptyFn,
    onStoreRefresh          : Ext.emptyFn,
    onStoreLoad             : Ext.emptyFn,
    onSelectChange          : function(a, d, c, f) {
        var e = this, b = d ? "select" : "deselect";
        if ((c || e.fireEvent("before" + b, e, a)) !== false && f() !== false) {
            if (!c) {
                e.fireEvent(b, e, a)
            }
        }
    },
    onLastFocusChanged      : function(b, a) {
        this.fireEvent("focuschange", this, b, a)
    },
    onEditorKey             : Ext.emptyFn,
    beforeViewRender        : function(a) {
        this.views = this.views || [];
        this.views.push(a);
        this.bindStore(a.getStore(), true)
    },
    bindComponent           : Ext.emptyFn
});
Ext.define("Ext.selection.DataViewModel", {
    extend                  : "Ext.selection.Model",
    requires                : ["Ext.util.KeyNav"],
    deselectOnContainerClick: true,
    enableKeyNav            : true,
    constructor             : function(a) {
        this.addEvents("beforedeselect", "beforeselect", "deselect", "select");
        this.callParent(arguments)
    },
    bindComponent           : function(a) {
        var b  = this, c = {
            refresh: b.refresh,
            scope  : b
        };
        b.view = a;
        b.bindStore(a.getStore());
        c[a.triggerEvent]   = b.onItemClick;
        c[a.triggerCtEvent] = b.onContainerClick;
        a.on(c);
        if (b.enableKeyNav) {
            b.initKeyNav(a)
        }
    },
    onUpdate                : function(b) {
        var a = this.view;
        if (a && this.isSelected(b)) {
            a.onItemSelect(b)
        }
    },
    onItemClick             : function(b, a, d, c, f) {
        this.selectWithEvent(a, f)
    },
    onContainerClick        : function() {
        if (this.deselectOnContainerClick) {
            this.deselectAll()
        }
    },
    initKeyNav              : function(a) {
        var b = this;
        if (!a.rendered) {
            a.on({
                render: Ext.Function.bind(b.initKeyNav, b, [a]),
                single: true
            });
            return
        }
        a.el.set({tabIndex: -1});
        b.keyNav = new Ext.util.KeyNav({
            target           : a.el,
            ignoreInputFields: true,
            down             : Ext.pass(b.onNavKey, [1], b),
            right            : Ext.pass(b.onNavKey, [1], b),
            left             : Ext.pass(b.onNavKey, [-1], b),
            up               : Ext.pass(b.onNavKey, [-1], b),
            scope            : b
        })
    },
    onNavKey                : function(f) {
        f     = f || 1;
        var e = this, b = e.view, d = e.getSelection()[0], c = e.view.store.getCount(), a;
        if (d) {
            a = b.indexOf(b.getNode(d)) + f
        } else {
            a = 0
        }
        if (a < 0) {
            a = c - 1
        } else {
            if (a >= c) {
                a = 0
            }
        }
        e.select(a)
    },
    onSelectChange          : function(b, e, d, g) {
        var f = this, a = f.view, c = e ? "select" : "deselect";
        if ((d || f.fireEvent("before" + c, f, b)) !== false && g() !== false) {
            if (a) {
                if (e) {
                    a.onItemSelect(b)
                } else {
                    a.onItemDeselect(b)
                }
            }
            if (!d) {
                f.fireEvent(c, f, b)
            }
        }
    },
    onLastFocusChanged      : function(d, b, c) {
        var a = this.view;
        if (a && !c && b) {
            a.focusNode(b);
            this.fireEvent("focuschange", this, d, b)
        }
    },
    destroy                 : function() {
        Ext.destroy(this.keyNav);
        this.callParent()
    }
});
Ext.define("Ext.view.AbstractView", {
    extend                 : "Ext.Component",
    requires               : ["Ext.LoadMask", "Ext.data.StoreManager", "Ext.CompositeElementLite", "Ext.DomQuery", "Ext.selection.DataViewModel"],
    mixins                 : {bindable: "Ext.util.Bindable"},
    inheritableStatics     : {
        getRecord   : function(a) {
            return this.getBoundView(a).getRecord(a)
        },
        getBoundView: function(a) {
            return Ext.getCmp(a.boundView)
        }
    },
    deferInitialRefresh    : true,
    itemCls                : Ext.baseCSSPrefix + "dataview-item",
    loadingText            : "Loading...",
    loadMask               : true,
    loadingUseMsg          : true,
    selectedItemCls        : Ext.baseCSSPrefix + "item-selected",
    emptyText              : "",
    deferEmptyText         : true,
    trackOver              : false,
    blockRefresh           : false,
    preserveScrollOnRefresh: false,
    last                   : false,
    triggerEvent           : "itemclick",
    triggerCtEvent         : "containerclick",
    addCmpEvents           : function() {
    },
    initComponent          : function() {
        var c = this, a = Ext.isDefined, d = c.itemTpl, b = {};
        if (d) {
            if (Ext.isArray(d)) {
                d = d.join("")
            } else {
                if (Ext.isObject(d)) {
                    b = Ext.apply(b, d.initialConfig);
                    d = d.html
                }
            }
            if (!c.itemSelector) {
                c.itemSelector = "." + c.itemCls
            }
            d     = Ext.String.format('<tpl for="."><div class="{0}">{1}</div></tpl>', c.itemCls, d);
            c.tpl = new Ext.XTemplate(d, b)
        }
        c.callParent();
        c.tpl = c.getTpl("tpl");
        if (c.overItemCls) {
            c.trackOver = true
        }
        c.addEvents("beforerefresh", "refresh", "viewready", "itemupdate", "itemadd", "itemremove");
        c.addCmpEvents();
        c.store = Ext.data.StoreManager.lookup(c.store || "ext-empty-store");
        if (!c.dataSource) {
            c.dataSource = c.store
        }
        c.bindStore(c.dataSource, true, "dataSource");
        if (!c.all) {
            c.all = new Ext.CompositeElementLite()
        }
        c.scrollState = {
            top : 0,
            left: 0
        };
        c.on({
            scroll : c.onViewScroll,
            element: "el",
            scope  : c
        })
    },
    onRender               : function() {
        var d = this, b = d.loadMask, c = d.getMaskStore(), a = {
            target: d,
            msg   : d.loadingText,
            msgCls: d.loadingCls,
            useMsg: d.loadingUseMsg,
            store : c
        };
        d.callParent(arguments);
        if (b && !c.proxy.isSynchronous) {
            if (Ext.isObject(b)) {
                a = Ext.apply(a, b)
            }
            d.loadMask = new Ext.LoadMask(a);
            d.loadMask.on({
                scope     : d,
                beforeshow: d.onMaskBeforeShow,
                hide      : d.onMaskHide
            })
        }
    },
    finishRender           : function() {
        var a = this;
        a.callParent(arguments);
        if (!a.up("[collapsed],[hidden]")) {
            a.doFirstRefresh(a.dataSource)
        }
    },
    onBoxReady             : function() {
        var a = this;
        a.callParent(arguments);
        if (!a.firstRefreshDone) {
            a.doFirstRefresh(a.dataSource)
        }
    },
    getMaskStore           : function() {
        return this.store
    },
    onMaskBeforeShow       : function() {
        var b = this, a = b.loadingHeight;
        if (a && a > b.getHeight()) {
            b.hasLoadingHeight = true;
            b.oldMinHeight     = b.minHeight;
            b.minHeight        = a;
            b.updateLayout()
        }
    },
    onMaskHide             : function() {
        var a = this;
        if (!a.destroying && a.hasLoadingHeight) {
            a.minHeight = a.oldMinHeight;
            a.updateLayout();
            delete a.hasLoadingHeight
        }
    },
    beforeRender           : function() {
        this.callParent(arguments);
        this.getSelectionModel().beforeViewRender(this)
    },
    afterRender            : function() {
        this.callParent(arguments);
        this.getSelectionModel().bindComponent(this)
    },
    getSelectionModel      : function() {
        var a = this, b = "SINGLE";
        if (a.simpleSelect) {
            b = "SIMPLE"
        } else {
            if (a.multiSelect) {
                b = "MULTI"
            }
        }
        if (!a.selModel || !a.selModel.events) {
            a.selModel = new Ext.selection.DataViewModel(Ext.apply({
                allowDeselect: a.allowDeselect,
                mode         : b
            }, a.selModel))
        }
        if (!a.selModel.hasRelaySetup) {
            a.relayEvents(a.selModel, ["selectionchange", "beforeselect", "beforedeselect", "select", "deselect", "focuschange"]);
            a.selModel.hasRelaySetup = true
        }
        if (a.disableSelection) {
            a.selModel.locked = true
        }
        return a.selModel
    },
    refresh                : function() {
        var c = this, g, b, e, d, f, a;
        if (!c.rendered || c.isDestroyed) {
            return
        }
        if (!c.hasListeners.beforerefresh || c.fireEvent("beforerefresh", c) !== false) {
            g = c.getTargetEl();
            a = c.getViewRange();
            f = g.dom;
            if (!c.preserveScrollOnRefresh) {
                b               = f.parentNode;
                e               = f.style.display;
                f.style.display = "none";
                d               = f.nextSibling;
                b.removeChild(f)
            }
            if (c.refreshCounter) {
                c.clearViewEl()
            } else {
                c.fixedNodes     = g.dom.childNodes.length;
                c.refreshCounter = 1
            }
            c.tpl.append(g, c.collectData(a, c.all.startIndex));
            if (a.length < 1) {
                if (!this.store.loading && (!c.deferEmptyText || c.hasFirstRefresh)) {
                    Ext.core.DomHelper.insertHtml("beforeEnd", g.dom, c.emptyText)
                }
                c.all.clear()
            } else {
                c.collectNodes(g.dom);
                c.updateIndexes(0)
            }
            if (c.hasFirstRefresh) {
                if (c.refreshSelmodelOnRefresh !== false) {
                    c.selModel.refresh()
                } else {
                    c.selModel.pruneIf()
                }
            }
            c.hasFirstRefresh = true;
            if (!c.preserveScrollOnRefresh) {
                b.insertBefore(f, d);
                f.style.display = e
            }
            this.refreshSize();
            c.fireEvent("refresh", c);
            if (!c.viewReady) {
                c.viewReady = true;
                c.fireEvent("viewready", c)
            }
        }
    },
    collectNodes           : function(a) {
        this.all.fill(Ext.query(this.getItemSelector(), Ext.getDom(a)), this.all.startIndex)
    },
    getViewRange           : function() {
        return this.dataSource.getRange()
    },
    refreshSize            : function() {
        var a = this.getSizeModel();
        if (a.height.shrinkWrap || a.width.shrinkWrap) {
            this.updateLayout()
        }
    },
    clearViewEl            : function() {
        var b = this, a = b.getTargetEl();
        if (b.fixedNodes) {
            while (a.dom.childNodes[b.fixedNodes]) {
                a.dom.removeChild(a.dom.childNodes[b.fixedNodes])
            }
        } else {
            a.update("")
        }
        b.refreshCounter++
    },
    onViewScroll           : Ext.emptyFn,
    onIdChanged            : Ext.emptyFn,
    saveScrollState        : function() {
        if (this.rendered) {
            var b  = this.el.dom, a = this.scrollState;
            a.left = b.scrollLeft;
            a.top  = b.scrollTop
        }
    },
    restoreScrollState     : function() {
        if (this.rendered) {
            var b        = this.el.dom, a = this.scrollState;
            b.scrollLeft = a.left;
            b.scrollTop  = a.top
        }
    },
    prepareData            : function(e, d, c) {
        var b, a, f;
        if (c) {
            b = c.getAssociatedData();
            for (a in b) {
                if (b.hasOwnProperty(a)) {
                    if (!f) {
                        e = Ext.Object.chain(e);
                        f = true
                    }
                    e[a] = b[a]
                }
            }
        }
        return e
    },
    collectData            : function(c, f) {
        var e = [], d = 0, a = c.length, b;
        for (; d < a; d++) {
            b    = c[d];
            e[d] = this.prepareData(b.data, f + d, b)
        }
        return e
    },
    bufferRender           : function(a, b) {
        var c = this, d = c.renderBuffer || (c.renderBuffer = document.createElement("div"));
        c.tpl.overwrite(d, c.collectData(a, b));
        return Ext.DomQuery.select(c.getItemSelector(), d)
    },
    getNodeContainer       : function() {
        return this.getTargetEl()
    },
    onUpdate               : function(e, a) {
        var d = this, b, c;
        if (d.viewReady) {
            b = d.dataSource.indexOf(a);
            if (b > -1) {
                c = d.bufferRender([a], b)[0];
                if (d.getNode(a)) {
                    d.all.replaceElement(b, c, true);
                    d.updateIndexes(b, b);
                    d.selModel.onUpdate(a);
                    if (d.hasListeners.itemupdate) {
                        d.fireEvent("itemupdate", a, b, c)
                    }
                    return c
                }
            }
        }
    },
    onAdd                  : function(c, b, d) {
        var e = this, a;
        if (e.rendered) {
            if (e.all.getCount() === 0) {
                e.refresh();
                a = e.all.slice()
            } else {
                a = e.doAdd(b, d);
                if (e.refreshSelmodelOnRefresh !== false) {
                    e.selModel.refresh()
                }
                e.updateIndexes(d);
                e.refreshSize()
            }
            if (e.hasListeners.itemadd) {
                e.fireEvent("itemadd", b, d, a)
            }
        }
    },
    doAdd                  : function(c, d) {
        var h = this, b = h.bufferRender(c, d, true), f = h.all, g = f.getCount(), e, a;
        if (g === 0) {
            for (e = 0, a = b.length; e < a; e++) {
                this.getNodeContainer().appendChild(b[e])
            }
        } else {
            if (d < g) {
                if (d === 0) {
                    f.item(d).insertSibling(b, "before", true)
                } else {
                    f.item(d - 1).insertSibling(b, "after", true)
                }
            } else {
                f.last().insertSibling(b, "after", true)
            }
        }
        f.insert(d, b);
        return b
    },
    onRemove               : function(h, b, d) {
        var f = this, g = f.hasListeners.itemremove, e, a, c;
        if (f.all.getCount()) {
            if (f.dataSource.getCount() === 0) {
                if (g) {
                    for (e = d.length - 1; e >= 0; --e) {
                        f.fireEvent("itemremove", b[e], d[e])
                    }
                }
                f.refresh()
            } else {
                for (e = d.length - 1; e >= 0; --e) {
                    a = b[e];
                    c = d[e];
                    f.doRemove(a, c);
                    if (g) {
                        f.fireEvent("itemremove", a, c)
                    }
                }
                f.updateIndexes(d[0])
            }
            this.refreshSize()
        }
    },
    doRemove               : function(a, b) {
        this.all.removeElement(b, true)
    },
    refreshNode            : function(a) {
        this.onUpdate(this.dataSource, this.dataSource.getAt(a))
    },
    updateIndexes          : function(e, d) {
        var b = this.all.elements, a = this.getViewRange(), c;
        e     = e || 0;
        d     = d || ((d === 0) ? 0 : (b.length - 1));
        for (c = e; c <= d; c++) {
            b[c].viewIndex    = c;
            b[c].viewRecordId = a[c].internalId;
            if (!b[c].boundView) {
                b[c].boundView = this.id
            }
        }
    },
    getStore               : function() {
        return this.store
    },
    bindStore              : function(a, b, d) {
        var c = this;
        c.mixins.bindable.bindStore.apply(c, arguments);
        if (!b) {
            c.getSelectionModel().bindStore(a)
        }
        if (c.componentLayoutCounter) {
            c.doFirstRefresh(a)
        }
    },
    doFirstRefresh         : function(a) {
        var b              = this;
        b.firstRefreshDone = true;
        if (a && !a.loading) {
            if (b.deferInitialRefresh) {
                b.applyFirstRefresh()
            } else {
                b.refresh()
            }
        }
    },
    applyFirstRefresh      : function() {
        var a = this;
        if (a.isDestroyed) {
            return
        }
        if (a.up("[isCollapsingOrExpanding]")) {
            Ext.Function.defer(a.applyFirstRefresh, 100, a)
        } else {
            Ext.Function.defer(function() {
                if (!a.isDestroyed) {
                    a.refresh()
                }
            }, 1)
        }
    },
    onUnbindStore          : function(a) {
        this.setMaskBind(null)
    },
    onBindStore            : function(a, b, c) {
        this.setMaskBind(a);
        if (!b && c === "store") {
            this.bindStore(a, false, "dataSource")
        }
    },
    setMaskBind            : function(b) {
        var a = this.loadMask;
        if (a && a.bindStore) {
            a.bindStore(b)
        }
    },
    getStoreListeners      : function() {
        var a = this;
        return {
            idchanged : a.onIdChanged,
            refresh   : a.onDataRefresh,
            add       : a.onAdd,
            bulkremove: a.onRemove,
            update    : a.onUpdate,
            clear     : a.refresh
        }
    },
    onDataRefresh          : function() {
        this.refreshView()
    },
    refreshView            : function() {
        var a = this, b = !a.firstRefreshDone && (!a.rendered || a.up("[collapsed],[isCollapsingOrExpanding],[hidden]"));
        if (b) {
            a.deferInitialRefresh = false
        } else {
            if (a.blockRefresh !== true) {
                a.firstRefreshDone = true;
                a.refresh()
            }
        }
    },
    findItemByChild        : function(a) {
        return Ext.fly(a).findParent(this.getItemSelector(), this.getTargetEl())
    },
    findTargetByEvent      : function(a) {
        return a.getTarget(this.getItemSelector(), this.getTargetEl())
    },
    getSelectedNodes       : function() {
        var b = [], a = this.selModel.getSelection(), d = a.length, c = 0;
        for (; c < d; c++) {
            b.push(this.getNode(a[c]))
        }
        return b
    },
    getRecords             : function(c) {
        var b = [], d = 0, a = c.length, e = this.dataSource.data;
        for (; d < a; d++) {
            b[b.length] = e.getByKey(c[d].viewRecordId)
        }
        return b
    },
    getRecord              : function(a) {
        return this.dataSource.data.getByKey(Ext.getDom(a).viewRecordId)
    },
    isSelected             : function(b) {
        var a = this.getRecord(b);
        return this.selModel.isSelected(a)
    },
    select                 : function(b, c, a) {
        this.selModel.select(b, c, a)
    },
    deselect               : function(b, a) {
        this.selModel.deselect(b, a)
    },
    getNode                : function(a) {
        if ((!a && a !== 0) || !this.rendered) {
            return null
        }
        if (Ext.isString(a)) {
            return document.getElementById(a)
        }
        if (Ext.isNumber(a)) {
            return this.all.elements[a]
        }
        if (a.isModel) {
            return this.getNodeByRecord(a)
        }
        return a
    },
    getNodeByRecord        : function(a) {
        var c = this.all.elements, d = c.length, b = 0;
        for (; b < d; b++) {
            if (c[b].viewRecordId === a.internalId) {
                return c[b]
            }
        }
        return null
    },
    getNodes               : function(c, a) {
        var b = this.all;
        if (a === undefined) {
            a = b.getCount()
        } else {
            a++
        }
        return b.slice(c || 0, a)
    },
    indexOf                : function(a) {
        a = this.getNode(a);
        if (!a && a !== 0) {
            return -1
        }
        if (Ext.isNumber(a.viewIndex)) {
            return a.viewIndex
        }
        return this.all.indexOf(a)
    },
    onDestroy              : function() {
        var a = this;
        a.all.clear();
        a.callParent();
        a.bindStore(null);
        a.selModel.destroy()
    },
    onItemSelect           : function(a) {
        var b = this.getNode(a);
        if (b) {
            Ext.fly(b).addCls(this.selectedItemCls)
        }
    },
    onItemDeselect         : function(a) {
        var b = this.getNode(a);
        if (b) {
            Ext.fly(b).removeCls(this.selectedItemCls)
        }
    },
    getItemSelector        : function() {
        return this.itemSelector
    }
}, function() {
    Ext.deprecate("extjs", "4.0", function() {
        Ext.view.AbstractView.override({
            getSelectionCount : function() {
                if (Ext.global.console) {
                    Ext.global.console.warn("DataView: getSelectionCount will be removed, please interact with the Ext.selection.DataViewModel")
                }
                return this.selModel.getSelection().length
            },
            getSelectedRecords: function() {
                if (Ext.global.console) {
                    Ext.global.console.warn("DataView: getSelectedRecords will be removed, please interact with the Ext.selection.DataViewModel")
                }
                return this.selModel.getSelection()
            },
            select            : function(a, b, d) {
                if (Ext.global.console) {
                    Ext.global.console.warn("DataView: select will be removed, please access select through a DataView's SelectionModel, ie: view.getSelectionModel().select()")
                }
                var c = this.getSelectionModel();
                return c.select.apply(c, arguments)
            },
            clearSelections   : function() {
                if (Ext.global.console) {
                    Ext.global.console.warn("DataView: clearSelections will be removed, please access deselectAll through DataView's SelectionModel, ie: view.getSelectionModel().deselectAll()")
                }
                var a = this.getSelectionModel();
                return a.deselectAll()
            }
        })
    })
});
Ext.define("Ext.view.View", {
    extend                      : "Ext.view.AbstractView",
    alternateClassName          : "Ext.DataView",
    alias                       : "widget.dataview",
    deferHighlight              : Ext.isIE7m ? 100 : 0,
    mouseOverOutBuffer          : 20,
    inputTagRe                  : /^textarea$|^input$/i,
    inheritableStatics          : {
        EventMap: {
            mousedown  : "MouseDown",
            mouseup    : "MouseUp",
            click      : "Click",
            dblclick   : "DblClick",
            contextmenu: "ContextMenu",
            mouseover  : "MouseOver",
            mouseout   : "MouseOut",
            mouseenter : "MouseEnter",
            mouseleave : "MouseLeave",
            keydown    : "KeyDown",
            focus      : "Focus"
        }
    },
    initComponent               : function() {
        var a = this;
        a.callParent();
        if (a.mouseOverOutBuffer) {
            a.handleMouseOverOrOut  = Ext.Function.createBuffered(a.handleMouseOverOrOut, a.mouseOverOutBuffer, a);
            a.lastMouseOverOutEvent = new Ext.EventObjectImpl()
        } else {
            if (a.deferHighlight) {
                a.setHighlightedItem = Ext.Function.createBuffered(a.setHighlightedItem, a.deferHighlight, a)
            }
        }
    },
    addCmpEvents                : function() {
        this.addEvents("beforeitemmousedown", "beforeitemmouseup", "beforeitemmouseenter", "beforeitemmouseleave", "beforeitemclick", "beforeitemdblclick", "beforeitemcontextmenu", "beforeitemkeydown", "itemmousedown", "itemmouseup", "itemmouseenter", "itemmouseleave", "itemclick", "itemdblclick", "itemcontextmenu", "itemkeydown", "beforecontainermousedown", "beforecontainermouseup", "beforecontainermouseover", "beforecontainermouseout", "beforecontainerclick", "beforecontainerdblclick", "beforecontainercontextmenu", "beforecontainerkeydown", "containermouseup", "containermouseover", "containermouseout", "containerclick", "containerdblclick", "containercontextmenu", "containerkeydown", "selectionchange", "beforeselect", "beforedeselect", "select", "deselect", "focuschange", "highlightitem", "unhighlightitem")
    },
    getFocusEl                  : function() {
        return this.getTargetEl()
    },
    afterRender                 : function() {
        var a = this, b = a.mouseOverOutBuffer ? a.onMouseOverOut : a.handleMouseOverOrOut;
        a.callParent();
        a.mon(a.getTargetEl(), {
            scope      : a,
            freezeEvent: true,
            click      : a.handleEvent,
            mousedown  : a.handleEvent,
            mouseup    : a.handleEvent,
            dblclick   : a.handleEvent,
            contextmenu: a.handleEvent,
            keydown    : a.handleEvent,
            mouseover  : b,
            mouseout   : b
        })
    },
    onMouseOverOut              : function(b) {
        var a = this;
        a.lastMouseOverOutEvent.setEvent(b.browserEvent, true);
        a.handleMouseOverOrOut(a.lastMouseOverOutEvent)
    },
    handleMouseOverOrOut        : function(d) {
        var c = this, b = d.type === "mouseout", f = b ? d.getRelatedTarget : d.getTarget, a = f.call(d, c.itemSelector) || f.call(d, c.dataRowSelector);
        if (!c.mouseOverItem || a !== c.mouseOverItem) {
            if (c.mouseOverItem) {
                d.item    = c.mouseOverItem;
                d.newType = "mouseleave";
                c.handleEvent(d)
            }
            c.mouseOverItem = a;
            if (c.mouseOverItem) {
                d.item    = c.mouseOverItem;
                d.newType = "mouseenter";
                c.handleEvent(d)
            }
        }
    },
    handleEvent                 : function(c) {
        var b = this, a = c.type == "keydown" && c.getKey();
        if (b.processUIEvent(c) !== false) {
            b.processSpecialEvent(c)
        }
        if (a === c.SPACE) {
            if (!b.inputTagRe.test(c.getTarget().tagName)) {
                c.stopEvent()
            }
        }
    },
    processItemEvent            : Ext.emptyFn,
    processContainerEvent       : Ext.emptyFn,
    processSpecialEvent         : Ext.emptyFn,
    processUIEvent              : function(g) {
        if (!Ext.getBody().isAncestor(g.target)) {
            return
        }
        var h = this, j = g.getTarget(h.getItemSelector(), h.getTargetEl()), a = this.statics().EventMap, f, d, i = g.type, c = g.type, b;
        if (g.newType) {
            c = g.newType;
            j = g.item
        }
        if (!j && i == "keydown") {
            b = h.getSelectionModel();
            d = b.lastFocused || b.getLastSelected();
            if (d) {
                j = h.getNode(d, true)
            }
        }
        if (j) {
            if (!d) {
                d = h.getRecord(j)
            }
            f = h.indexInStore ? h.indexInStore(d) : h.indexOf(j);
            if (!d || h.processItemEvent(d, j, f, g) === false) {
                return false
            }
            if ((h["onBeforeItem" + a[c]](d, j, f, g) === false) || (h.fireEvent("beforeitem" + c, h, d, j, f, g) === false) || (h["onItem" + a[c]](d, j, f, g) === false)) {
                return false
            }
            h.fireEvent("item" + c, h, d, j, f, g)
        } else {
            if ((h.processContainerEvent(g) === false) || (h["onBeforeContainer" + a[i]](g) === false) || (h.fireEvent("beforecontainer" + i, h, g) === false) || (h["onContainer" + a[i]](g) === false)) {
                return false
            }
            h.fireEvent("container" + i, h, g)
        }
        return true
    },
    onItemMouseEnter            : function(a, c, b, d) {
        if (this.trackOver) {
            this.highlightItem(c)
        }
    },
    onItemMouseLeave            : function(a, c, b, d) {
        if (this.trackOver) {
            this.clearHighlight()
        }
    },
    onItemMouseDown             : Ext.emptyFn,
    onItemMouseUp               : Ext.emptyFn,
    onItemFocus                 : Ext.emptyFn,
    onItemClick                 : Ext.emptyFn,
    onItemDblClick              : Ext.emptyFn,
    onItemContextMenu           : Ext.emptyFn,
    onItemKeyDown               : Ext.emptyFn,
    onBeforeItemMouseDown       : Ext.emptyFn,
    onBeforeItemMouseUp         : Ext.emptyFn,
    onBeforeItemFocus           : Ext.emptyFn,
    onBeforeItemMouseEnter      : Ext.emptyFn,
    onBeforeItemMouseLeave      : Ext.emptyFn,
    onBeforeItemClick           : Ext.emptyFn,
    onBeforeItemDblClick        : Ext.emptyFn,
    onBeforeItemContextMenu     : Ext.emptyFn,
    onBeforeItemKeyDown         : Ext.emptyFn,
    onContainerMouseDown        : Ext.emptyFn,
    onContainerMouseUp          : Ext.emptyFn,
    onContainerMouseOver        : Ext.emptyFn,
    onContainerMouseOut         : Ext.emptyFn,
    onContainerClick            : Ext.emptyFn,
    onContainerDblClick         : Ext.emptyFn,
    onContainerContextMenu      : Ext.emptyFn,
    onContainerKeyDown          : Ext.emptyFn,
    onBeforeContainerMouseDown  : Ext.emptyFn,
    onBeforeContainerMouseUp    : Ext.emptyFn,
    onBeforeContainerMouseOver  : Ext.emptyFn,
    onBeforeContainerMouseOut   : Ext.emptyFn,
    onBeforeContainerClick      : Ext.emptyFn,
    onBeforeContainerDblClick   : Ext.emptyFn,
    onBeforeContainerContextMenu: Ext.emptyFn,
    onBeforeContainerKeyDown    : Ext.emptyFn,
    setHighlightedItem          : function(e) {
        var d = this, c = d.highlightedItem, f = d.overItemCls, a = d.beforeOverItemCls, b;
        if (c != e) {
            if (c) {
                Ext.fly(c).removeCls(f);
                b = c.previousSibling;
                if (a && b) {
                    Ext.fly(b).removeCls(a)
                }
                d.fireEvent("unhighlightitem", d, c)
            }
            d.highlightedItem = e;
            if (e) {
                Ext.fly(e).addCls(d.overItemCls);
                b = e.previousSibling;
                if (a && b) {
                    Ext.fly(b).addCls(a)
                }
                d.fireEvent("highlightitem", d, e)
            }
        }
    },
    highlightItem               : function(a) {
        this.setHighlightedItem(a)
    },
    clearHighlight              : function() {
        this.setHighlightedItem(undefined)
    },
    onUpdate                    : function(b, a) {
        var f = this, e, c, d;
        if (f.viewReady) {
            e = f.getNode(a);
            c = f.callParent(arguments);
            d = f.highlightedItem;
            if (d && d === e) {
                delete f.highlightedItem;
                if (c) {
                    f.highlightItem(c)
                }
            }
        }
    },
    refresh                     : function() {
        this.clearHighlight();
        this.callParent(arguments)
    },
    focusNode                   : function(h) {
        var f    = this, e = f.getNode(h, true), d = f.el, a = 0, b = 0, g = d.getRegion(), c;
        g.bottom = g.top + d.dom.clientHeight;
        g.right  = g.left + d.dom.clientWidth;
        if (e) {
            c = Ext.fly(e).getRegion();
            if (c.top < g.top) {
                a = c.top - g.top
            } else {
                if (c.bottom > g.bottom) {
                    a = c.bottom - g.bottom
                }
            }
            if (c.left < g.left) {
                b = c.left - g.left
            } else {
                if (c.right > g.right) {
                    b = c.right - g.right
                }
            }
            if (b || a) {
                f.scrollBy(b, a, false)
            }
            d.focus()
        }
    }
});
Ext.define("Ext.layout.component.BoundList", {
    extend                               : "Ext.layout.component.Auto",
    alias                                : "layout.boundlist",
    type                                 : "component",
    beginLayout                          : function(d) {
        var c = this, a = c.owner, b = a.pagingToolbar;
        c.callParent(arguments);
        if (a.floating) {
            d.savedXY = a.getXY();
            a.setXY([0, -9999])
        }
        if (b) {
            d.toolbarContext = d.context.getCmp(b)
        }
        d.listContext = d.getEl("listEl")
    },
    beginLayoutCycle                     : function(b) {
        var a = this.owner;
        this.callParent(arguments);
        if (b.heightModel.auto) {
            a.el.setHeight("auto");
            a.listEl.setHeight("auto")
        }
    },
    getLayoutItems                       : function() {
        var a = this.owner.pagingToolbar;
        return a ? [a] : []
    },
    isValidParent                        : function() {
        return true
    },
    finishedLayout                       : function(a) {
        var b = a.savedXY;
        this.callParent(arguments);
        if (b) {
            this.owner.setXY(b)
        }
    },
    measureContentWidth                  : function(a) {
        return this.owner.listEl.getWidth()
    },
    measureContentHeight                 : function(a) {
        return this.owner.listEl.getHeight()
    },
    publishInnerHeight                   : function(c, a) {
        var b = c.toolbarContext, d = 0;
        if (b) {
            d = b.getProp("height")
        }
        if (d === undefined) {
            this.done = false
        } else {
            c.listContext.setHeight(a - c.getFrameInfo().height - d)
        }
    },
    calculateOwnerHeightFromContentHeight: function(c) {
        var a = this.callParent(arguments), b = c.toolbarContext;
        if (b) {
            a += b.getProp("height")
        }
        return a
    }
});
Ext.define("Ext.form.field.Spinner", {
    extend              : "Ext.form.field.Trigger",
    alias               : "widget.spinnerfield",
    alternateClassName  : "Ext.form.Spinner",
    requires            : ["Ext.util.KeyNav"],
    trigger1Cls         : Ext.baseCSSPrefix + "form-spinner-up",
    trigger2Cls         : Ext.baseCSSPrefix + "form-spinner-down",
    spinUpEnabled       : true,
    spinDownEnabled     : true,
    keyNavEnabled       : true,
    mouseWheelEnabled   : true,
    repeatTriggerClick  : true,
    onSpinUp            : Ext.emptyFn,
    onSpinDown          : Ext.emptyFn,
    triggerTpl          : '<td style="{triggerStyle}" class="{triggerCls}"><div class="' + Ext.baseCSSPrefix + "trigger-index-0 " + Ext.baseCSSPrefix + "form-trigger " + Ext.baseCSSPrefix + 'form-spinner-up {spinnerUpCls} {childElCls}" role="button"></div><div class="' + Ext.baseCSSPrefix + "trigger-index-1 " + Ext.baseCSSPrefix + "form-trigger " + Ext.baseCSSPrefix + 'form-spinner-down {spinnerDownCls} {childElCls}" role="button"></div></td></tr>',
    initComponent       : function() {
        this.callParent();
        this.addEvents("spin", "spinup", "spindown")
    },
    onRender            : function() {
        var b = this, a;
        b.callParent(arguments);
        a             = b.triggerEl;
        b.spinUpEl    = a.item(0);
        b.spinDownEl  = a.item(1);
        b.triggerCell = b.spinUpEl.parent();
        if (b.keyNavEnabled) {
            b.spinnerKeyNav = new Ext.util.KeyNav(b.inputEl, {
                scope: b,
                up   : b.spinUp,
                down : b.spinDown
            })
        }
        if (b.mouseWheelEnabled) {
            b.mon(b.bodyEl, "mousewheel", b.onMouseWheel, b)
        }
    },
    getSubTplMarkup     : function(b) {
        var c = this, a = b.childElCls, d = Ext.form.field.Base.prototype.getSubTplMarkup.apply(c, arguments);
        return '<table id="' + c.id + '-triggerWrap" class="' + Ext.baseCSSPrefix + "form-trigger-wrap" + a + '" cellpadding="0" cellspacing="0"><tbody><tr><td id="' + c.id + '-inputCell" class="' + Ext.baseCSSPrefix + "form-trigger-input-cell" + a + '">' + d + "</td>" + c.getTriggerMarkup() + "</tbody></table>"
    },
    getTriggerMarkup    : function() {
        return this.getTpl("triggerTpl").apply(this.getTriggerData())
    },
    getTriggerData      : function() {
        var a = this, b = (a.readOnly || a.hideTrigger);
        return {
            triggerCls    : Ext.baseCSSPrefix + "trigger-cell",
            triggerStyle  : b ? "display:none" : "",
            spinnerUpCls  : !a.spinUpEnabled ? a.trigger1Cls + "-disabled" : "",
            spinnerDownCls: !a.spinDownEnabled ? a.trigger2Cls + "-disabled" : ""
        }
    },
    getTriggerWidth     : function() {
        var b = this, a = 0;
        if (b.triggerWrap && !b.hideTrigger && !b.readOnly) {
            a = b.triggerWidth
        }
        return a
    },
    onTrigger1Click     : function() {
        this.spinUp()
    },
    onTrigger2Click     : function() {
        this.spinDown()
    },
    onTriggerWrapMouseup: function() {
        this.inputEl.focus()
    },
    spinUp              : function() {
        var a = this;
        if (a.spinUpEnabled && !a.disabled) {
            a.fireEvent("spin", a, "up");
            a.fireEvent("spinup", a);
            a.onSpinUp()
        }
    },
    spinDown            : function() {
        var a = this;
        if (a.spinDownEnabled && !a.disabled) {
            a.fireEvent("spin", a, "down");
            a.fireEvent("spindown", a);
            a.onSpinDown()
        }
    },
    setSpinUpEnabled    : function(a) {
        var b           = this, c = b.spinUpEnabled;
        b.spinUpEnabled = a;
        if (c !== a && b.rendered) {
            b.spinUpEl[a ? "removeCls" : "addCls"](b.trigger1Cls + "-disabled")
        }
    },
    setSpinDownEnabled  : function(a) {
        var b             = this, c = b.spinDownEnabled;
        b.spinDownEnabled = a;
        if (c !== a && b.rendered) {
            b.spinDownEl[a ? "removeCls" : "addCls"](b.trigger2Cls + "-disabled")
        }
    },
    onMouseWheel        : function(b) {
        var a = this, c;
        if (a.hasFocus) {
            c = b.getWheelDelta();
            if (c > 0) {
                a.spinUp()
            } else {
                if (c < 0) {
                    a.spinDown()
                }
            }
            b.stopEvent()
        }
    },
    onDestroy           : function() {
        Ext.destroyMembers(this, "spinnerKeyNav", "spinUpEl", "spinDownEl");
        this.callParent()
    }
});
Ext.define("Ext.form.field.Number", {
    extend               : "Ext.form.field.Spinner",
    alias                : "widget.numberfield",
    alternateClassName   : ["Ext.form.NumberField", "Ext.form.Number"],
    allowExponential     : true,
    allowDecimals        : true,
    decimalSeparator     : ".",
    submitLocaleSeparator: true,
    decimalPrecision     : 2,
    minValue             : Number.NEGATIVE_INFINITY,
    maxValue             : Number.MAX_VALUE,
    step                 : 1,
    minText              : "The minimum value for this field is {0}",
    maxText              : "The maximum value for this field is {0}",
    nanText              : "{0} is not a valid number",
    negativeText         : "The value cannot be negative",
    baseChars            : "0123456789",
    autoStripChars       : false,
    initComponent        : function() {
        var a = this;
        a.callParent();
        a.setMinValue(a.minValue);
        a.setMaxValue(a.maxValue)
    },
    getErrors            : function(c) {
        var b = this, e = b.callParent(arguments), d = Ext.String.format, a;
        c     = Ext.isDefined(c) ? c : this.processRawValue(this.getRawValue());
        if (c.length < 1) {
            return e
        }
        c = String(c).replace(b.decimalSeparator, ".");
        if (isNaN(c)) {
            e.push(d(b.nanText, c))
        }
        a = b.parseValue(c);
        if (b.minValue === 0 && a < 0) {
            e.push(this.negativeText)
        } else {
            if (a < b.minValue) {
                e.push(d(b.minText, b.minValue))
            }
        }
        if (a > b.maxValue) {
            e.push(d(b.maxText, b.maxValue))
        }
        return e
    },
    rawToValue           : function(b) {
        var a = this.fixPrecision(this.parseValue(b));
        if (a === null) {
            a = b || null
        }
        return a
    },
    valueToRaw           : function(c) {
        var b = this, a = b.decimalSeparator;
        c     = b.parseValue(c);
        c     = b.fixPrecision(c);
        c     = Ext.isNumber(c) ? c : parseFloat(String(c).replace(a, "."));
        c     = isNaN(c) ? "" : String(c).replace(".", a);
        return c
    },
    getSubmitValue       : function() {
        var a = this, b = a.callParent();
        if (!a.submitLocaleSeparator) {
            b = b.replace(a.decimalSeparator, ".")
        }
        return b
    },
    onChange             : function() {
        this.toggleSpinners();
        this.callParent(arguments)
    },
    toggleSpinners       : function() {
        var c = this, d = c.getValue(), b = d === null, a;
        if (c.spinUpEnabled || c.spinUpDisabledByToggle) {
            a = b || d < c.maxValue;
            c.setSpinUpEnabled(a, true)
        }
        if (c.spinDownEnabled || c.spinDownDisabledByToggle) {
            a = b || d > c.minValue;
            c.setSpinDownEnabled(a, true)
        }
    },
    setMinValue          : function(b) {
        var a      = this, c;
        a.minValue = Ext.Number.from(b, Number.NEGATIVE_INFINITY);
        a.toggleSpinners();
        if (a.disableKeyFilter !== true) {
            c = a.baseChars + "";
            if (a.allowExponential) {
                c += a.decimalSeparator + "e+-"
            } else {
                if (a.allowDecimals) {
                    c += a.decimalSeparator
                }
                if (a.minValue < 0) {
                    c += "-"
                }
            }
            c        = Ext.String.escapeRegex(c);
            a.maskRe = new RegExp("[" + c + "]");
            if (a.autoStripChars) {
                a.stripCharsRe = new RegExp("[^" + c + "]", "gi")
            }
        }
    },
    setMaxValue          : function(a) {
        this.maxValue = Ext.Number.from(a, Number.MAX_VALUE);
        this.toggleSpinners()
    },
    parseValue           : function(a) {
        a = parseFloat(String(a).replace(this.decimalSeparator, "."));
        return isNaN(a) ? null : a
    },
    fixPrecision         : function(d) {
        var c = this, b = isNaN(d), a = c.decimalPrecision;
        if (b || !d) {
            return b ? "" : d
        } else {
            if (!c.allowDecimals || a <= 0) {
                a = 0
            }
        }
        return parseFloat(Ext.Number.toFixed(parseFloat(d), a))
    },
    beforeBlur           : function() {
        var b = this, a = b.parseValue(b.getRawValue());
        if (!Ext.isEmpty(a)) {
            b.setValue(a)
        }
    },
    setSpinUpEnabled     : function(b, a) {
        this.callParent(arguments);
        if (!a) {
            delete this.spinUpDisabledByToggle
        } else {
            this.spinUpDisabledByToggle = !b
        }
    },
    onSpinUp             : function() {
        var a = this;
        if (!a.readOnly) {
            a.setSpinValue(Ext.Number.constrain(a.getValue() + a.step, a.minValue, a.maxValue))
        }
    },
    setSpinDownEnabled   : function(b, a) {
        this.callParent(arguments);
        if (!a) {
            delete this.spinDownDisabledByToggle
        } else {
            this.spinDownDisabledByToggle = !b
        }
    },
    onSpinDown           : function() {
        var a = this;
        if (!a.readOnly) {
            a.setSpinValue(Ext.Number.constrain(a.getValue() - a.step, a.minValue, a.maxValue))
        }
    },
    setSpinValue         : function(c) {
        var b = this, a;
        if (b.enforceMaxLength) {
            if (b.fixPrecision(c).toString().length > b.maxLength) {
                return
            }
        }
        b.setValue(c)
    }
});
Ext.define("Ext.toolbar.Paging", {
    extend            : "Ext.toolbar.Toolbar",
    alias             : "widget.pagingtoolbar",
    alternateClassName: "Ext.PagingToolbar",
    requires          : ["Ext.toolbar.TextItem", "Ext.form.field.Number"],
    mixins            : {bindable: "Ext.util.Bindable"},
    displayInfo       : false,
    prependButtons    : false,
    displayMsg        : "Displaying {0} - {1} of {2}",
    emptyMsg          : "No data to display",
    beforePageText    : "Page",
    afterPageText     : "of {0}",
    firstText         : "First Page",
    prevText          : "Previous Page",
    nextText          : "Next Page",
    lastText          : "Last Page",
    refreshText       : "Refresh",
    inputItemWidth    : 30,
    getPagingItems    : function() {
        var a = this;
        return [{
            itemId      : "first",
            tooltip     : a.firstText,
            overflowText: a.firstText,
            iconCls     : Ext.baseCSSPrefix + "tbar-page-first",
            disabled    : true,
            handler     : a.moveFirst,
            scope       : a
        }, {
            itemId      : "prev",
            tooltip     : a.prevText,
            overflowText: a.prevText,
            iconCls     : Ext.baseCSSPrefix + "tbar-page-prev",
            disabled    : true,
            handler     : a.movePrevious,
            scope       : a
        }, "-", a.beforePageText, {
            xtype          : "numberfield",
            itemId         : "inputItem",
            name           : "inputItem",
            cls            : Ext.baseCSSPrefix + "tbar-page-number",
            allowDecimals  : false,
            minValue       : 1,
            hideTrigger    : true,
            enableKeyEvents: true,
            keyNavEnabled  : false,
            selectOnFocus  : true,
            submitValue    : false,
            isFormField    : false,
            width          : a.inputItemWidth,
            margins        : "-1 2 3 2",
            listeners      : {
                scope  : a,
                keydown: a.onPagingKeyDown,
                blur   : a.onPagingBlur
            }
        }, {
            xtype : "tbtext",
            itemId: "afterTextItem",
            text  : Ext.String.format(a.afterPageText, 1)
        }, "-", {
            itemId      : "next",
            tooltip     : a.nextText,
            overflowText: a.nextText,
            iconCls     : Ext.baseCSSPrefix + "tbar-page-next",
            disabled    : true,
            handler     : a.moveNext,
            scope       : a
        }, {
            itemId      : "last",
            tooltip     : a.lastText,
            overflowText: a.lastText,
            iconCls     : Ext.baseCSSPrefix + "tbar-page-last",
            disabled    : true,
            handler     : a.moveLast,
            scope       : a
        }, "-", {
            itemId      : "refresh",
            tooltip     : a.refreshText,
            overflowText: a.refreshText,
            iconCls     : Ext.baseCSSPrefix + "tbar-loading",
            handler     : a.doRefresh,
            scope       : a
        }]
    },
    initComponent     : function() {
        var b = this, c = b.getPagingItems(), a = b.items || b.buttons || [];
        if (b.prependButtons) {
            b.items = a.concat(c)
        } else {
            b.items = c.concat(a)
        }
        delete b.buttons;
        if (b.displayInfo) {
            b.items.push("->");
            b.items.push({
                xtype : "tbtext",
                itemId: "displayItem"
            })
        }
        b.callParent();
        b.addEvents("change", "beforechange");
        b.on("beforerender", b.onLoad, b, {single: true});
        b.bindStore(b.store || "ext-empty-store", true)
    },
    updateInfo        : function() {
        var e = this, c = e.child("#displayItem"), a = e.store, b = e.getPageData(), d, f;
        if (c) {
            d = a.getCount();
            if (d === 0) {
                f = e.emptyMsg
            } else {
                f = Ext.String.format(e.displayMsg, b.fromRecord, b.toRecord, b.total)
            }
            c.setText(f)
        }
    },
    onLoad            : function() {
        var g = this, d, b, c, a, f, h, e;
        f     = g.store.getCount();
        h     = f === 0;
        if (!h) {
            d = g.getPageData();
            b = d.currentPage;
            c = d.pageCount;
            a = Ext.String.format(g.afterPageText, isNaN(c) ? 1 : c)
        } else {
            b = 0;
            c = 0;
            a = Ext.String.format(g.afterPageText, 0)
        }
        Ext.suspendLayouts();
        e = g.child("#afterTextItem");
        if (e) {
            e.setText(a)
        }
        e = g.getInputItem();
        if (e) {
            e.setDisabled(h).setValue(b)
        }
        g.setChildDisabled("#first", b === 1 || h);
        g.setChildDisabled("#prev", b === 1 || h);
        g.setChildDisabled("#next", b === c || h);
        g.setChildDisabled("#last", b === c || h);
        g.setChildDisabled("#refresh", false);
        g.updateInfo();
        Ext.resumeLayouts(true);
        if (g.rendered) {
            g.fireEvent("change", g, d)
        }
    },
    setChildDisabled  : function(a, b) {
        var c = this.child(a);
        if (c) {
            c.setDisabled(b)
        }
    },
    getPageData       : function() {
        var b = this.store, a = b.getTotalCount();
        return {
            total      : a,
            currentPage: b.currentPage,
            pageCount  : Math.ceil(a / b.pageSize),
            fromRecord : ((b.currentPage - 1) * b.pageSize) + 1,
            toRecord   : Math.min(b.currentPage * b.pageSize, a)
        }
    },
    onLoadError       : function() {
        if (!this.rendered) {
            return
        }
        this.setChildDisabled("#refresh", false)
    },
    getInputItem      : function() {
        return this.child("#inputItem")
    },
    readPageFromInput : function(b) {
        var c = this.getInputItem(), d = false, a;
        if (c) {
            a = c.getValue();
            d = parseInt(a, 10);
            if (!a || isNaN(d)) {
                c.setValue(b.currentPage);
                return false
            }
        }
        return d
    },
    onPagingFocus     : function() {
        var a = this.getInputItem();
        if (a) {
            a.select()
        }
    },
    onPagingBlur      : function(c) {
        var b = this.getInputItem(), a;
        if (b) {
            a = this.getPageData().currentPage;
            b.setValue(a)
        }
    },
    onPagingKeyDown   : function(h, g) {
        var d = this, b = g.getKey(), c = d.getPageData(), a = g.shiftKey ? 10 : 1, f;
        if (b == g.RETURN) {
            g.stopEvent();
            f = d.readPageFromInput(c);
            if (f !== false) {
                f = Math.min(Math.max(1, f), c.pageCount);
                if (d.fireEvent("beforechange", d, f) !== false) {
                    d.store.loadPage(f)
                }
            }
        } else {
            if (b == g.HOME || b == g.END) {
                g.stopEvent();
                f = b == g.HOME ? 1 : c.pageCount;
                h.setValue(f)
            } else {
                if (b == g.UP || b == g.PAGE_UP || b == g.DOWN || b == g.PAGE_DOWN) {
                    g.stopEvent();
                    f = d.readPageFromInput(c);
                    if (f) {
                        if (b == g.DOWN || b == g.PAGE_DOWN) {
                            a *= -1
                        }
                        f += a;
                        if (f >= 1 && f <= c.pageCount) {
                            h.setValue(f)
                        }
                    }
                }
            }
        }
    },
    beforeLoad        : function() {
        if (this.rendered) {
            this.setChildDisabled("#refresh", true)
        }
    },
    moveFirst         : function() {
        if (this.fireEvent("beforechange", this, 1) !== false) {
            this.store.loadPage(1)
        }
    },
    movePrevious      : function() {
        var b = this, a = b.store.currentPage - 1;
        if (a > 0) {
            if (b.fireEvent("beforechange", b, a) !== false) {
                b.store.previousPage()
            }
        }
    },
    moveNext          : function() {
        var c = this, b = c.getPageData().pageCount, a = c.store.currentPage + 1;
        if (a <= b) {
            if (c.fireEvent("beforechange", c, a) !== false) {
                c.store.nextPage()
            }
        }
    },
    moveLast          : function() {
        var b = this, a = b.getPageData().pageCount;
        if (b.fireEvent("beforechange", b, a) !== false) {
            b.store.loadPage(a)
        }
    },
    doRefresh         : function() {
        var a = this, b = a.store.currentPage;
        if (a.fireEvent("beforechange", a, b) !== false) {
            a.store.loadPage(b)
        }
    },
    getStoreListeners : function() {
        return {
            beforeload: this.beforeLoad,
            load      : this.onLoad,
            exception : this.onLoadError
        }
    },
    unbind            : function(a) {
        this.bindStore(null)
    },
    bind              : function(a) {
        this.bindStore(a)
    },
    onDestroy         : function() {
        this.unbind();
        this.callParent()
    }
});
Ext.define("Ext.view.BoundList", {
    extend              : "Ext.view.View",
    alias               : "widget.boundlist",
    alternateClassName  : "Ext.BoundList",
    requires            : ["Ext.layout.component.BoundList", "Ext.toolbar.Paging"],
    mixins              : {queryable: "Ext.Queryable"},
    pageSize            : 0,
    baseCls             : Ext.baseCSSPrefix + "boundlist",
    itemCls             : Ext.baseCSSPrefix + "boundlist-item",
    listItemCls         : "",
    shadow              : false,
    trackOver           : true,
    refreshed           : 0,
    deferInitialRefresh : false,
    componentLayout     : "boundlist",
    childEls            : ["listEl"],
    renderTpl           : ['<div id="{id}-listEl" class="{baseCls}-list-ct ', Ext.dom.Element.unselectableCls, '" style="overflow:auto"></div>', "{%", "var me=values.$comp, pagingToolbar=me.pagingToolbar;", "if (pagingToolbar) {", "pagingToolbar.ownerLayout = me.componentLayout;", "Ext.DomHelper.generateMarkup(pagingToolbar.getRenderTree(), out);", "}", "%}", {disableFormats: true}],
    initComponent       : function() {
        var b             = this, a = b.baseCls, c = b.itemCls;
        b.selectedItemCls = a + "-selected";
        if (b.trackOver) {
            b.overItemCls = a + "-item-over"
        }
        b.itemSelector = "." + c;
        if (b.floating) {
            b.addCls(a + "-floating")
        }
        if (!b.tpl) {
            b.tpl = new Ext.XTemplate('<ul class="' + Ext.plainListCls + '"><tpl for=".">', '<li role="option" unselectable="on" class="' + c + '">' + b.getInnerTpl(b.displayField) + "</li>", "</tpl></ul>")
        } else {
            if (!b.tpl.isTemplate) {
                b.tpl = new Ext.XTemplate(b.tpl)
            }
        }
        if (b.pageSize) {
            b.pagingToolbar = b.createPagingToolbar()
        }
        b.callParent()
    },
    beforeRender        : function() {
        var a = this;
        a.callParent(arguments);
        if (a.up("menu")) {
            a.addCls(Ext.baseCSSPrefix + "menu")
        }
    },
    getRefOwner         : function() {
        return this.pickerField || this.callParent()
    },
    getRefItems         : function() {
        return this.pagingToolbar ? [this.pagingToolbar] : []
    },
    createPagingToolbar : function() {
        return Ext.widget("pagingtoolbar", {
            id         : this.id + "-paging-toolbar",
            pageSize   : this.pageSize,
            store      : this.dataSource,
            border     : false,
            ownerCt    : this,
            ownerLayout: this.getComponentLayout()
        })
    },
    finishRenderChildren: function() {
        var a = this.pagingToolbar;
        this.callParent(arguments);
        if (a) {
            a.finishRender()
        }
    },
    refresh             : function() {
        var c   = this, a = c.tpl, b = c.pagingToolbar, d = c.rendered;
        a.field = c.pickerField;
        a.store = c.store;
        c.callParent();
        a.field = a.store = null;
        if (d && b && b.rendered && !c.preserveScrollOnRefresh) {
            c.el.appendChild(b.el)
        }
        if (d && Ext.isIE6 && Ext.isStrict) {
            c.listEl.repaint()
        }
    },
    bindStore           : function(a, b) {
        var c = this.pagingToolbar;
        this.callParent(arguments);
        if (c) {
            c.bindStore(a, b)
        }
    },
    getTargetEl         : function() {
        return this.listEl || this.el
    },
    getInnerTpl         : function(a) {
        return "{" + a + "}"
    },
    onDestroy           : function() {
        Ext.destroyMembers(this, "pagingToolbar", "listEl");
        this.callParent()
    }
});
Ext.define("Ext.view.BoundListKeyNav", {
    extend           : "Ext.util.KeyNav",
    requires         : "Ext.view.BoundList",
    constructor      : function(b, a) {
        var c       = this;
        c.boundList = a.boundList;
        c.callParent([b, Ext.apply({}, a, c.defaultHandlers)])
    },
    defaultHandlers  : {
        up      : function() {
            var e = this, b = e.boundList, d = b.all, f = b.highlightedItem, c = f ? b.indexOf(f) : -1, a = c > 0 ? c - 1 : d.getCount() - 1;
            e.highlightAt(a)
        },
        down    : function() {
            var e = this, b = e.boundList, d = b.all, f = b.highlightedItem, c = f ? b.indexOf(f) : -1, a = c < d.getCount() - 1 ? c + 1 : 0;
            e.highlightAt(a)
        },
        pageup  : function() {
        },
        pagedown: function() {
        },
        home    : function() {
            this.highlightAt(0)
        },
        end     : function() {
            var a = this;
            a.highlightAt(a.boundList.all.getCount() - 1)
        },
        enter   : function(a) {
            this.selectHighlighted(a)
        }
    },
    highlightAt      : function(b) {
        var a = this.boundList, c = a.all.item(b);
        if (c) {
            c = c.dom;
            a.highlightItem(c);
            a.getTargetEl().scrollChildIntoView(c, false)
        }
    },
    selectHighlighted: function(f) {
        var d = this, b = d.boundList, c = b.highlightedItem, a = b.getSelectionModel();
        if (c) {
            a.selectWithEvent(b.getRecord(c), f)
        }
    }
});
Ext.define("Ext.layout.component.field.ComboBox", {
    extend       : "Ext.layout.component.field.Trigger",
    alias        : "layout.combobox",
    requires     : ["Ext.util.TextMetrics"],
    type         : "combobox",
    startingWidth: null,
    getTextWidth : function() {
        var g = this, b = g.owner, k = b.store, h = b.displayField, d = k.data.length, j = "", e = 0, c = 0, f, l, a;
        for (; e < d; e++) {
            l = k.getAt(e).data[h];
            f = l.length;
            if (f > c) {
                c = f;
                j = l
            }
        }
        a = Math.max(g.callParent(arguments), b.inputEl.getTextWidth(j + b.growAppend));
        if (!g.startingWidth || b.removingRecords) {
            g.startingWidth = a;
            if (a < b.growMin) {
                b.defaultListConfig.minWidth = b.growMin
            }
            b.removingRecords = false
        }
        return (a < g.startingWidth) ? g.startingWidth : a
    }
});
Ext.define("Ext.form.field.ComboBox", {
    extend               : "Ext.form.field.Picker",
    requires             : ["Ext.util.DelayedTask", "Ext.EventObject", "Ext.view.BoundList", "Ext.view.BoundListKeyNav", "Ext.data.StoreManager", "Ext.layout.component.field.ComboBox"],
    alternateClassName   : "Ext.form.ComboBox",
    alias                : ["widget.combobox", "widget.combo"],
    mixins               : {bindable: "Ext.util.Bindable"},
    componentLayout      : "combobox",
    triggerCls           : Ext.baseCSSPrefix + "form-arrow-trigger",
    hiddenName           : "",
    hiddenDataCls        : Ext.baseCSSPrefix + "hide-display " + Ext.baseCSSPrefix + "form-data-hidden",
    fieldSubTpl          : ['<div class="{hiddenDataCls}" role="presentation"></div>', '<input id="{id}" type="{type}" {inputAttrTpl} class="{fieldCls} {typeCls} {editableCls}" autocomplete="off"', '<tpl if="value"> value="{[Ext.util.Format.htmlEncode(values.value)]}"</tpl>', '<tpl if="name"> name="{name}"</tpl>', '<tpl if="placeholder"> placeholder="{placeholder}"</tpl>', '<tpl if="size"> size="{size}"</tpl>', '<tpl if="maxLength !== undefined"> maxlength="{maxLength}"</tpl>', '<tpl if="readOnly"> readonly="readonly"</tpl>', '<tpl if="disabled"> disabled="disabled"</tpl>', '<tpl if="tabIdx"> tabIndex="{tabIdx}"</tpl>', '<tpl if="fieldStyle"> style="{fieldStyle}"</tpl>', "/>", {
        compiled      : true,
        disableFormats: true
    }],
    getSubTplData        : function() {
        var a = this;
        Ext.applyIf(a.subTplData, {hiddenDataCls: a.hiddenDataCls});
        return a.callParent(arguments)
    },
    afterRender          : function() {
        var a = this;
        a.callParent(arguments);
        a.setHiddenValue(a.value)
    },
    multiSelect          : false,
    delimiter            : ", ",
    displayField         : "text",
    triggerAction        : "all",
    allQuery             : "",
    queryParam           : "query",
    queryMode            : "remote",
    queryCaching         : true,
    pageSize             : 0,
    anyMatch             : false,
    caseSensitive        : false,
    autoSelect           : true,
    typeAhead            : false,
    typeAheadDelay       : 250,
    selectOnTab          : true,
    forceSelection       : false,
    growToLongestValue   : true,
    defaultListConfig    : {
        loadingHeight: 70,
        minWidth     : 70,
        maxHeight    : 300,
        shadow       : "sides"
    },
    ignoreSelection      : 0,
    removingRecords      : null,
    resizeComboToGrow    : function() {
        var a = this;
        return a.grow && a.growToLongestValue
    },
    initComponent        : function() {
        var e = this, c = Ext.isDefined, b = e.store, d = e.transform, a, f;
        Ext.applyIf(e.renderSelectors, {hiddenDataEl: "." + e.hiddenDataCls.split(" ").join(".")});
        this.addEvents("beforequery", "select", "beforeselect", "beforedeselect");
        if (d) {
            a = Ext.getDom(d);
            if (a) {
                if (!e.store) {
                    b = Ext.Array.map(Ext.Array.from(a.options), function(g) {
                        return [g.value, g.text]
                    })
                }
                if (!e.name) {
                    e.name = a.name
                }
                if (!("value" in e)) {
                    e.value = a.value
                }
            }
        }
        e.bindStore(b || "ext-empty-store", true);
        b = e.store;
        if (b.autoCreated) {
            e.queryMode  = "local";
            e.valueField = e.displayField = "field1";
            if (!b.expanded) {
                e.displayField = "field2"
            }
        }
        if (!c(e.valueField)) {
            e.valueField = e.displayField
        }
        f = e.queryMode === "local";
        if (!c(e.queryDelay)) {
            e.queryDelay = f ? 10 : 500
        }
        if (!c(e.minChars)) {
            e.minChars = f ? 0 : 4
        }
        if (!e.displayTpl) {
            e.displayTpl = new Ext.XTemplate('<tpl for=".">{[typeof values === "string" ? values : values["' + e.displayField + '"]]}<tpl if="xindex < xcount">' + e.delimiter + "</tpl></tpl>")
        } else {
            if (Ext.isString(e.displayTpl)) {
                e.displayTpl = new Ext.XTemplate(e.displayTpl)
            }
        }
        e.callParent();
        e.doQueryTask = new Ext.util.DelayedTask(e.doRawQuery, e);
        if (e.store.getCount() > 0) {
            e.setValue(e.value)
        }
        if (a) {
            e.render(a.parentNode, a);
            Ext.removeNode(a);
            delete e.renderTo
        }
    },
    getStore             : function() {
        return this.store
    },
    beforeBlur           : function() {
        this.doQueryTask.cancel();
        this.assertValue()
    },
    assertValue          : function() {
        var b = this, c = b.getRawValue(), d, a;
        if (b.forceSelection) {
            if (b.multiSelect) {
                if (c !== b.getDisplayValue()) {
                    b.setValue(b.lastSelection)
                }
            } else {
                d = b.findRecordByDisplay(c);
                if (d) {
                    a = b.value;
                    if (!b.findRecordByValue(a)) {
                        b.select(d, true)
                    }
                } else {
                    b.setValue(b.lastSelection)
                }
            }
        }
        b.collapse()
    },
    onTypeAhead          : function() {
        var e = this, d = e.displayField, b = e.store.findRecord(d, e.getRawValue()), c = e.getPicker(), f, a, g;
        if (b) {
            f = b.get(d);
            a = f.length;
            g = e.getRawValue().length;
            c.highlightItem(c.getNode(b));
            if (g !== 0 && g !== a) {
                e.setRawValue(f);
                e.selectText(g, f.length)
            }
        }
    },
    resetToDefault       : Ext.emptyFn,
    beforeReset          : function() {
        this.callParent();
        if (this.queryFilter && !this.queryFilter.disabled) {
            this.queryFilter.disabled = true;
            this.store.filter()
        }
    },
    onUnbindStore        : function(a) {
        var c = this, b = c.picker;
        if (c.queryFilter) {
            c.store.removeFilter(c.queryFilter)
        }
        if (!a && b) {
            b.bindStore(null)
        }
    },
    onBindStore          : function(a, c) {
        var b = this.picker;
        if (!c) {
            this.resetToDefault()
        }
        if (b) {
            b.bindStore(a)
        }
    },
    getStoreListeners    : function() {
        var a = this;
        return {
            beforeload : a.onBeforeLoad,
            clear      : a.onClear,
            datachanged: a.onDataChanged,
            load       : a.onLoad,
            exception  : a.onException,
            remove     : a.onRemove
        }
    },
    onBeforeLoad         : function() {
        ++this.ignoreSelection
    },
    onDataChanged        : function() {
        var a = this;
        if (a.resizeComboToGrow()) {
            a.updateLayout()
        }
    },
    onClear              : function() {
        var a = this;
        if (a.resizeComboToGrow()) {
            a.removingRecords = true;
            a.onDataChanged()
        }
    },
    onRemove             : function() {
        var a = this;
        if (a.resizeComboToGrow()) {
            a.removingRecords = true
        }
    },
    onException          : function() {
        if (this.ignoreSelection > 0) {
            --this.ignoreSelection
        }
        this.collapse()
    },
    onLoad               : function(b, a, d) {
        var c = this;
        if (c.ignoreSelection > 0) {
            --c.ignoreSelection
        }
        if (d && !b.lastOptions.rawQuery) {
            if (c.value == null) {
                if (c.store.getCount()) {
                    c.doAutoSelect()
                } else {
                    c.setValue(c.value)
                }
            } else {
                c.setValue(c.value)
            }
        }
    },
    doRawQuery           : function() {
        this.doQuery(this.getRawValue(), false, true)
    },
    doQuery              : function(e, b, d) {
        var c = this, a = c.beforeQuery({
            query   : e || "",
            rawQuery: d,
            forceAll: b,
            combo   : c,
            cancel  : false
        });
        if (a === false || a.cancel) {
            return false
        }
        if (c.queryCaching && a.query === c.lastQuery) {
            c.expand()
        } else {
            c.lastQuery = a.query;
            if (c.queryMode === "local") {
                c.doLocalQuery(a)
            } else {
                c.doRemoteQuery(a)
            }
        }
        return true
    },
    beforeQuery          : function(a) {
        var b = this;
        if (b.fireEvent("beforequery", a) === false) {
            a.cancel = true
        } else {
            if (!a.cancel) {
                if (a.query.length < b.minChars && !a.forceAll) {
                    a.cancel = true
                }
            }
        }
        return a
    },
    doLocalQuery         : function(a) {
        var b = this, c = a.query;
        if (!b.queryFilter) {
            b.queryFilter = new Ext.util.Filter({
                id           : b.id + "-query-filter",
                anyMatch     : b.anyMatch,
                caseSensitive: b.caseSensitive,
                root         : "data",
                property     : b.displayField
            });
            b.store.addFilter(b.queryFilter, false)
        }
        if (c || !a.forceAll) {
            b.queryFilter.disabled = false;
            b.queryFilter.setValue(b.enableRegEx ? new RegExp(c) : c)
        } else {
            b.queryFilter.disabled = true
        }
        b.store.filter();
        if (b.store.getCount()) {
            b.expand()
        } else {
            b.collapse()
        }
        b.afterQuery(a)
    },
    doRemoteQuery        : function(b) {
        var c = this, a = function() {
            c.afterQuery(b)
        };
        c.expand();
        if (c.pageSize) {
            c.loadPage(1, {
                rawQuery: b.rawQuery,
                callback: a
            })
        } else {
            c.store.load({
                params  : c.getParams(b.query),
                rawQuery: b.rawQuery,
                callback: a
            })
        }
    },
    afterQuery           : function(a) {
        var b = this;
        if (b.store.getCount()) {
            if (b.typeAhead) {
                b.doTypeAhead()
            }
            if (b.getRawValue() !== b.getDisplayValue()) {
                b.ignoreSelection++;
                b.picker.getSelectionModel().deselectAll();
                b.ignoreSelection--
            }
            if (a.rawQuery) {
                b.syncSelection();
                if (b.picker && !b.picker.getSelectionModel().hasSelection()) {
                    b.doAutoSelect()
                }
            } else {
                b.doAutoSelect()
            }
        }
    },
    loadPage             : function(b, a) {
        this.store.loadPage(b, Ext.apply({params: this.getParams(this.lastQuery)}, a))
    },
    onPageChange         : function(b, a) {
        this.loadPage(a);
        return false
    },
    getParams            : function(c) {
        var b = {}, a = this.queryParam;
        if (a) {
            b[a] = c
        }
        return b
    },
    doAutoSelect         : function() {
        var b = this, a = b.picker, c, d;
        if (a && b.autoSelect && b.store.getCount() > 0) {
            c = a.getSelectionModel().lastSelected;
            d = a.getNode(c || 0);
            if (d) {
                a.highlightItem(d);
                a.listEl.scrollChildIntoView(d, false)
            }
        }
    },
    doTypeAhead          : function() {
        if (!this.typeAheadTask) {
            this.typeAheadTask = new Ext.util.DelayedTask(this.onTypeAhead, this)
        }
        if (this.lastKey != Ext.EventObject.BACKSPACE && this.lastKey != Ext.EventObject.DELETE) {
            this.typeAheadTask.delay(this.typeAheadDelay)
        }
    },
    onTriggerClick       : function() {
        var a = this;
        if (!a.readOnly && !a.disabled) {
            if (a.isExpanded) {
                a.collapse()
            } else {
                a.onFocus({});
                if (a.triggerAction === "all") {
                    a.doQuery(a.allQuery, true)
                } else {
                    if (a.triggerAction === "last") {
                        a.doQuery(a.lastQuery, true)
                    } else {
                        a.doQuery(a.getRawValue(), false, true)
                    }
                }
            }
            a.inputEl.focus()
        }
    },
    onPaste              : function() {
        var a = this;
        if (!a.readOnly && !a.disabled && a.editable) {
            a.doQueryTask.delay(a.queryDelay)
        }
    },
    onKeyUp              : function(d, b) {
        var c = this, a = d.getKey();
        if (!c.readOnly && !c.disabled && c.editable) {
            c.lastKey = a;
            if (!d.isSpecialKey() || a == d.BACKSPACE || a == d.DELETE) {
                c.doQueryTask.delay(c.queryDelay)
            }
        }
        if (c.enableKeyEvents) {
            c.callParent(arguments)
        }
    },
    initEvents           : function() {
        var a = this;
        a.callParent();
        if (!a.enableKeyEvents) {
            a.mon(a.inputEl, "keyup", a.onKeyUp, a)
        }
        a.mon(a.inputEl, "paste", a.onPaste, a)
    },
    onDestroy            : function() {
        Ext.destroy(this.listKeyNav);
        this.bindStore(null);
        this.callParent()
    },
    onAdded              : function() {
        var a = this;
        a.callParent(arguments);
        if (a.picker) {
            a.picker.ownerCt = a.up("[floating]");
            a.picker.registerWithOwnerCt()
        }
    },
    createPicker         : function() {
        var c = this, b, a = Ext.apply({
            xtype         : "boundlist",
            pickerField   : c,
            selModel      : {mode: c.multiSelect ? "SIMPLE" : "SINGLE"},
            floating      : true,
            hidden        : true,
            store         : c.store,
            displayField  : c.displayField,
            focusOnToFront: false,
            pageSize      : c.pageSize,
            tpl           : c.tpl
        }, c.listConfig, c.defaultListConfig);
        b     = c.picker = Ext.widget(a);
        if (c.pageSize) {
            b.pagingToolbar.on("beforechange", c.onPageChange, c)
        }
        c.mon(b, {
            itemclick: c.onItemClick,
            refresh  : c.onListRefresh,
            scope    : c
        });
        c.mon(b.getSelectionModel(), {
            beforeselect   : c.onBeforeSelect,
            beforedeselect : c.onBeforeDeselect,
            selectionchange: c.onListSelectionChange,
            scope          : c
        });
        return b
    },
    alignPicker          : function() {
        var b = this, a = b.getPicker(), e = b.getPosition()[1] - Ext.getBody().getScroll().top, d = Ext.Element.getViewHeight() - e - b.getHeight(), c = Math.max(e, d);
        if (a.height) {
            delete a.height;
            a.updateLayout()
        }
        if (a.getHeight() > c - 5) {
            a.setHeight(c - 5)
        }
        b.callParent()
    },
    onListRefresh        : function() {
        if (!this.expanding) {
            this.alignPicker()
        }
        this.syncSelection()
    },
    onItemClick          : function(c, a) {
        var e = this, d = e.picker.getSelectionModel().getSelection(), b = e.valueField;
        if (!e.multiSelect && d.length) {
            if (a.get(b) === d[0].get(b)) {
                e.displayTplData = [a.data];
                e.setRawValue(e.getDisplayValue());
                e.collapse()
            }
        }
    },
    onBeforeSelect       : function(b, a) {
        return this.fireEvent("beforeselect", this, a, a.index)
    },
    onBeforeDeselect     : function(b, a) {
        return this.fireEvent("beforedeselect", this, a, a.index)
    },
    onListSelectionChange: function(b, d) {
        var a = this, e = a.multiSelect, c = d.length > 0;
        if (!a.ignoreSelection && a.isExpanded) {
            if (!e) {
                Ext.defer(a.collapse, 1, a)
            }
            if (e || c) {
                a.setValue(d, false)
            }
            if (c) {
                a.fireEvent("select", a, d)
            }
            a.inputEl.focus()
        }
    },
    onExpand             : function() {
        var d = this, a = d.listKeyNav, c = d.selectOnTab, b = d.getPicker();
        if (a) {
            a.enable()
        } else {
            a = d.listKeyNav = new Ext.view.BoundListKeyNav(this.inputEl, {
                boundList   : b,
                forceKeyDown: true,
                tab         : function(f) {
                    if (c) {
                        this.selectHighlighted(f);
                        d.triggerBlur()
                    }
                    return true
                },
                enter       : function(h) {
                    var f = b.getSelectionModel(), g = f.getCount();
                    this.selectHighlighted(h);
                    if (!d.multiSelect && g === f.getCount()) {
                        d.collapse()
                    }
                }
            })
        }
        if (c) {
            d.ignoreMonitorTab = true
        }
        Ext.defer(a.enable, 1, a);
        d.inputEl.focus()
    },
    onCollapse           : function() {
        var b = this, a = b.listKeyNav;
        if (a) {
            a.disable();
            b.ignoreMonitorTab = false
        }
    },
    select               : function(e, b) {
        var d = this, c = d.picker, a = true, f;
        if (e && e.isModel && b === true && c) {
            f = !c.getSelectionModel().isSelected(e)
        }
        d.setValue(e, true);
        if (f) {
            d.fireEvent("select", d, e)
        }
    },
    findRecord           : function(d, c) {
        var b = this.store, a = b.findExact(d, c);
        return a !== -1 ? b.getAt(a) : false
    },
    findRecordByValue    : function(a) {
        return this.findRecord(this.valueField, a)
    },
    findRecordByDisplay  : function(a) {
        return this.findRecord(this.displayField, a)
    },
    setValue             : function(l, e) {
        var j = this, c = j.valueNotFoundText, m = j.inputEl, f, h, g, a, k = [], b = [], d = [];
        if (j.store.loading) {
            j.value = l;
            j.setHiddenValue(j.value);
            return j
        }
        l = Ext.Array.from(l);
        for (f = 0, h = l.length; f < h; f++) {
            g = l[f];
            if (!g || !g.isModel) {
                g = j.findRecordByValue(g)
            }
            if (g) {
                k.push(g);
                b.push(g.data);
                d.push(g.get(j.valueField))
            } else {
                if (!j.forceSelection) {
                    d.push(l[f]);
                    a                 = {};
                    a[j.displayField] = l[f];
                    b.push(a)
                } else {
                    if (Ext.isDefined(c)) {
                        b.push(c)
                    }
                }
            }
        }
        j.setHiddenValue(d);
        j.value = j.multiSelect ? d : d[0];
        if (!Ext.isDefined(j.value)) {
            j.value = null
        }
        j.displayTplData = b;
        j.lastSelection  = j.valueModels = k;
        if (m && j.emptyText && !Ext.isEmpty(l)) {
            m.removeCls(j.emptyCls)
        }
        j.setRawValue(j.getDisplayValue());
        j.checkChange();
        if (e !== false) {
            j.syncSelection()
        }
        j.applyEmptyText();
        return j
    },
    setHiddenValue       : function(h) {
        var e = this, a = e.hiddenName, d, b, j, g, f, c;
        if (!e.hiddenDataEl || !a) {
            return
        }
        h = Ext.Array.from(h);
        b = e.hiddenDataEl.dom;
        j = b.childNodes;
        g = j[0];
        f = h.length;
        c = j.length;
        if (!g && f > 0) {
            e.hiddenDataEl.update(Ext.DomHelper.markup({
                tag : "input",
                type: "hidden",
                name: a
            }));
            c = 1;
            g = b.firstChild
        }
        while (c > f) {
            b.removeChild(j[0]);
            --c
        }
        while (c < f) {
            b.appendChild(g.cloneNode(true));
            ++c
        }
        for (d = 0; d < f; d++) {
            j[d].value = h[d]
        }
    },
    getDisplayValue      : function() {
        return this.displayTpl.apply(this.displayTplData)
    },
    getValue             : function() {
        var b = this, a = b.picker, d = b.getRawValue(), c = b.value;
        if (b.getDisplayValue() !== d) {
            c       = d;
            b.value = b.displayTplData = b.valueModels = null;
            if (a) {
                b.ignoreSelection++;
                a.getSelectionModel().deselectAll();
                b.ignoreSelection--
            }
        }
        return c
    },
    getSubmitValue       : function() {
        var a = this.getValue();
        if (Ext.isEmpty(a)) {
            a = ""
        }
        return a
    },
    isEqual              : function(e, d) {
        var b = Ext.Array.from, c, a;
        e     = b(e);
        d     = b(d);
        a     = e.length;
        if (a !== d.length) {
            return false
        }
        for (c = 0; c < a; c++) {
            if (d[c] !== e[c]) {
                return false
            }
        }
        return true
    },
    clearValue           : function() {
        this.setValue([])
    },
    syncSelection        : function() {
        var g = this, d = g.picker, f, c, b = g.valueModels || [], e = b.length, a, h;
        if (d) {
            f = [];
            for (a = 0; a < e; a++) {
                h = b[a];
                if (h && h.isModel && g.store.indexOf(h) >= 0) {
                    f.push(h)
                }
            }
            g.ignoreSelection++;
            c = d.getSelectionModel();
            c.deselectAll();
            if (f.length) {
                c.select(f, undefined, true)
            }
            g.ignoreSelection--
        }
    },
    onEditorTab          : function(b) {
        var a = this.listKeyNav;
        if (this.selectOnTab && a) {
            a.selectHighlighted(b)
        }
    }
});
Ext.define("ExtThemeNeptune.toolbar.Paging", {
    override       : "Ext.toolbar.Paging",
    defaultButtonUI: "plain-toolbar",
    inputItemWidth : 40
});
Ext.define("Ext.picker.Month", {
    extend              : "Ext.Component",
    requires            : ["Ext.XTemplate", "Ext.util.ClickRepeater", "Ext.Date", "Ext.button.Button"],
    alias               : "widget.monthpicker",
    alternateClassName  : "Ext.MonthPicker",
    childEls            : ["bodyEl", "prevEl", "nextEl", "buttonsEl", "monthEl", "yearEl"],
    renderTpl           : ['<div id="{id}-bodyEl" class="{baseCls}-body">', '<div id="{id}-monthEl" class="{baseCls}-months">', '<tpl for="months">', '<div class="{parent.baseCls}-item {parent.baseCls}-month">', '<a style="{parent.monthStyle}" hidefocus="on" class="{parent.baseCls}-item-inner" href="#">{.}</a>', "</div>", "</tpl>", "</div>", '<div id="{id}-yearEl" class="{baseCls}-years">', '<div class="{baseCls}-yearnav">', '<div class="{baseCls}-yearnav-button-ct">', '<a id="{id}-prevEl" class="{baseCls}-yearnav-button {baseCls}-yearnav-prev" href="#" hidefocus="on" ></a>', "</div>", '<div class="{baseCls}-yearnav-button-ct">', '<a id="{id}-nextEl" class="{baseCls}-yearnav-button {baseCls}-yearnav-next" href="#" hidefocus="on" ></a>', "</div>", "</div>", '<tpl for="years">', '<div class="{parent.baseCls}-item {parent.baseCls}-year">', '<a hidefocus="on" class="{parent.baseCls}-item-inner" href="#">{.}</a>', "</div>", "</tpl>", "</div>", '<div class="' + Ext.baseCSSPrefix + 'clear"></div>', "</div>", '<tpl if="showButtons">', '<div id="{id}-buttonsEl" class="{baseCls}-buttons">{%', "var me=values.$comp, okBtn=me.okBtn, cancelBtn=me.cancelBtn;", "okBtn.ownerLayout = cancelBtn.ownerLayout = me.componentLayout;", "okBtn.ownerCt = cancelBtn.ownerCt = me;", "Ext.DomHelper.generateMarkup(okBtn.getRenderTree(), out);", "Ext.DomHelper.generateMarkup(cancelBtn.getRenderTree(), out);", "%}</div>", "</tpl>"],
    okText              : "OK",
    cancelText          : "Cancel",
    baseCls             : Ext.baseCSSPrefix + "monthpicker",
    showButtons         : true,
    measureWidth        : 35,
    measureMaxHeight    : 20,
    smallCls            : Ext.baseCSSPrefix + "monthpicker-small",
    totalYears          : 10,
    yearOffset          : 5,
    monthOffset         : 6,
    initComponent       : function() {
        var a         = this;
        a.selectedCls = a.baseCls + "-selected";
        a.addEvents("cancelclick", "monthclick", "monthdblclick", "okclick", "select", "yearclick", "yeardblclick");
        if (a.small) {
            a.addCls(a.smallCls)
        }
        a.setValue(a.value);
        a.activeYear = a.getYear(new Date().getFullYear() - 4, -4);
        if (a.showButtons) {
            a.okBtn     = new Ext.button.Button({
                text   : a.okText,
                handler: a.onOkClick,
                scope  : a
            });
            a.cancelBtn = new Ext.button.Button({
                text   : a.cancelText,
                handler: a.onCancelClick,
                scope  : a
            })
        }
        this.callParent()
    },
    beforeRender        : function() {
        var f = this, c = 0, b = [], a = Ext.Date.getShortMonthName, e = f.monthOffset, g = f.monthMargin, d = "";
        f.callParent();
        for (; c < e; ++c) {
            b.push(a(c), a(c + e))
        }
        if (Ext.isDefined(g)) {
            d = "margin: 0 " + g + "px;"
        }
        Ext.apply(f.renderData, {
            months     : b,
            years      : f.getYears(),
            showButtons: f.showButtons,
            monthStyle : d
        })
    },
    afterRender         : function() {
        var b = this, a = b.bodyEl, c = b.buttonsEl;
        b.callParent();
        b.mon(a, "click", b.onBodyClick, b);
        b.mon(a, "dblclick", b.onBodyClick, b);
        b.years        = a.select("." + b.baseCls + "-year a");
        b.months       = a.select("." + b.baseCls + "-month a");
        b.backRepeater = new Ext.util.ClickRepeater(b.prevEl, {handler: Ext.Function.bind(b.adjustYear, b, [-b.totalYears])});
        b.prevEl.addClsOnOver(b.baseCls + "-yearnav-prev-over");
        b.nextRepeater = new Ext.util.ClickRepeater(b.nextEl, {handler: Ext.Function.bind(b.adjustYear, b, [b.totalYears])});
        b.nextEl.addClsOnOver(b.baseCls + "-yearnav-next-over");
        b.updateBody();
        if (!Ext.isDefined(b.monthMargin)) {
            Ext.picker.Month.prototype.monthMargin = b.calculateMonthMargin()
        }
    },
    calculateMonthMargin: function() {
        var d = this, b = d.monthEl, a = d.months, e = a.first(), c = e.getMargin("l");
        while (c && d.getLargest() > d.measureMaxHeight) {
            --c;
            a.setStyle("margin", "0 " + c + "px")
        }
        return c
    },
    getLargest          : function(a) {
        var b = 0;
        this.months.each(function(d) {
            var c = d.getHeight();
            if (c > b) {
                b = c
            }
        });
        return b
    },
    setValue            : function(d) {
        var c = this, e = c.activeYear, f = c.monthOffset, b, a;
        if (!d) {
            c.value = [null, null]
        } else {
            if (Ext.isDate(d)) {
                c.value = [d.getMonth(), d.getFullYear()]
            } else {
                c.value = [d[0], d[1]]
            }
        }
        if (c.rendered) {
            b = c.value[1];
            if (b !== null) {
                if ((b < e || b > e + c.yearOffset)) {
                    c.activeYear = b - c.yearOffset + 1
                }
            }
            c.updateBody()
        }
        return c
    },
    getValue            : function() {
        return this.value
    },
    hasSelection        : function() {
        var a = this.value;
        return a[0] !== null && a[1] !== null
    },
    getYears            : function() {
        var d = this, e = d.yearOffset, f = d.activeYear, a = f + e, c = f, b = [];
        for (; c < a; ++c) {
            b.push(c, c + e)
        }
        return b
    },
    updateBody          : function() {
        var h = this, e = h.years, b = h.months, l = h.getYears(), m = h.selectedCls, j = h.getYear(null), f = h.value[0], k = h.monthOffset, g, d, i, a, c;
        if (h.rendered) {
            e.removeCls(m);
            b.removeCls(m);
            d = e.elements;
            a = d.length;
            for (i = 0; i < a; i++) {
                c               = Ext.fly(d[i]);
                g               = l[i];
                c.dom.innerHTML = g;
                if (g == j) {
                    c.addCls(m)
                }
            }
            if (f !== null) {
                if (f < k) {
                    f = f * 2
                } else {
                    f = (f - k) * 2 + 1
                }
                b.item(f).addCls(m)
            }
        }
    },
    getYear             : function(a, c) {
        var b = this.value[1];
        c     = c || 0;
        return b === null ? a : b + c
    },
    onBodyClick         : function(d, b) {
        var c = this, a = d.type == "dblclick";
        if (d.getTarget("." + c.baseCls + "-month")) {
            d.stopEvent();
            c.onMonthClick(b, a)
        } else {
            if (d.getTarget("." + c.baseCls + "-year")) {
                d.stopEvent();
                c.onYearClick(b, a)
            }
        }
    },
    adjustYear          : function(a) {
        if (typeof a != "number") {
            a = this.totalYears
        }
        this.activeYear += a;
        this.updateBody()
    },
    onOkClick           : function() {
        this.fireEvent("okclick", this, this.value)
    },
    onCancelClick       : function() {
        this.fireEvent("cancelclick", this)
    },
    onMonthClick        : function(c, a) {
        var b      = this;
        b.value[0] = b.resolveOffset(b.months.indexOf(c), b.monthOffset);
        b.updateBody();
        b.fireEvent("month" + (a ? "dbl" : "") + "click", b, b.value);
        b.fireEvent("select", b, b.value)
    },
    onYearClick         : function(c, a) {
        var b      = this;
        b.value[1] = b.activeYear + b.resolveOffset(b.years.indexOf(c), b.yearOffset);
        b.updateBody();
        b.fireEvent("year" + (a ? "dbl" : "") + "click", b, b.value);
        b.fireEvent("select", b, b.value)
    },
    resolveOffset       : function(a, b) {
        if (a % 2 === 0) {
            return (a / 2)
        } else {
            return b + Math.floor(a / 2)
        }
    },
    beforeDestroy       : function() {
        var a   = this;
        a.years = a.months = null;
        Ext.destroyMembers(a, "backRepeater", "nextRepeater", "okBtn", "cancelBtn");
        a.callParent()
    },
    finishRenderChildren: function() {
        var a = this;
        this.callParent(arguments);
        if (this.showButtons) {
            a.okBtn.finishRender();
            a.cancelBtn.finishRender()
        }
    },
    onDestroy           : function() {
        Ext.destroyMembers(this, "okBtn", "cancelBtn");
        this.callParent()
    }
});
Ext.define("Ext.picker.Date", {
    extend              : "Ext.Component",
    requires            : ["Ext.XTemplate", "Ext.button.Button", "Ext.button.Split", "Ext.util.ClickRepeater", "Ext.util.KeyNav", "Ext.EventObject", "Ext.fx.Manager", "Ext.picker.Month"],
    alias               : "widget.datepicker",
    alternateClassName  : "Ext.DatePicker",
    childEls            : ["innerEl", "eventEl", "prevEl", "nextEl", "middleBtnEl", "footerEl"],
    border              : true,
    renderTpl           : ['<div id="{id}-innerEl" role="grid">', '<div role="presentation" class="{baseCls}-header">', '<a id="{id}-prevEl" class="{baseCls}-prev {baseCls}-arrow" href="#" role="button" title="{prevText}" hidefocus="on" ></a>', '<div class="{baseCls}-month" id="{id}-middleBtnEl">{%this.renderMonthBtn(values, out)%}</div>', '<a id="{id}-nextEl" class="{baseCls}-next {baseCls}-arrow" href="#" role="button" title="{nextText}" hidefocus="on" ></a>', "</div>", '<table id="{id}-eventEl" class="{baseCls}-inner" cellspacing="0" role="grid">', '<thead role="presentation"><tr role="row">', '<tpl for="dayNames">', '<th role="columnheader" class="{parent.baseCls}-column-header" title="{.}">', '<div class="{parent.baseCls}-column-header-inner">{.:this.firstInitial}</div>', "</th>", "</tpl>", "</tr></thead>", '<tbody role="presentation"><tr role="row">', '<tpl for="days">', "{#:this.isEndOfWeek}", '<td role="gridcell" id="{[Ext.id()]}">', '<a role="presentation" hidefocus="on" class="{parent.baseCls}-date" href="#"></a>', "</td>", "</tpl>", "</tr></tbody>", "</table>", '<tpl if="showToday">', '<div id="{id}-footerEl" role="presentation" class="{baseCls}-footer">{%this.renderTodayBtn(values, out)%}</div>', "</tpl>", "</div>", {
        firstInitial  : function(a) {
            return Ext.picker.Date.prototype.getDayInitial(a)
        },
        isEndOfWeek   : function(b) {
            b--;
            var a = b % 7 === 0 && b !== 0;
            return a ? '</tr><tr role="row">' : ""
        },
        renderTodayBtn: function(a, b) {
            Ext.DomHelper.generateMarkup(a.$comp.todayBtn.getRenderTree(), b)
        },
        renderMonthBtn: function(a, b) {
            Ext.DomHelper.generateMarkup(a.$comp.monthBtn.getRenderTree(), b)
        }
    }],
    todayText           : "Today",
    ariaTitle           : "Date Picker: {0}",
    ariaTitleDateFormat : "F d, Y",
    todayTip            : "{0} (Spacebar)",
    minText             : "This date is before the minimum date",
    maxText             : "This date is after the maximum date",
    disabledDaysText    : "Disabled",
    disabledDatesText   : "Disabled",
    nextText            : "Next Month (Control+Right)",
    prevText            : "Previous Month (Control+Left)",
    monthYearText       : "Choose a month (Control+Up/Down to move years)",
    monthYearFormat     : "F Y",
    startDay            : 0,
    showToday           : true,
    disableAnim         : false,
    baseCls             : Ext.baseCSSPrefix + "datepicker",
    longDayFormat       : "F d, Y",
    focusOnShow         : false,
    focusOnSelect       : true,
    initHour            : 12,
    numDays             : 42,
    initComponent       : function() {
        var b             = this, a = Ext.Date.clearTime;
        b.selectedCls     = b.baseCls + "-selected";
        b.disabledCellCls = b.baseCls + "-disabled";
        b.prevCls         = b.baseCls + "-prevday";
        b.activeCls       = b.baseCls + "-active";
        b.cellCls         = b.baseCls + "-cell";
        b.nextCls         = b.baseCls + "-prevday";
        b.todayCls        = b.baseCls + "-today";
        if (!b.format) {
            b.format = Ext.Date.defaultFormat
        }
        if (!b.dayNames) {
            b.dayNames = Ext.Date.dayNames
        }
        b.dayNames = b.dayNames.slice(b.startDay).concat(b.dayNames.slice(0, b.startDay));
        b.callParent();
        b.value = b.value ? a(b.value, true) : a(new Date());
        b.addEvents("select");
        b.initDisabledDays()
    },
    beforeRender        : function() {
        var b = this, c = new Array(b.numDays), a = Ext.Date.format(new Date(), b.format);
        if (b.up("menu")) {
            b.addCls(Ext.baseCSSPrefix + "menu")
        }
        b.monthBtn = new Ext.button.Split({
            ownerCt    : b,
            ownerLayout: b.getComponentLayout(),
            text       : "",
            tooltip    : b.monthYearText,
            listeners  : {
                click     : b.showMonthPicker,
                arrowclick: b.showMonthPicker,
                scope     : b
            }
        });
        if (b.showToday) {
            b.todayBtn = new Ext.button.Button({
                ownerCt    : b,
                ownerLayout: b.getComponentLayout(),
                text       : Ext.String.format(b.todayText, a),
                tooltip    : Ext.String.format(b.todayTip, a),
                tooltipType: "title",
                handler    : b.selectToday,
                scope      : b
            })
        }
        b.callParent();
        Ext.applyIf(b, {renderData: {}});
        Ext.apply(b.renderData, {
            dayNames : b.dayNames,
            showToday: b.showToday,
            prevText : b.prevText,
            nextText : b.nextText,
            days     : c
        });
        b.protoEl.unselectable()
    },
    finishRenderChildren: function() {
        var a = this;
        a.callParent();
        a.monthBtn.finishRender();
        if (a.showToday) {
            a.todayBtn.finishRender()
        }
    },
    onRender            : function(b, a) {
        var c = this;
        c.callParent(arguments);
        c.cells     = c.eventEl.select("tbody td");
        c.textNodes = c.eventEl.query("tbody td a");
        c.mon(c.eventEl, {
            scope     : c,
            mousewheel: c.handleMouseWheel,
            click     : {
                fn      : c.handleDateClick,
                delegate: "a." + c.baseCls + "-date"
            }
        })
    },
    initEvents          : function() {
        var c = this, a = Ext.Date, b = a.DAY;
        c.callParent();
        c.prevRepeater = new Ext.util.ClickRepeater(c.prevEl, {
            handler       : c.showPrevMonth,
            scope         : c,
            preventDefault: true,
            stopDefault   : true
        });
        c.nextRepeater = new Ext.util.ClickRepeater(c.nextEl, {
            handler       : c.showNextMonth,
            scope         : c,
            preventDefault: true,
            stopDefault   : true
        });
        c.keyNav       = new Ext.util.KeyNav(c.eventEl, Ext.apply({
            scope   : c,
            left    : function(d) {
                if (d.ctrlKey) {
                    c.showPrevMonth()
                } else {
                    c.update(a.add(c.activeDate, b, -1))
                }
            },
            right   : function(d) {
                if (d.ctrlKey) {
                    c.showNextMonth()
                } else {
                    c.update(a.add(c.activeDate, b, 1))
                }
            },
            up      : function(d) {
                if (d.ctrlKey) {
                    c.showNextYear()
                } else {
                    c.update(a.add(c.activeDate, b, -7))
                }
            },
            down    : function(d) {
                if (d.ctrlKey) {
                    c.showPrevYear()
                } else {
                    c.update(a.add(c.activeDate, b, 7))
                }
            },
            pageUp  : function(d) {
                if (d.altKey) {
                    c.showPrevYear()
                } else {
                    c.showPrevMonth()
                }
            },
            pageDown: function(d) {
                if (d.altKey) {
                    c.showNextYear()
                } else {
                    c.showNextMonth()
                }
            },
            tab     : function(d) {
                c.doCancelFieldFocus = true;
                c.handleTabClick(d);
                delete c.doCancelFieldFocus;
                return true
            },
            enter   : function(d) {
                d.stopPropagation();
                return true
            },
            home    : function(d) {
                c.update(a.getFirstDateOfMonth(c.activeDate))
            },
            end     : function(d) {
                c.update(a.getLastDateOfMonth(c.activeDate))
            }
        }, c.keyNavConfig));
        if (c.showToday) {
            c.todayKeyListener = c.eventEl.addKeyListener(Ext.EventObject.SPACE, c.selectToday, c)
        }
        c.update(c.value)
    },
    handleTabClick      : function(d) {
        var c = this, a = c.getSelectedDate(c.activeDate), b = c.handler;
        if (!c.disabled && a.dateValue && !Ext.fly(a.parentNode).hasCls(c.disabledCellCls)) {
            c.doCancelFocus = c.focusOnSelect === false;
            c.setValue(new Date(a.dateValue));
            delete c.doCancelFocus;
            c.fireEvent("select", c, c.value);
            if (b) {
                b.call(c.scope || c, c, c.value)
            }
            c.onSelect()
        }
    },
    getSelectedDate     : function(a) {
        var d = this, h = a.getTime(), i = d.cells, j = d.selectedCls, f = i.elements, b, e = f.length, g;
        i.removeCls(j);
        for (b = 0; b < e; b++) {
            g = Ext.fly(f[b]);
            if (g.dom.firstChild.dateValue == h) {
                return g.dom.firstChild
            }
        }
        return null
    },
    initDisabledDays    : function() {
        var g = this, b = g.disabledDates, f = "(?:", a, h, c, e;
        if (!g.disabledDatesRE && b) {
            a = b.length - 1;
            c = b.length;
            for (h = 0; h < c; h++) {
                e = b[h];
                f += Ext.isDate(e) ? "^" + Ext.String.escapeRegex(Ext.Date.dateFormat(e, g.format)) + "$" : e;
                if (h != a) {
                    f += "|"
                }
            }
            g.disabledDatesRE = new RegExp(f + ")")
        }
    },
    setDisabledDates    : function(a) {
        var b = this;
        if (Ext.isArray(a)) {
            b.disabledDates   = a;
            b.disabledDatesRE = null
        } else {
            b.disabledDatesRE = a
        }
        b.initDisabledDays();
        b.update(b.value, true);
        return b
    },
    setDisabledDays     : function(a) {
        this.disabledDays = a;
        return this.update(this.value, true)
    },
    setMinDate          : function(a) {
        this.minDate = a;
        return this.update(this.value, true)
    },
    setMaxDate          : function(a) {
        this.maxDate = a;
        return this.update(this.value, true)
    },
    setValue            : function(a) {
        this.value = Ext.Date.clearTime(a, true);
        return this.update(this.value)
    },
    getValue            : function() {
        return this.value
    },
    getDayInitial       : function(a) {
        return a.substr(0, 1)
    },
    focus               : function() {
        this.update(this.activeDate)
    },
    onEnable            : function() {
        this.callParent();
        this.setDisabledStatus(false);
        this.update(this.activeDate)
    },
    onDisable           : function() {
        this.callParent();
        this.setDisabledStatus(true)
    },
    setDisabledStatus   : function(a) {
        var b = this;
        b.keyNav.setDisabled(a);
        b.prevRepeater.setDisabled(a);
        b.nextRepeater.setDisabled(a);
        if (b.showToday) {
            b.todayKeyListener.setDisabled(a);
            b.todayBtn.setDisabled(a)
        }
    },
    getActive           : function() {
        return this.activeDate || this.value
    },
    runAnimation        : function(c) {
        var b = this.monthPicker, a = {
            duration: 200,
            callback: function() {
                if (c) {
                    b.hide()
                } else {
                    b.show()
                }
            }
        };
        if (c) {
            b.el.slideOut("t", a)
        } else {
            b.el.slideIn("t", a)
        }
    },
    hideMonthPicker     : function(a) {
        var c = this, b = c.monthPicker;
        if (b) {
            if (c.shouldAnimate(a)) {
                c.runAnimation(true)
            } else {
                b.hide()
            }
        }
        return c
    },
    showMonthPicker     : function(a) {
        var c = this, b;
        if (c.rendered && !c.disabled) {
            b = c.createMonthPicker();
            b.setValue(c.getActive());
            b.setSize(c.getSize());
            b.setPosition(-1, -1);
            if (c.shouldAnimate(a)) {
                c.runAnimation(false)
            } else {
                b.show()
            }
        }
        return c
    },
    shouldAnimate       : function(a) {
        return Ext.isDefined(a) ? a : !this.disableAnim
    },
    createMonthPicker   : function() {
        var b = this, a = b.monthPicker;
        if (!a) {
            b.monthPicker = a = new Ext.picker.Month({
                renderTo : b.el,
                floating : true,
                shadow   : false,
                small    : b.showToday === false,
                listeners: {
                    scope        : b,
                    cancelclick  : b.onCancelClick,
                    okclick      : b.onOkClick,
                    yeardblclick : b.onOkClick,
                    monthdblclick: b.onOkClick
                }
            });
            if (!b.disableAnim) {
                a.el.setStyle("display", "none")
            }
            b.on("beforehide", Ext.Function.bind(b.hideMonthPicker, b, [false]))
        }
        return a
    },
    onOkClick           : function(b, e) {
        var d = this, f = e[0], c = e[1], a = new Date(c, f, d.getActive().getDate());
        if (a.getMonth() !== f) {
            a = Ext.Date.getLastDateOfMonth(new Date(c, f, 1))
        }
        d.setValue(a);
        d.hideMonthPicker()
    },
    onCancelClick       : function() {
        this.selectedUpdate(this.activeDate);
        this.hideMonthPicker()
    },
    showPrevMonth       : function(a) {
        return this.setValue(Ext.Date.add(this.activeDate, Ext.Date.MONTH, -1))
    },
    showNextMonth       : function(a) {
        return this.setValue(Ext.Date.add(this.activeDate, Ext.Date.MONTH, 1))
    },
    showPrevYear        : function() {
        return this.setValue(Ext.Date.add(this.activeDate, Ext.Date.YEAR, -1))
    },
    showNextYear        : function() {
        return this.setValue(Ext.Date.add(this.activeDate, Ext.Date.YEAR, 1))
    },
    handleMouseWheel    : function(a) {
        a.stopEvent();
        if (!this.disabled) {
            var b = a.getWheelDelta();
            if (b > 0) {
                this.showPrevMonth()
            } else {
                if (b < 0) {
                    this.showNextMonth()
                }
            }
        }
    },
    handleDateClick     : function(d, a) {
        var c = this, b = c.handler;
        d.stopEvent();
        if (!c.disabled && a.dateValue && !Ext.fly(a.parentNode).hasCls(c.disabledCellCls)) {
            c.doCancelFocus = c.focusOnSelect === false;
            c.setValue(new Date(a.dateValue));
            delete c.doCancelFocus;
            c.fireEvent("select", c, c.value);
            if (b) {
                b.call(c.scope || c, c, c.value)
            }
            c.onSelect()
        }
    },
    onSelect            : function() {
        if (this.hideOnSelect) {
            this.hide()
        }
    },
    selectToday         : function() {
        var c = this, a = c.todayBtn, b = c.handler;
        if (a && !a.disabled) {
            c.setValue(Ext.Date.clearTime(new Date()));
            c.fireEvent("select", c, c.value);
            if (b) {
                b.call(c.scope || c, c, c.value)
            }
            c.onSelect()
        }
        return c
    },
    selectedUpdate      : function(a) {
        var d = this, h = a.getTime(), i = d.cells, j = d.selectedCls, f = i.elements, b, e = f.length, g;
        i.removeCls(j);
        for (b = 0; b < e; b++) {
            g = Ext.fly(f[b]);
            if (g.dom.firstChild.dateValue == h) {
                d.fireEvent("highlightitem", d, g);
                g.addCls(j);
                if (d.isVisible() && !d.doCancelFocus) {
                    Ext.fly(g.dom.firstChild).focus(50)
                }
                break
            }
        }
    },
    fullUpdate          : function(z) {
        var D = this, f = D.cells.elements, d = D.textNodes, F = D.disabledCellCls, n = Ext.Date, v = 0, C = 0, e = D.isVisible(), l = +n.clearTime(z, true), y = +n.clearTime(new Date()), t = D.minDate ? n.clearTime(D.minDate, true) : Number.NEGATIVE_INFINITY, u = D.maxDate ? n.clearTime(D.maxDate, true) : Number.POSITIVE_INFINITY, B = D.disabledDatesRE, s = D.disabledDatesText, G = D.disabledDays ? D.disabledDays.join("") : false, A = D.disabledDaysText, w = D.format, k = n.getDaysInMonth(z), p = n.getFirstDateOfMonth(z), g = p.getDay() - D.startDay, x = n.add(z, n.MONTH, -1), b = D.longDayFormat, j, q, a, E, m, o, c, h, r;
        if (g < 0) {
            g += 7
        }
        k += g;
        j = n.getDaysInMonth(x) - g;
        q = new Date(x.getFullYear(), x.getMonth(), j, D.initHour);
        if (D.showToday) {
            E = n.clearTime(new Date());
            a = (E < t || E > u || (B && w && B.test(n.dateFormat(E, w))) || (G && G.indexOf(E.getDay()) != -1));
            if (!D.disabled) {
                D.todayBtn.setDisabled(a);
                D.todayKeyListener.setDisabled(a)
            }
        }
        m = function(i, H) {
            r                      = +n.clearTime(q, true);
            i.title                = n.format(q, b);
            i.firstChild.dateValue = r;
            if (r == y) {
                H += " " + D.todayCls;
                i.title       = D.todayText;
                D.todayElSpan = Ext.DomHelper.append(i.firstChild, {
                    tag : "span",
                    cls : Ext.baseCSSPrefix + "hide-clip",
                    html: D.todayText
                }, true)
            }
            if (r == l) {
                H += " " + D.selectedCls;
                D.fireEvent("highlightitem", D, i);
                if (e && D.floating) {
                    Ext.fly(i.firstChild).focus(50)
                }
            }
            if (r < t) {
                H += " " + F;
                i.title = D.minText
            } else {
                if (r > u) {
                    H += " " + F;
                    i.title = D.maxText
                } else {
                    if (G && G.indexOf(q.getDay()) !== -1) {
                        i.title = A;
                        H += " " + F
                    } else {
                        if (B && w) {
                            h = n.dateFormat(q, w);
                            if (B.test(h)) {
                                i.title = s.replace("%0", h);
                                H += " " + F
                            }
                        }
                    }
                }
            }
            i.className = H + " " + D.cellCls
        };
        for (; v < D.numDays; ++v) {
            if (v < g) {
                o = (++j);
                c = D.prevCls
            } else {
                if (v >= k) {
                    o = (++C);
                    c = D.nextCls
                } else {
                    o = v - g + 1;
                    c = D.activeCls
                }
            }
            d[v].innerHTML = o;
            q.setDate(q.getDate() + 1);
            m(f[v], c)
        }
        D.monthBtn.setText(Ext.Date.format(z, D.monthYearFormat))
    },
    update              : function(a, d) {
        var b = this, c = b.activeDate;
        if (b.rendered) {
            b.activeDate = a;
            if (!d && c && b.el && c.getMonth() == a.getMonth() && c.getFullYear() == a.getFullYear()) {
                b.selectedUpdate(a, c)
            } else {
                b.fullUpdate(a, c)
            }
        }
        return b
    },
    beforeDestroy       : function() {
        var a = this;
        if (a.rendered) {
            Ext.destroy(a.todayKeyListener, a.keyNav, a.monthPicker, a.monthBtn, a.nextRepeater, a.prevRepeater, a.todayBtn);
            delete a.textNodes;
            delete a.cells.elements
        }
        a.callParent()
    },
    onShow              : function() {
        this.callParent(arguments);
        if (this.focusOnShow) {
            this.focus()
        }
    }
});
Ext.define("Ext.form.field.Date", {
    extend            : "Ext.form.field.Picker",
    alias             : "widget.datefield",
    requires          : ["Ext.picker.Date"],
    alternateClassName: ["Ext.form.DateField", "Ext.form.Date"],
    format            : "m/d/Y",
    altFormats        : "m/d/Y|n/j/Y|n/j/y|m/j/y|n/d/y|m/j/Y|n/d/Y|m-d-y|m-d-Y|m/d|m-d|md|mdy|mdY|d|Y-m-d|n-j|n/j",
    disabledDaysText  : "Disabled",
    disabledDatesText : "Disabled",
    minText           : "The date in this field must be equal to or after {0}",
    maxText           : "The date in this field must be equal to or before {0}",
    invalidText       : "{0} is not a valid date - it must be in the format {1}",
    triggerCls        : Ext.baseCSSPrefix + "form-date-trigger",
    showToday         : true,
    useStrict         : undefined,
    initTime          : "12",
    initTimeFormat    : "H",
    matchFieldWidth   : false,
    startDay          : 0,
    initComponent     : function() {
        var d = this, b = Ext.isString, c, a;
        c     = d.minValue;
        a     = d.maxValue;
        if (b(c)) {
            d.minValue = d.parseDate(c)
        }
        if (b(a)) {
            d.maxValue = d.parseDate(a)
        }
        d.disabledDatesRE = null;
        d.initDisabledDays();
        d.callParent()
    },
    initValue         : function() {
        var a = this, b = a.value;
        if (Ext.isString(b)) {
            a.value = a.rawToValue(b)
        }
        a.callParent()
    },
    initDisabledDays  : function() {
        if (this.disabledDates) {
            var b = this.disabledDates, a = b.length - 1, f = "(?:", g, e = b.length, c;
            for (g = 0; g < e; g++) {
                c = b[g];
                f += Ext.isDate(c) ? "^" + Ext.String.escapeRegex(c.dateFormat(this.format)) + "$" : c;
                if (g !== a) {
                    f += "|"
                }
            }
            this.disabledDatesRE = new RegExp(f + ")")
        }
    },
    setDisabledDates  : function(a) {
        var c           = this, b = c.picker;
        c.disabledDates = a;
        c.initDisabledDays();
        if (b) {
            b.setDisabledDates(c.disabledDatesRE)
        }
    },
    setDisabledDays   : function(a) {
        var b             = this.picker;
        this.disabledDays = a;
        if (b) {
            b.setDisabledDays(a)
        }
    },
    setMinValue       : function(c) {
        var b      = this, a = b.picker, d = (Ext.isString(c) ? b.parseDate(c) : c);
        b.minValue = d;
        if (a) {
            a.minText = Ext.String.format(b.minText, b.formatDate(b.minValue));
            a.setMinDate(d)
        }
    },
    setMaxValue       : function(c) {
        var b      = this, a = b.picker, d = (Ext.isString(c) ? b.parseDate(c) : c);
        b.maxValue = d;
        if (a) {
            a.maxText = Ext.String.format(b.maxText, b.formatDate(b.maxValue));
            a.setMaxDate(d)
        }
    },
    getErrors         : function(p) {
        var h = this, o = Ext.String.format, j = Ext.Date.clearTime, n = h.callParent(arguments), m = h.disabledDays, d = h.disabledDatesRE, l = h.minValue, g = h.maxValue, f = m ? m.length : 0, e = 0, a, b, k, c;
        p     = h.formatDate(p || h.processRawValue(h.getRawValue()));
        if (p === null || p.length < 1) {
            return n
        }
        a = p;
        p = h.parseDate(p);
        if (!p) {
            n.push(o(h.invalidText, a, Ext.Date.unescapeFormat(h.format)));
            return n
        }
        c = p.getTime();
        if (l && c < j(l).getTime()) {
            n.push(o(h.minText, h.formatDate(l)))
        }
        if (g && c > j(g).getTime()) {
            n.push(o(h.maxText, h.formatDate(g)))
        }
        if (m) {
            k = p.getDay();
            for (; e < f; e++) {
                if (k === m[e]) {
                    n.push(h.disabledDaysText);
                    break
                }
            }
        }
        b = h.formatDate(p);
        if (d && d.test(b)) {
            n.push(o(h.disabledDatesText, b))
        }
        return n
    },
    rawToValue        : function(a) {
        return this.parseDate(a) || a || null
    },
    valueToRaw        : function(a) {
        return this.formatDate(this.parseDate(a))
    },
    safeParse         : function(f, g) {
        var e = this, c = Ext.Date, a = null, b = e.useStrict, d;
        if (c.formatContainsHourInfo(g)) {
            a = c.parse(f, g, b)
        } else {
            d = c.parse(f + " " + e.initTime, g + " " + e.initTimeFormat, b);
            if (d) {
                a = c.clearTime(d)
            }
        }
        return a
    },
    getSubmitValue    : function() {
        var b = this.submitFormat || this.format, a = this.getValue();
        return a ? Ext.Date.format(a, b) : ""
    },
    parseDate         : function(e) {
        if (!e || Ext.isDate(e)) {
            return e
        }
        var d = this, g = d.safeParse(e, d.format), b = d.altFormats, f = d.altFormatsArray, c = 0, a;
        if (!g && b) {
            f = f || b.split("|");
            a = f.length;
            for (; c < a && !g; ++c) {
                g = d.safeParse(e, f[c])
            }
        }
        return g
    },
    formatDate        : function(a) {
        return Ext.isDate(a) ? Ext.Date.dateFormat(a, this.format) : a
    },
    createPicker      : function() {
        var a = this, b = Ext.String.format;
        return new Ext.picker.Date({
            pickerField      : a,
            ownerCt          : a.ownerCt,
            renderTo         : document.body,
            floating         : true,
            hidden           : true,
            focusOnShow      : true,
            minDate          : a.minValue,
            maxDate          : a.maxValue,
            disabledDatesRE  : a.disabledDatesRE,
            disabledDatesText: a.disabledDatesText,
            disabledDays     : a.disabledDays,
            disabledDaysText : a.disabledDaysText,
            format           : a.format,
            showToday        : a.showToday,
            startDay         : a.startDay,
            minText          : b(a.minText, a.formatDate(a.minValue)),
            maxText          : b(a.maxText, a.formatDate(a.maxValue)),
            listeners        : {
                scope : a,
                select: a.onSelect
            },
            keyNavConfig     : {
                esc: function() {
                    a.collapse()
                }
            }
        })
    },
    onDownArrow       : function(a) {
        this.callParent(arguments);
        if (this.isExpanded) {
            this.getPicker().focus()
        }
    },
    onSelect          : function(a, c) {
        var b = this;
        b.setValue(c);
        b.fireEvent("select", b, c);
        b.collapse()
    },
    onExpand          : function() {
        var a = this.getValue();
        this.picker.setValue(Ext.isDate(a) ? a : new Date())
    },
    onCollapse        : function() {
        this.focus(false, 60)
    },
    beforeBlur        : function() {
        var c = this, a = c.parseDate(c.getRawValue()), b = c.focusTask;
        if (b) {
            b.cancel()
        }
        if (a) {
            c.setValue(a)
        }
    }
});
Ext.define("ExtThemeNeptune.picker.Month", {
    override        : "Ext.picker.Month",
    measureMaxHeight: 36
});
Ext.define("Ext.form.field.FileButton", {
    extend         : "Ext.button.Button",
    alias          : "widget.filebutton",
    childEls       : ["btnEl", "btnWrap", "btnInnerEl", "btnIconEl", "fileInputEl"],
    inputCls       : Ext.baseCSSPrefix + "form-file-input",
    cls            : Ext.baseCSSPrefix + "form-file-btn",
    preventDefault : false,
    renderTpl      : ['<span id="{id}-btnWrap" class="{baseCls}-wrap', '<tpl if="splitCls"> {splitCls}</tpl>', '{childElCls}" unselectable="on">', '<span id="{id}-btnEl" class="{baseCls}-button">', '<span id="{id}-btnInnerEl" class="{baseCls}-inner {innerCls}', '{childElCls}" unselectable="on">', "{text}", "</span>", '<span role="img" id="{id}-btnIconEl" class="{baseCls}-icon-el {iconCls}', '{childElCls} {glyphCls}" unselectable="on" style="', '<tpl if="iconUrl">background-image:url({iconUrl});</tpl>', '<tpl if="glyph && glyphFontFamily">font-family:{glyphFontFamily};</tpl>">', '<tpl if="glyph">&#{glyph};</tpl><tpl if="iconCls || iconUrl">&#160;</tpl>', "</span>", "</span>", "</span>", '<input id="{id}-fileInputEl" class="{childElCls} {inputCls}" type="file" size="1" name="{inputName}">'],
    getTemplateArgs: function() {
        var a       = this.callParent();
        a.inputCls  = this.inputCls;
        a.inputName = this.inputName;
        return a
    },
    afterRender    : function() {
        var a = this;
        a.callParent(arguments);
        a.fileInputEl.on("change", a.fireChange, a)
    },
    fireChange     : function(a) {
        this.fireEvent("change", this, a, this.fileInputEl.dom.value)
    },
    createFileInput: function(a) {
        var b         = this;
        b.fileInputEl = b.el.createChild({
            name: b.inputName,
            id  : !a ? b.id + "-fileInputEl" : undefined,
            cls : b.inputCls,
            tag : "input",
            type: "file",
            size: 1
        });
        b.fileInputEl.on("change", b.fireChange, b)
    },
    reset          : function(a) {
        if (a) {
            this.fileInputEl.remove()
        }
        this.createFileInput(!a)
    },
    restoreInput   : function(a) {
        this.fileInputEl.remove();
        a = Ext.get(a);
        this.el.appendChild(a);
        this.fileInputEl = a
    },
    onDisable      : function() {
        this.callParent();
        this.fileInputEl.dom.disabled = true
    },
    onEnable       : function() {
        this.callParent();
        this.fileInputEl.dom.disabled = false
    }
});
Ext.define("Ext.form.field.File", {
    extend             : "Ext.form.field.Trigger",
    alias              : ["widget.filefield", "widget.fileuploadfield"],
    alternateClassName : ["Ext.form.FileUploadField", "Ext.ux.form.FileUploadField", "Ext.form.File"],
    requires           : ["Ext.form.field.FileButton"],
    buttonText         : "Browse...",
    buttonOnly         : false,
    buttonMargin       : 3,
    clearOnSubmit      : true,
    extraFieldBodyCls  : Ext.baseCSSPrefix + "form-file-wrap",
    readOnly           : true,
    triggerNoEditCls   : "",
    componentLayout    : "triggerfield",
    childEls           : ["browseButtonWrap"],
    onRender           : function() {
        var a = this, c = a.id, b;
        a.callParent(arguments);
        b             = a.inputEl;
        b.dom.name    = "";
        a.button      = new Ext.form.field.FileButton(Ext.apply({
            renderTo   : c + "-browseButtonWrap",
            ownerCt    : a,
            ownerLayout: a.componentLayout,
            id         : c + "-button",
            ui         : a.ui,
            disabled   : a.disabled,
            text       : a.buttonText,
            style      : a.buttonOnly ? "" : a.getButtonMarginProp() + a.buttonMargin + "px",
            inputName  : a.getName(),
            listeners  : {
                scope : a,
                change: a.onFileChange
            }
        }, a.buttonConfig));
        a.fileInputEl = a.button.fileInputEl;
        if (a.buttonOnly) {
            a.inputCell.setDisplayed(false)
        }
        a.browseButtonWrap.dom.style.width = (a.browseButtonWrap.dom.lastChild.offsetWidth + a.button.getEl().getMargin("lr")) + "px";
        if (Ext.isIE) {
            a.button.getEl().repaint()
        }
    },
    getTriggerMarkup   : function() {
        return '<td id="' + this.id + '-browseButtonWrap"></td>'
    },
    onFileChange       : function(a, c, b) {
        this.lastValue = null;
        Ext.form.field.File.superclass.setValue.call(this, b)
    },
    setValue           : Ext.emptyFn,
    reset              : function() {
        var b = this, a = b.clearOnSubmit;
        if (b.rendered) {
            b.button.reset(a);
            b.fileInputEl = b.button.fileInputEl;
            if (a) {
                b.inputEl.dom.value = ""
            }
        }
        b.callParent()
    },
    onShow             : function() {
        this.callParent();
        this.button.updateLayout()
    },
    onDisable          : function() {
        this.callParent();
        this.button.disable()
    },
    onEnable           : function() {
        this.callParent();
        this.button.enable()
    },
    isFileUpload       : function() {
        return true
    },
    extractFileInput   : function() {
        var a = this.button.fileInputEl.dom;
        this.reset();
        return a
    },
    restoreInput       : function(b) {
        var a = this.button;
        a.restoreInput(b);
        this.fileInputEl = a.fileInputEl
    },
    onDestroy          : function() {
        Ext.destroyMembers(this, "button");
        delete this.fileInputEl;
        this.callParent()
    },
    getButtonMarginProp: function() {
        return "margin-left:"
    }
});
Ext.define("Ext.picker.Color", {
    extend            : "Ext.Component",
    requires          : "Ext.XTemplate",
    alias             : "widget.colorpicker",
    alternateClassName: "Ext.ColorPalette",
    componentCls      : Ext.baseCSSPrefix + "color-picker",
    selectedCls       : Ext.baseCSSPrefix + "color-picker-selected",
    itemCls           : Ext.baseCSSPrefix + "color-picker-item",
    value             : null,
    clickEvent        : "click",
    allowReselect     : false,
    colors            : ["000000", "993300", "333300", "003300", "003366", "000080", "333399", "333333", "800000", "FF6600", "808000", "008000", "008080", "0000FF", "666699", "808080", "FF0000", "FF9900", "99CC00", "339966", "33CCCC", "3366FF", "800080", "969696", "FF00FF", "FFCC00", "FFFF00", "00FF00", "00FFFF", "00CCFF", "993366", "C0C0C0", "FF99CC", "FFCC99", "FFFF99", "CCFFCC", "CCFFFF", "99CCFF", "CC99FF", "FFFFFF"],
    colorRe           : /(?:^|\s)color-(.{6})(?:\s|$)/,
    renderTpl         : ['<tpl for="colors">', '<a href="#" class="color-{.} {parent.itemCls}" hidefocus="on">', '<span class="{parent.itemCls}-inner" style="background:#{.}">&#160;</span>', "</a>", "</tpl>"],
    initComponent     : function() {
        var a = this;
        a.callParent(arguments);
        a.addEvents("select");
        if (a.handler) {
            a.on("select", a.handler, a.scope, true)
        }
    },
    initRenderData    : function() {
        var a = this;
        return Ext.apply(a.callParent(), {
            itemCls: a.itemCls,
            colors : a.colors
        })
    },
    onRender          : function() {
        var b = this, a = b.clickEvent;
        b.callParent(arguments);
        b.mon(b.el, a, b.handleClick, b, {delegate: "a"});
        if (a != "click") {
            b.mon(b.el, "click", Ext.emptyFn, b, {
                delegate : "a",
                stopEvent: true
            })
        }
    },
    afterRender       : function() {
        var a = this, b;
        a.callParent(arguments);
        if (a.value) {
            b       = a.value;
            a.value = null;
            a.select(b, true)
        }
    },
    handleClick       : function(c, d) {
        var b = this, a;
        c.stopEvent();
        if (!b.disabled) {
            a = d.className.match(b.colorRe)[1];
            b.select(a.toUpperCase())
        }
    },
    select            : function(b, a) {
        var d = this, f = d.selectedCls, e = d.value, c;
        b     = b.replace("#", "");
        if (!d.rendered) {
            d.value = b;
            return
        }
        if (b != e || d.allowReselect) {
            c = d.el;
            if (d.value) {
                c.down("a.color-" + e).removeCls(f)
            }
            c.down("a.color-" + b).addCls(f);
            d.value = b;
            if (a !== true) {
                d.fireEvent("select", d, b)
            }
        }
    },
    clear             : function() {
        var b = this, c = b.value, a;
        if (c && b.rendered) {
            a = b.el.down("a.color-" + c);
            a.removeCls(b.selectedCls)
        }
        b.value = null
    },
    getValue          : function() {
        return this.value || null
    }
});
Ext.define("Ext.layout.component.field.HtmlEditor", {
    extend            : "Ext.layout.component.field.FieldContainer",
    alias             : ["layout.htmleditor"],
    type              : "htmleditor",
    naturalHeight     : 150,
    naturalWidth      : 300,
    beginLayout       : function(b) {
        var a = this.owner, c;
        if (Ext.isGecko) {
            c              = a.textareaEl.dom;
            this.lastValue = c.value;
            c.value        = ""
        }
        this.callParent(arguments);
        b.toolbarContext  = b.context.getCmp(a.toolbar);
        b.inputCmpContext = b.context.getCmp(a.inputCmp);
        b.textAreaContext = b.getEl("textareaEl");
        b.iframeContext   = b.getEl("iframeEl")
    },
    beginLayoutCycle  : function(g) {
        var f = this, c = g.widthModel, b = g.heightModel, a = f.owner, e = a.iframeEl, d = a.textareaEl;
        f.callParent(arguments);
        if (c.shrinkWrap) {
            e.setStyle("width", "");
            d.setStyle("width", "")
        } else {
            if (c.natural) {
                g.bodyCellContext.setWidth(f.naturalWidth)
            }
        }
        if (b.natural || b.shrinkWrap) {
            e.setHeight(f.naturalHeight);
            d.setHeight(f.naturalHeight)
        }
    },
    finishedLayout    : function() {
        var a = this.owner;
        this.callParent(arguments);
        if (Ext.isIE9m && Ext.isIEQuirks) {
            a.el.repaint()
        }
        if (Ext.isGecko) {
            a.textareaEl.dom.value = this.lastValue
        }
    },
    publishOwnerWidth : function(b, a) {
        this.callParent(arguments);
        a -= b.inputCmpContext.getBorderInfo().width;
        b.textAreaContext.setWidth(a);
        b.iframeContext.setWidth(a)
    },
    publishInnerWidth : function(e, c) {
        var b = e.inputCmpContext.getBorderInfo().width, d = Ext.isStrict && Ext.isIE8m, a = e.widthModel.natural;
        this.callParent(arguments);
        c = e.bodyCellContext.props.width - b;
        if (a) {
            if (d) {
                c -= 2
            }
            e.textAreaContext.setWidth(c);
            e.iframeContext.setWidth(c)
        } else {
            if (d) {
                e.textAreaContext.setWidth(c)
            }
        }
    },
    publishInnerHeight: function(c, a) {
        var d = c.toolbarContext.getProp("height"), b = this.owner.sourceEditMode;
        this.callParent(arguments);
        a = c.bodyCellContext.props.height;
        if (d !== undefined) {
            a -= d + c.inputCmpContext.getFrameInfo().height;
            if (Ext.isIE8 && Ext.isStrict) {
                a -= 2
            } else {
                if (Ext.isIEQuirks && (Ext.isIE8 || Ext.isIE9)) {
                    a -= 4
                }
            }
            c.iframeContext.setHeight(a);
            c.textAreaContext.setHeight(a)
        } else {
            this.done = false
        }
    }
});
Ext.define("Ext.form.field.HtmlEditor", {
    extend             : "Ext.form.FieldContainer",
    mixins             : {field: "Ext.form.field.Field"},
    alias              : "widget.htmleditor",
    alternateClassName : "Ext.form.HtmlEditor",
    requires           : ["Ext.tip.QuickTipManager", "Ext.picker.Color", "Ext.layout.container.VBox", "Ext.toolbar.Item", "Ext.toolbar.Toolbar", "Ext.util.Format", "Ext.layout.component.field.HtmlEditor"],
    componentLayout    : "htmleditor",
    componentTpl       : ["{beforeTextAreaTpl}", '<textarea id="{id}-textareaEl" name="{name}" tabIndex="-1" {inputAttrTpl}', ' class="{textareaCls}" autocomplete="off">', "{[Ext.util.Format.htmlEncode(values.value)]}", "</textarea>", "{afterTextAreaTpl}", "{beforeIFrameTpl}", '<iframe id="{id}-iframeEl" name="{iframeName}" frameBorder="0" {iframeAttrTpl}', ' src="{iframeSrc}" class="{iframeCls}"></iframe>', "{afterIFrameTpl}", {disableFormats: true}],
    stretchInputElFixed: true,
    subTplInsertions   : ["beforeTextAreaTpl", "afterTextAreaTpl", "beforeIFrameTpl", "afterIFrameTpl", "iframeAttrTpl", "inputAttrTpl"],
    enableFormat       : true,
    enableFontSize     : true,
    enableColors       : true,
    enableAlignments   : true,
    enableLists        : true,
    enableSourceEdit   : true,
    enableLinks        : true,
    enableFont         : true,
    createLinkText     : "Please enter the URL for the link:",
    defaultLinkValue   : "http://",
    fontFamilies       : ["Arial", "Courier New", "Tahoma", "Times New Roman", "Verdana"],
    defaultValue       : (Ext.isOpera || Ext.isIE6) ? "&#160;" : "&#8203;",
    extraFieldBodyCls  : Ext.baseCSSPrefix + "html-editor-wrap",
    initialized        : false,
    activated          : false,
    sourceEditMode     : false,
    iframePad          : 3,
    hideMode           : "offsets",
    maskOnDisable      : true,
    containerElCls     : Ext.baseCSSPrefix + "html-editor-container",
    initComponent      : function() {
        var a = this;
        a.addEvents("initialize", "activate", "beforesync", "beforepush", "sync", "push", "editmodechange");
        a.items  = [a.createToolbar(), a.createInputCmp()];
        a.layout = {
            type : "vbox",
            align: "stretch"
        };
        a.callParent(arguments);
        a.initField()
    },
    createInputCmp     : function() {
        this.inputCmp = Ext.widget(this.getInputCmpCfg());
        return this.inputCmp
    },
    getInputCmpCfg     : function() {
        var a = this, c = a.id + "-inputCmp", b = {
            id         : c,
            name       : a.name,
            textareaCls: Ext.baseCSSPrefix + "hidden",
            value      : a.value,
            iframeName : Ext.id(),
            iframeSrc  : Ext.SSL_SECURE_URL,
            iframeCls  : Ext.baseCSSPrefix + "htmleditor-iframe"
        };
        a.getInsertionRenderData(b, a.subTplInsertions);
        return {
            flex    : 1,
            xtype   : "component",
            tpl     : a.getTpl("componentTpl"),
            childEls: ["iframeEl", "textareaEl"],
            id      : c,
            cls     : Ext.baseCSSPrefix + "html-editor-input",
            data    : b
        }
    },
    createToolbar      : function() {
        this.toolbar = Ext.widget(this.getToolbarCfg());
        return this.toolbar
    },
    getToolbarCfg      : function() {
        var g = this, b = [], e, a = Ext.quickTipsActive && Ext.tip.QuickTipManager.isEnabled(), d = Ext.baseCSSPrefix, h, f;

        function c(k, i, j) {
            return {
                itemId      : k,
                cls         : d + "btn-icon",
                iconCls     : d + "edit-" + k,
                enableToggle: i !== false,
                scope       : g,
                handler     : j || g.relayBtnCmd,
                clickEvent  : "mousedown",
                tooltip     : a ? g.buttonTips[k] || f : f,
                overflowText: g.buttonTips[k].title || f,
                tabIndex    : -1
            }
        }

        if (g.enableFont && !Ext.isSafari2) {
            h = Ext.widget("component", {
                itemId     : "fontSelect",
                renderTpl  : ['<select id="{id}-selectEl" class="' + d + 'font-select">', "</select>"],
                childEls   : ["selectEl"],
                afterRender: function() {
                    g.fontSelect = this.selectEl;
                    Ext.Component.prototype.afterRender.apply(this, arguments)
                },
                onDisable  : function() {
                    var i = this.selectEl;
                    if (i) {
                        i.dom.disabled = true
                    }
                    Ext.Component.prototype.onDisable.apply(this, arguments)
                },
                onEnable   : function() {
                    var i = this.selectEl;
                    if (i) {
                        i.dom.disabled = false
                    }
                    Ext.Component.prototype.onEnable.apply(this, arguments)
                },
                listeners  : {
                    change : function() {
                        g.win.focus();
                        g.relayCmd("fontName", g.fontSelect.dom.value);
                        g.deferFocus()
                    },
                    element: "selectEl"
                }
            });
            b.push(h, "-")
        }
        if (g.enableFormat) {
            b.push(c("bold"), c("italic"), c("underline"))
        }
        if (g.enableFontSize) {
            b.push("-", c("increasefontsize", false, g.adjustFont), c("decreasefontsize", false, g.adjustFont))
        }
        if (g.enableColors) {
            b.push("-", {
                itemId      : "forecolor",
                cls         : d + "btn-icon",
                iconCls     : d + "edit-forecolor",
                overflowText: g.buttonTips.forecolor.title,
                tooltip     : a ? g.buttonTips.forecolor || f : f,
                tabIndex    : -1,
                menu        : Ext.widget("menu", {
                    plain: true,
                    items: [{
                        xtype        : "colorpicker",
                        allowReselect: true,
                        focus        : Ext.emptyFn,
                        value        : "000000",
                        plain        : true,
                        clickEvent   : "mousedown",
                        handler      : function(j, i) {
                            g.relayCmd("forecolor", Ext.isWebKit || Ext.isIE ? "#" + i : i);
                            this.up("menu").hide()
                        }
                    }]
                })
            }, {
                itemId      : "backcolor",
                cls         : d + "btn-icon",
                iconCls     : d + "edit-backcolor",
                overflowText: g.buttonTips.backcolor.title,
                tooltip     : a ? g.buttonTips.backcolor || f : f,
                tabIndex    : -1,
                menu        : Ext.widget("menu", {
                    plain: true,
                    items: [{
                        xtype        : "colorpicker",
                        focus        : Ext.emptyFn,
                        value        : "FFFFFF",
                        plain        : true,
                        allowReselect: true,
                        clickEvent   : "mousedown",
                        handler      : function(j, i) {
                            if (Ext.isGecko) {
                                g.execCmd("useCSS", false);
                                g.execCmd("hilitecolor", "#" + i);
                                g.execCmd("useCSS", true);
                                g.deferFocus()
                            } else {
                                g.relayCmd(Ext.isOpera ? "hilitecolor" : "backcolor", Ext.isWebKit || Ext.isIE || Ext.isOpera ? "#" + i : i)
                            }
                            this.up("menu").hide()
                        }
                    }]
                })
            })
        }
        if (g.enableAlignments) {
            b.push("-", c("justifyleft"), c("justifycenter"), c("justifyright"))
        }
        if (!Ext.isSafari2) {
            if (g.enableLinks) {
                b.push("-", c("createlink", false, g.createLink))
            }
            if (g.enableLists) {
                b.push("-", c("insertorderedlist"), c("insertunorderedlist"))
            }
            if (g.enableSourceEdit) {
                b.push("-", c("sourceedit", true, function(i) {
                    g.toggleSourceEdit(!g.sourceEditMode)
                }))
            }
        }
        for (e = 0; e < b.length; e++) {
            if (b[e].itemId !== "sourceedit") {
                b[e].disabled = true
            }
        }
        return {
            xtype          : "toolbar",
            defaultButtonUI: g.defaultButtonUI,
            cls            : Ext.baseCSSPrefix + "html-editor-tb",
            enableOverflow : true,
            items          : b,
            listeners      : {
                click  : function(i) {
                    i.preventDefault()
                },
                element: "el"
            }
        }
    },
    getMaskTarget      : function() {
        return Ext.isGecko ? this.inputCmp.el : this.bodyEl
    },
    setReadOnly        : function(e) {
        var d      = this, c = d.textareaEl, b = d.iframeEl, a;
        d.readOnly = e;
        if (c) {
            c.dom.readOnly = e
        }
        if (d.initialized) {
            a = d.getEditorBody();
            if (Ext.isIE) {
                b.setDisplayed(false);
                a.contentEditable = !e;
                b.setDisplayed(true)
            } else {
                d.setDesignMode(!e)
            }
            if (a) {
                a.style.cursor = e ? "default" : "text"
            }
            d.disableItems(e)
        }
    },
    getDocMarkup       : function() {
        var b = this, a = b.iframeEl.getHeight() - b.iframePad * 2, c = Ext.isIE8m;
        return Ext.String.format((c ? "" : "<!DOCTYPE html>") + '<html><head><style type="text/css">' + (Ext.isOpera ? "p{margin:0}" : "") + "body{border:0;margin:0;padding:{0}px;direction:" + (b.rtl ? "rtl;" : "ltr;") + (c ? Ext.emptyString : "min-") + "height:{1}px;box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;cursor:text;background-color:white;" + (Ext.isIE ? "" : "font-size:12px;font-family:{2}") + "}</style></head><body></body></html>", b.iframePad, a, b.defaultFont)
    },
    getEditorBody      : function() {
        var a = this.getDoc();
        return a.body || a.documentElement
    },
    getDoc             : function() {
        return (!Ext.isIE && this.iframeEl.dom.contentDocument) || this.getWin().document
    },
    getWin             : function() {
        return Ext.isIE ? this.iframeEl.dom.contentWindow : window.frames[this.iframeEl.dom.name]
    },
    initDefaultFont    : function() {
        var g = this, a = 0, h, b, j, e, d, f, c;
        if (!g.defaultFont) {
            b = g.textareaEl.getStyle("font-family");
            b = Ext.String.capitalize(b.split(",")[0]);
            h = Ext.Array.clone(g.fontFamilies);
            Ext.Array.include(h, b);
            h.sort();
            g.defaultFont = b;
            j             = g.down("#fontSelect").selectEl.dom;
            for (d = 0, f = h.length; d < f; ++d) {
                b = h[d];
                c = b.toLowerCase();
                e = new Option(b, c);
                if (b == g.defaultFont) {
                    a = d
                }
                e.style.fontFamily = c;
                if (Ext.isIE) {
                    j.add(e)
                } else {
                    j.options.add(e)
                }
            }
            j.options[a].selected = true
        }
    },
    isEqual            : function(b, a) {
        return this.isEqualAsString(b, a)
    },
    afterRender        : function() {
        var b = this, a = b.inputCmp;
        b.callParent(arguments);
        b.iframeEl   = a.iframeEl;
        b.textareaEl = a.textareaEl;
        b.inputEl    = b.iframeEl;
        if (b.enableFont) {
            b.initDefaultFont()
        }
        b.monitorTask = Ext.TaskManager.start({
            run     : b.checkDesignMode,
            scope   : b,
            interval: 100
        });
        b.relayCmd("fontName", b.defaultFont)
    },
    initFrameDoc       : function() {
        var b = this, c, a;
        Ext.TaskManager.stop(b.monitorTask);
        c     = b.getDoc();
        b.win = b.getWin();
        c.open();
        c.write(b.getDocMarkup());
        c.close();
        a = {
            run     : function() {
                var d = b.getDoc();
                if (d.body || d.readyState === "complete") {
                    Ext.TaskManager.stop(a);
                    b.setDesignMode(true);
                    Ext.defer(b.initEditor, 10, b)
                }
            },
            interval: 10,
            duration: 10000,
            scope   : b
        };
        Ext.TaskManager.start(a)
    },
    checkDesignMode    : function() {
        var a = this, b = a.getDoc();
        if (b && (!b.editorInitialized || a.getDesignMode() !== "on")) {
            a.initFrameDoc()
        }
    },
    setDesignMode      : function(c) {
        var a = this, b = a.getDoc();
        if (b) {
            if (a.readOnly) {
                c = false
            }
            b.designMode = (/on|true/i).test(String(c).toLowerCase()) ? "on" : "off"
        }
    },
    getDesignMode      : function() {
        var a = this.getDoc();
        return !a ? "" : String(a.designMode).toLowerCase()
    },
    disableItems       : function(d) {
        var b = this.getToolbar().items.items, c, a = b.length, e;
        for (c = 0; c < a; c++) {
            e = b[c];
            if (e.getItemId() !== "sourceedit") {
                e.setDisabled(d)
            }
        }
    },
    toggleSourceEdit   : function(b) {
        var f = this, d = f.iframeEl, a = f.textareaEl, e = Ext.baseCSSPrefix + "hidden", c = f.getToolbar().getComponent("sourceedit");
        if (!Ext.isBoolean(b)) {
            b = !f.sourceEditMode
        }
        f.sourceEditMode = b;
        if (c.pressed !== b) {
            c.toggle(b)
        }
        if (b) {
            f.disableItems(true);
            f.syncValue();
            d.addCls(e);
            a.removeCls(e);
            a.dom.removeAttribute("tabIndex");
            a.focus();
            f.inputEl = a
        } else {
            if (f.initialized) {
                f.disableItems(f.readOnly)
            }
            f.pushValue();
            d.removeCls(e);
            a.addCls(e);
            a.dom.setAttribute("tabIndex", -1);
            f.deferFocus();
            f.inputEl = d
        }
        f.fireEvent("editmodechange", f, b);
        f.updateLayout()
    },
    createLink         : function() {
        var a = prompt(this.createLinkText, this.defaultLinkValue);
        if (a && a !== "http://") {
            this.relayCmd("createlink", a)
        }
    },
    clearInvalid       : Ext.emptyFn,
    setValue           : function(d) {
        var c = this, b = c.textareaEl, a = c.inputCmp;
        c.mixins.field.setValue.call(c, d);
        if (d === null || d === undefined) {
            d = ""
        }
        if (b) {
            b.dom.value = d
        }
        c.pushValue();
        if (!c.rendered && c.inputCmp) {
            c.inputCmp.data.value = d
        }
        return c
    },
    cleanHtml          : function(a) {
        a = String(a);
        if (Ext.isWebKit) {
            a = a.replace(/\sclass="(?:Apple-style-span|Apple-tab-span|khtml-block-placeholder)"/gi, "")
        }
        if (a.charCodeAt(0) === parseInt(this.defaultValue.replace(/\D/g, ""), 10)) {
            a = a.substring(1)
        }
        return a
    },
    syncValue          : function() {
        var f = this, b, g, d, a, c, e;
        if (f.initialized) {
            b = f.getEditorBody();
            d = b.innerHTML;
            e = f.textareaEl.dom;
            if (Ext.isWebKit) {
                a = b.getAttribute("style");
                c = a.match(/text-align:(.*?);/i);
                if (c && c[1]) {
                    d = '<div style="' + c[0] + '">' + d + "</div>"
                }
            }
            d = f.cleanHtml(d);
            if (f.fireEvent("beforesync", f, d) !== false) {
                if (Ext.isGecko && e.value === "" && d === "<br>") {
                    d = ""
                }
                if (e.value !== d) {
                    e.value = d;
                    g       = true
                }
                f.fireEvent("sync", f, d);
                if (g) {
                    f.checkChange()
                }
            }
        }
    },
    getValue           : function() {
        var a = this, b;
        if (!a.sourceEditMode) {
            a.syncValue()
        }
        b       = a.rendered ? a.textareaEl.dom.value : a.value;
        a.value = b;
        return b
    },
    pushValue          : function() {
        var b = this, a;
        if (b.initialized) {
            a = b.textareaEl.dom.value || "";
            if (!b.activated && a.length < 1) {
                a = b.defaultValue
            }
            if (b.fireEvent("beforepush", b, a) !== false) {
                b.getEditorBody().innerHTML = a;
                if (Ext.isGecko) {
                    b.setDesignMode(false);
                    b.setDesignMode(true)
                }
                b.fireEvent("push", b, a)
            }
        }
    },
    deferFocus         : function() {
        this.focus(false, true)
    },
    getFocusEl         : function() {
        var a = this, b = a.win;
        return b && !a.sourceEditMode ? b : a.textareaEl
    },
    focus              : function(d, b) {
        var c = this, e, a;
        if (b) {
            if (!c.focusTask) {
                c.focusTask = new Ext.util.DelayedTask(c.focus)
            }
            c.focusTask.delay(Ext.isNumber(b) ? b : 10, null, c, [d, false])
        } else {
            if (d) {
                if (c.textareaEl && c.textareaEl.dom) {
                    e = c.textareaEl.dom.value
                }
                if (e && e.length) {
                    c.execCmd("selectall", true)
                }
            }
            a = c.getFocusEl();
            if (a && a.focus) {
                a.focus()
            }
        }
        return c
    },
    initEditor         : function() {
        try {
            var f                      = this, d = f.getEditorBody(), b = f.textareaEl.getStyles("font-size", "font-family", "background-image", "background-repeat", "background-color", "color"), h, c;
            b["background-attachment"] = "fixed";
            d.bgProperties             = "fixed";
            Ext.DomHelper.applyStyles(d, b);
            h = f.getDoc();
            if (h) {
                try {
                    Ext.EventManager.removeAll(h)
                } catch (g) {
                }
            }
            c = Ext.Function.bind(f.onEditorEvent, f);
            Ext.EventManager.on(h, {
                mousedown: c,
                dblclick : c,
                click    : c,
                keyup    : c,
                buffer   : 100
            });
            c = f.onRelayedEvent;
            Ext.EventManager.on(h, {
                mousedown: c,
                mousemove: c,
                mouseup  : c,
                click    : c,
                dblclick : c,
                scope    : f
            });
            if (Ext.isGecko) {
                Ext.EventManager.on(h, "keypress", f.applyCommand, f)
            }
            if (f.fixKeys) {
                Ext.EventManager.on(h, "keydown", f.fixKeys, f)
            }
            if (f.fixKeysAfter) {
                Ext.EventManager.on(h, "keyup", f.fixKeysAfter, f)
            }
            if (Ext.isIE9 && Ext.isStrict) {
                Ext.EventManager.on(h.documentElement, "focus", f.focus, f)
            }
            if (Ext.isIE8m || (Ext.isIE9 && !Ext.isStrict)) {
                Ext.EventManager.on(h, "focusout", function() {
                    f.savedSelection = h.selection.type !== "None" ? h.selection.createRange() : null
                }, f);
                Ext.EventManager.on(h, "focusin", function() {
                    if (f.savedSelection) {
                        f.savedSelection.select()
                    }
                }, f)
            }
            Ext.EventManager.onWindowUnload(f.beforeDestroy, f);
            h.editorInitialized = true;
            f.initialized       = true;
            f.pushValue();
            f.setReadOnly(f.readOnly);
            f.fireEvent("initialize", f)
        } catch (a) {
        }
    },
    beforeDestroy      : function() {
        var a = this, d = a.monitorTask, c, f;
        if (d) {
            Ext.TaskManager.stop(d)
        }
        if (a.rendered) {
            Ext.EventManager.removeUnloadListener(a.beforeDestroy, a);
            try {
                c = a.getDoc();
                if (c) {
                    Ext.EventManager.removeAll(Ext.fly(c));
                    for (f in c) {
                        if (c.hasOwnProperty && c.hasOwnProperty(f)) {
                            delete c[f]
                        }
                    }
                }
            } catch (b) {
            }
            delete a.iframeEl;
            delete a.textareaEl;
            delete a.toolbar;
            delete a.inputCmp
        }
        a.callParent()
    },
    onRelayedEvent     : function(c) {
        var b = this.iframeEl, d = Ext.Element.getTrueXY(b), e = c.getXY(), a = Ext.EventManager.getPageXY(c.browserEvent);
        c.xy  = [d[0] + a[0], d[1] + a[1]];
        c.injectEvent(b);
        c.xy = e
    },
    onFirstFocus       : function() {
        var c       = this, b, a;
        c.activated = true;
        c.disableItems(c.readOnly);
        if (Ext.isGecko) {
            c.win.focus();
            b = c.win.getSelection();
            if (!b.focusNode || b.focusNode.nodeType !== 3) {
                a = b.getRangeAt(0);
                a.selectNodeContents(c.getEditorBody());
                a.collapse(true);
                c.deferFocus()
            }
            try {
                c.execCmd("useCSS", true);
                c.execCmd("styleWithCSS", false)
            } catch (d) {
            }
        }
        c.fireEvent("activate", c)
    },
    adjustFont         : function(d) {
        var e = d.getItemId() === "increasefontsize" ? 1 : -1, c = this.getDoc().queryCommandValue("FontSize") || "2", a = Ext.isString(c) && c.indexOf("px") !== -1, b;
        c     = parseInt(c, 10);
        if (a) {
            if (c <= 10) {
                c = 1 + e
            } else {
                if (c <= 13) {
                    c = 2 + e
                } else {
                    if (c <= 16) {
                        c = 3 + e
                    } else {
                        if (c <= 18) {
                            c = 4 + e
                        } else {
                            if (c <= 24) {
                                c = 5 + e
                            } else {
                                c = 6 + e
                            }
                        }
                    }
                }
            }
            c = Ext.Number.constrain(c, 1, 6)
        } else {
            b = Ext.isSafari;
            if (b) {
                e *= 2
            }
            c = Math.max(1, c + e) + (b ? "px" : 0)
        }
        this.relayCmd("FontSize", c)
    },
    onEditorEvent      : function(a) {
        this.updateToolbar()
    },
    updateToolbar      : function() {
        var h = this, e, c, d, j, b, f, a, g;
        if (h.readOnly) {
            return
        }
        if (!h.activated) {
            h.onFirstFocus();
            return
        }
        d = h.getToolbar().items.map;
        j = h.getDoc();
        if (h.enableFont && !Ext.isSafari2) {
            f = j.queryCommandValue("fontName");
            b = (f ? f.split(",")[0].replace(/^'/, "").replace(/'$/, "") : h.defaultFont).toLowerCase();
            a = h.fontSelect.dom;
            if (b !== a.value || b != f) {
                a.value = b
            }
        }
        function k() {
            var i;
            for (e = 0, c = arguments.length, b; e < c; e++) {
                b = arguments[e];
                try {
                    i = j.queryCommandState(b)
                } catch (l) {
                    i = false
                }
                d[b].toggle(i)
            }
        }

        if (h.enableFormat) {
            k("bold", "italic", "underline")
        }
        if (h.enableAlignments) {
            k("justifyleft", "justifycenter", "justifyright")
        }
        if (!Ext.isSafari2 && h.enableLists) {
            k("insertorderedlist", "insertunorderedlist")
        }
        g = h.toolbar.query("menu");
        for (e = 0; e < g.length; e++) {
            g[e].hide()
        }
        h.syncValue()
    },
    relayBtnCmd        : function(a) {
        this.relayCmd(a.getItemId())
    },
    relayCmd           : function(b, a) {
        Ext.defer(function() {
            var c = this;
            if (!this.isDestroyed) {
                c.win.focus();
                c.execCmd(b, a);
                c.updateToolbar()
            }
        }, 10, this)
    },
    execCmd            : function(c, b) {
        var a = this, d = a.getDoc();
        d.execCommand(c, false, (b == undefined ? null : b));
        a.syncValue()
    },
    applyCommand       : function(d) {
        if (d.ctrlKey) {
            var a = this, f = d.getCharCode(), b;
            if (f > 0) {
                f = String.fromCharCode(f);
                switch (f) {
                    case"b":
                        b = "bold";
                        break;
                    case"i":
                        b = "italic";
                        break;
                    case"u":
                        b = "underline";
                        break
                }
                if (b) {
                    a.win.focus();
                    a.execCmd(b);
                    a.deferFocus();
                    d.preventDefault()
                }
            }
        }
    },
    insertAtCursor     : function(c) {
        var b = this, a;
        if (b.activated) {
            b.win.focus();
            if (Ext.isIE) {
                a = b.getDoc().selection.createRange();
                if (a) {
                    a.pasteHTML(c);
                    b.syncValue();
                    b.deferFocus()
                }
            } else {
                b.execCmd("InsertHTML", c);
                b.deferFocus()
            }
        }
    },
    fixKeys            : (function() {
        if (Ext.isIE) {
            return function(g) {
                var c = this, b = g.getKey(), f = c.getDoc(), h = c.readOnly, a, d;
                if (b === g.TAB) {
                    g.stopEvent();
                    if (!h) {
                        a = f.selection.createRange();
                        if (a) {
                            if (a.collapse) {
                                a.collapse(true);
                                a.pasteHTML("&#160;&#160;&#160;&#160;")
                            }
                            c.deferFocus()
                        }
                    }
                } else {
                    if (b === g.ENTER) {
                        if (!h) {
                            a = f.selection.createRange();
                            if (a) {
                                d = a.parentElement();
                                if (!d || d.tagName.toLowerCase() !== "li") {
                                    g.stopEvent();
                                    a.pasteHTML("<br />");
                                    a.collapse(false);
                                    a.select()
                                }
                            }
                        }
                    }
                }
            }
        }
        if (Ext.isOpera) {
            return function(c) {
                var b = this, a = c.getKey(), d = b.readOnly;
                if (a === c.TAB) {
                    c.stopEvent();
                    if (!d) {
                        b.win.focus();
                        b.execCmd("InsertHTML", "&#160;&#160;&#160;&#160;");
                        b.deferFocus()
                    }
                }
            }
        }
        return null
    }()),
    fixKeysAfter       : (function() {
        if (Ext.isIE) {
            return function(d) {
                var b = this, a = d.getKey(), c = b.getDoc(), g = b.readOnly, f;
                if (!g && (a === d.BACKSPACE || a === d.DELETE)) {
                    f = c.body.innerHTML;
                    if (f === "<p>&nbsp;</p>" || f === "<P>&nbsp;</P>") {
                        c.body.innerHTML = ""
                    }
                }
            }
        }
        return null
    }()),
    getToolbar         : function() {
        return this.toolbar
    },
    buttonTips         : {
        bold               : {
            title: "Bold (Ctrl+B)",
            text : "Make the selected text bold.",
            cls  : Ext.baseCSSPrefix + "html-editor-tip"
        },
        italic             : {
            title: "Italic (Ctrl+I)",
            text : "Make the selected text italic.",
            cls  : Ext.baseCSSPrefix + "html-editor-tip"
        },
        underline          : {
            title: "Underline (Ctrl+U)",
            text : "Underline the selected text.",
            cls  : Ext.baseCSSPrefix + "html-editor-tip"
        },
        increasefontsize   : {
            title: "Grow Text",
            text : "Increase the font size.",
            cls  : Ext.baseCSSPrefix + "html-editor-tip"
        },
        decreasefontsize   : {
            title: "Shrink Text",
            text : "Decrease the font size.",
            cls  : Ext.baseCSSPrefix + "html-editor-tip"
        },
        backcolor          : {
            title: "Text Highlight Color",
            text : "Change the background color of the selected text.",
            cls  : Ext.baseCSSPrefix + "html-editor-tip"
        },
        forecolor          : {
            title: "Font Color",
            text : "Change the color of the selected text.",
            cls  : Ext.baseCSSPrefix + "html-editor-tip"
        },
        justifyleft        : {
            title: "Align Text Left",
            text : "Align text to the left.",
            cls  : Ext.baseCSSPrefix + "html-editor-tip"
        },
        justifycenter      : {
            title: "Center Text",
            text : "Center text in the editor.",
            cls  : Ext.baseCSSPrefix + "html-editor-tip"
        },
        justifyright       : {
            title: "Align Text Right",
            text : "Align text to the right.",
            cls  : Ext.baseCSSPrefix + "html-editor-tip"
        },
        insertunorderedlist: {
            title: "Bullet List",
            text : "Start a bulleted list.",
            cls  : Ext.baseCSSPrefix + "html-editor-tip"
        },
        insertorderedlist  : {
            title: "Numbered List",
            text : "Start a numbered list.",
            cls  : Ext.baseCSSPrefix + "html-editor-tip"
        },
        createlink         : {
            title: "Hyperlink",
            text : "Make the selected text a hyperlink.",
            cls  : Ext.baseCSSPrefix + "html-editor-tip"
        },
        sourceedit         : {
            title: "Source Edit",
            text : "Switch to source editing mode.",
            cls  : Ext.baseCSSPrefix + "html-editor-tip"
        }
    }
});
Ext.define("ExtThemeNeptune.form.field.HtmlEditor", {
    override       : "Ext.form.field.HtmlEditor",
    defaultButtonUI: "plain-toolbar"
});
Ext.define("Ext.picker.Time", {
    extend       : "Ext.view.BoundList",
    alias        : "widget.timepicker",
    requires     : ["Ext.data.Store", "Ext.Date"],
    increment    : 15,
    format       : "g:i A",
    displayField : "disp",
    initDate     : [2008, 0, 1],
    componentCls : Ext.baseCSSPrefix + "timepicker",
    loadMask     : false,
    initComponent: function() {
        var c    = this, a = Ext.Date, b = a.clearTime, d = c.initDate;
        c.absMin = b(new Date(d[0], d[1], d[2]));
        c.absMax = a.add(b(new Date(d[0], d[1], d[2])), "mi", (24 * 60) - 1);
        c.store  = c.createStore();
        c.store.addFilter(c.rangeFilter = new Ext.util.Filter({id: "time-picker-filter"}), false);
        c.updateList();
        c.callParent()
    },
    setMinValue  : function(a) {
        this.minValue = a;
        this.updateList()
    },
    setMaxValue  : function(a) {
        this.maxValue = a;
        this.updateList()
    },
    normalizeDate: function(a) {
        var b = this.initDate;
        a.setFullYear(b[0], b[1], b[2]);
        return a
    },
    updateList   : function() {
        var c = this, b = c.normalizeDate(c.minValue || c.absMin), a = c.normalizeDate(c.maxValue || c.absMax);
        c.rangeFilter.setFilterFn(function(d) {
            var e = d.get("date");
            return e >= b && e <= a
        });
        c.store.filter()
    },
    createStore  : function() {
        var d = this, c = Ext.Date, e = [], b = d.absMin, a = d.absMax;
        while (b <= a) {
            e.push({
                disp: c.dateFormat(b, d.format),
                date: b
            });
            b = c.add(b, "mi", d.increment)
        }
        return new Ext.data.Store({
            fields: ["disp", "date"],
            data  : e
        })
    },
    focusNode    : function(a) {
        return false
    }
});
Ext.define("Ext.form.field.Time", {
    extend                : "Ext.form.field.ComboBox",
    alias                 : "widget.timefield",
    requires              : ["Ext.form.field.Date", "Ext.picker.Time", "Ext.view.BoundListKeyNav", "Ext.Date"],
    alternateClassName    : ["Ext.form.TimeField", "Ext.form.Time"],
    triggerCls            : Ext.baseCSSPrefix + "form-time-trigger",
    minText               : "The time in this field must be equal to or after {0}",
    maxText               : "The time in this field must be equal to or before {0}",
    invalidText           : "{0} is not a valid time",
    format                : "g:i A",
    altFormats            : "g:ia|g:iA|g:i a|g:i A|h:i|g:i|H:i|ga|ha|gA|h a|g a|g A|gi|hi|gia|hia|g|H|gi a|hi a|giA|hiA|gi A|hi A",
    increment             : 15,
    pickerMaxHeight       : 300,
    selectOnTab           : true,
    snapToIncrement       : false,
    initDate              : "1/1/2008",
    initDateFormat        : "j/n/Y",
    ignoreSelection       : 0,
    queryMode             : "local",
    displayField          : "disp",
    valueField            : "date",
    initComponent         : function() {
        var c = this, b = c.minValue, a = c.maxValue;
        if (b) {
            c.setMinValue(b)
        }
        if (a) {
            c.setMaxValue(a)
        }
        c.displayTpl = new Ext.XTemplate('<tpl for=".">{[typeof values === "string" ? values : this.formatDate(values["' + c.displayField + '"])]}<tpl if="xindex < xcount">' + c.delimiter + "</tpl></tpl>", {formatDate: Ext.Function.bind(c.formatDate, c)});
        this.callParent()
    },
    transformOriginalValue: function(a) {
        if (Ext.isString(a)) {
            return this.rawToValue(a)
        }
        return a
    },
    isEqual               : function(b, a) {
        return Ext.Date.isEqual(b, a)
    },
    setMinValue           : function(c) {
        var b = this, a = b.picker;
        b.setLimit(c, true);
        if (a) {
            a.setMinValue(b.minValue)
        }
    },
    setMaxValue           : function(c) {
        var b = this, a = b.picker;
        b.setLimit(c, false);
        if (a) {
            a.setMaxValue(b.maxValue)
        }
    },
    setLimit              : function(b, f) {
        var a = this, e, c;
        if (Ext.isString(b)) {
            e = a.parseDate(b)
        } else {
            if (Ext.isDate(b)) {
                e = b
            }
        }
        if (e) {
            c = Ext.Date.clearTime(new Date(a.initDate));
            c.setHours(e.getHours(), e.getMinutes(), e.getSeconds(), e.getMilliseconds())
        } else {
            c = null
        }
        a[f ? "minValue" : "maxValue"] = c
    },
    rawToValue            : function(a) {
        return this.parseDate(a) || a || null
    },
    valueToRaw            : function(a) {
        return this.formatDate(this.parseDate(a))
    },
    getErrors             : function(d) {
        var b = this, f = Ext.String.format, g = b.callParent(arguments), c = b.minValue, e = b.maxValue, a;
        d     = b.formatDate(d || b.processRawValue(b.getRawValue()));
        if (d === null || d.length < 1) {
            return g
        }
        a = b.parseDate(d);
        if (!a) {
            g.push(f(b.invalidText, d, Ext.Date.unescapeFormat(b.format)));
            return g
        }
        if (c && a < c) {
            g.push(f(b.minText, b.formatDate(c)))
        }
        if (e && a > e) {
            g.push(f(b.maxText, b.formatDate(e)))
        }
        return g
    },
    formatDate            : function() {
        return Ext.form.field.Date.prototype.formatDate.apply(this, arguments)
    },
    parseDate             : function(e) {
        var d = this, g = e, b = d.altFormats, f = d.altFormatsArray, c = 0, a;
        if (e && !Ext.isDate(e)) {
            g = d.safeParse(e, d.format);
            if (!g && b) {
                f = f || b.split("|");
                a = f.length;
                for (; c < a && !g; ++c) {
                    g = d.safeParse(e, f[c])
                }
            }
        }
        if (g && d.snapToIncrement) {
            g = new Date(Ext.Number.snap(g.getTime(), d.increment * 60 * 1000))
        }
        return g
    },
    safeParse             : function(e, f) {
        var d = this, b = Ext.Date, c, a = null;
        if (b.formatContainsDateInfo(f)) {
            a = b.parse(e, f)
        } else {
            c = b.parse(d.initDate + " " + e, d.initDateFormat + " " + f);
            if (c) {
                a = c
            }
        }
        return a
    },
    getSubmitValue        : function() {
        var a = this, c = a.submitFormat || a.format, b = a.getValue();
        return b ? Ext.Date.format(b, c) : null
    },
    createPicker          : function() {
        var b        = this, a;
        b.listConfig = Ext.apply({
            xtype    : "timepicker",
            selModel : {mode: "SINGLE"},
            cls      : undefined,
            minValue : b.minValue,
            maxValue : b.maxValue,
            increment: b.increment,
            format   : b.format,
            maxHeight: b.pickerMaxHeight
        }, b.listConfig);
        a            = b.callParent();
        b.bindStore(a.store);
        return a
    },
    onItemClick           : function(b, a) {
        var d = this, c = b.getSelectionModel().getSelection();
        if (c.length > 0) {
            c = c[0];
            if (c && Ext.Date.isEqual(a.get("date"), c.get("date"))) {
                d.collapse()
            }
        }
    },
    onListSelectionChange : function(b, d) {
        if (d.length) {
            var a = this, c = d[0].get("date");
            if (!a.ignoreSelection) {
                a.skipSync = true;
                a.setValue(c);
                a.skipSync = false;
                a.fireEvent("select", a, c);
                a.picker.clearHighlight();
                a.collapse();
                a.inputEl.focus()
            }
        }
    },
    syncSelection         : function() {
        var i = this, g = i.picker, c, f, j, b, h, e, a;
        if (g && !i.skipSync) {
            g.clearHighlight();
            j = i.getValue();
            f = g.getSelectionModel();
            i.ignoreSelection++;
            if (j === null) {
                f.deselectAll()
            } else {
                if (Ext.isDate(j)) {
                    b = g.store.data.items;
                    e = b.length;
                    for (h = 0; h < e; h++) {
                        a = b[h];
                        if (Ext.Date.isEqual(a.get("date"), j)) {
                            c = a;
                            break
                        }
                    }
                    f.select(c)
                }
            }
            i.ignoreSelection--
        }
    },
    postBlur              : function() {
        var a = this, b = a.getValue();
        a.callParent(arguments);
        if (a.wasValid && b) {
            a.setRawValue(a.formatDate(b))
        }
    },
    setValue              : function() {
        this.getPicker();
        return this.callParent(arguments)
    },
    getValue              : function() {
        return this.parseDate(this.callParent(arguments))
    }
});
Ext.define("Ext.grid.CellContext", {
    isCellContext: true,
    constructor  : function(a) {
        this.view = a
    },
    setPosition  : function(c, a) {
        var b = this;
        if (arguments.length === 1) {
            if (c.view) {
                b.view = c.view
            }
            a = c.column;
            c = c.row
        }
        b.setRow(c);
        b.setColumn(a);
        return b
    },
    setRow       : function(b) {
        var a = this;
        if (b !== undefined) {
            if (typeof b === "number") {
                a.row    = Math.max(Math.min(b, a.view.dataSource.getCount() - 1), 0);
                a.record = a.view.dataSource.getAt(b)
            } else {
                if (b.isModel) {
                    a.record = b;
                    a.row    = a.view.indexOf(b)
                } else {
                    if (b.tagName) {
                        a.record = a.view.getRecord(b);
                        a.row    = a.view.indexOf(a.record)
                    }
                }
            }
        }
    },
    setColumn    : function(b) {
        var c = this, a = c.view.ownerCt.columnManager;
        if (b !== undefined) {
            if (typeof b === "number") {
                c.column       = b;
                c.columnHeader = a.getHeaderAtIndex(b)
            } else {
                if (b.isHeader) {
                    c.columnHeader = b;
                    c.column       = a.getHeaderIndex(b)
                }
            }
        }
    }
});
Ext.define("Ext.grid.ColumnComponentLayout", {
    extend                               : "Ext.layout.component.Auto",
    alias                                : "layout.columncomponent",
    type                                 : "columncomponent",
    setWidthInDom                        : true,
    beginLayout                          : function(b) {
        var a = this;
        a.callParent(arguments);
        b.titleContext   = b.getEl("titleEl");
        b.triggerContext = b.getEl("triggerEl")
    },
    beginLayoutCycle                     : function(d) {
        var b = this, a = b.owner;
        b.callParent(arguments);
        if (d.widthModel.shrinkWrap) {
            a.el.setWidth("")
        }
        var c = a.isLast && a.isSubHeader ? "0" : "";
        if (c !== b.lastBorderRightWidth) {
            a.el.dom.style.borderRightWidth = b.lasBorderRightWidth = c
        }
        a.titleEl.setStyle({
            paddingTop   : "",
            paddingBottom: ""
        })
    },
    publishInnerHeight                   : function(d, i) {
        if (!i) {
            return
        }
        var f = this, b = f.owner, a = i - d.getBorderInfo().height, c = a, g, e, j, h;
        if (!b.noWrap && !d.hasDomProp("width")) {
            f.done = false;
            return
        }
        if (d.hasRawContent) {
            e = c;
            g = b.textEl.getHeight();
            if (g) {
                c -= g;
                if (c > 0) {
                    j = Math.floor(c / 2);
                    h = c - j;
                    d.titleContext.setProp("padding-top", j);
                    d.titleContext.setProp("padding-bottom", h)
                }
            }
        } else {
            e = b.titleEl.getHeight();
            d.setProp("innerHeight", a - e, false)
        }
        if ((Ext.isIE6 || Ext.isIEQuirks) && d.triggerContext) {
            d.triggerContext.setHeight(e)
        }
    },
    measureContentHeight                 : function(a) {
        return a.el.dom.offsetHeight
    },
    publishOwnerHeight                   : function(b, a) {
        this.callParent(arguments);
        if ((Ext.isIE6 || Ext.isIEQuirks) && b.triggerContext) {
            b.triggerContext.setHeight(a)
        }
    },
    publishInnerWidth                    : function(a, b) {
        if (!a.hasRawContent) {
            a.setProp("innerWidth", b - a.getBorderInfo().width, false)
        }
    },
    calculateOwnerHeightFromContentHeight: function(c, b) {
        var a = this.callParent(arguments);
        if (!c.hasRawContent) {
            if (this.owner.noWrap || c.hasDomProp("width")) {
                return b + this.owner.titleEl.getHeight() + c.getBorderInfo().height
            }
            return null
        }
        return a
    },
    calculateOwnerWidthFromContentWidth  : function(f, b) {
        var a = this.owner, e = Math.max(b, a.textEl.getWidth() + f.titleContext.getPaddingInfo().width), d = f.getPaddingInfo().width, c = this.getTriggerOffset(a, f);
        return e + d + c
    },
    getTriggerOffset                     : function(a, c) {
        var b = 0;
        if (c.widthModel.shrinkWrap && !a.menuDisabled) {
            if (a.query(">:not([hidden])").length === 0) {
                b = a.self.triggerElWidth
            }
        }
        return b
    }
});
Ext.define("Ext.grid.ColumnLayout", {
    extend                : "Ext.layout.container.HBox",
    alias                 : "layout.gridcolumn",
    type                  : "gridcolumn",
    reserveOffset         : false,
    firstHeaderCls        : Ext.baseCSSPrefix + "column-header-first",
    lastHeaderCls         : Ext.baseCSSPrefix + "column-header-last",
    initLayout            : function() {
        if (!this.scrollbarWidth) {
            this.self.prototype.scrollbarWidth = Ext.getScrollbarSize().width
        }
        this.grid = this.owner.up("[scrollerOwner]");
        this.callParent()
    },
    beginLayout           : function(c) {
        var h = this, b = h.owner, a = h.grid, j = a.view, g = h.getVisibleItems(), f = g.length, d = h.firstHeaderCls, l = h.lastHeaderCls, e, k;
        if (a.lockable) {
            if (b.up("tablepanel") === j.normalGrid) {
                j = j.normalGrid.getView()
            } else {
                j = null
            }
        }
        for (e = 0; e < f; e++) {
            k        = g[e];
            k.isLast = false;
            k.removeCls([d, l]);
            if (e === 0) {
                k.addCls(d)
            }
            if (e === f - 1) {
                k.addCls(l);
                k.isLast = true
            }
        }
        h.callParent(arguments);
        if (!b.isColumn && Ext.getScrollbarSize().width && !a.collapsed && j && j.rendered && (c.viewTable = j.body.dom)) {
            c.viewContext = c.context.getCmp(j)
        }
    },
    roundFlex             : function(a) {
        return Math.floor(a)
    },
    calculate             : function(a) {
        this.callParent(arguments);
        if (a.state.parallelDone && (!this.owner.forceFit || a.flexedItems.length)) {
            a.setProp("columnWidthsDone", true)
        }
        if (a.viewContext) {
            a.state.tableHeight = a.viewTable.offsetHeight
        }
    },
    completeLayout        : function(d) {
        var b = this, a = b.owner, c = d.state;
        b.callParent(arguments);
        if (!d.flexedItems.length && !c.flexesCalculated && a.forceFit && b.convertWidthsToFlexes(d)) {
            b.cacheFlexes(d);
            d.invalidate({state: {flexesCalculated: true}})
        } else {
            d.setProp("columnWidthsDone", true)
        }
    },
    convertWidthsToFlexes : function(a) {
        var f = this, d = 0, g = f.sizeModels.calculated, c, e, b, j, h;
        c     = a.childItems;
        e     = c.length;
        for (b = 0; b < e; b++) {
            j = c[b];
            h = j.target;
            d += j.props.width;
            if (!(h.fixed || h.resizable === false)) {
                h.flex = a.childItems[b].flex = j.props.width;
                h.width      = null;
                j.widthModel = g
            }
        }
        return d !== a.props.width
    },
    getContainerSize      : function(e) {
        var d = this, a, c = e.viewContext, b;
        if (d.owner.isColumn) {
            a = d.getColumnContainerSize(e)
        } else {
            a = d.callParent(arguments);
            if (c && !c.heightModel.shrinkWrap && c.target.componentLayout.ownerContext) {
                b = c.getProp("height");
                if (isNaN(b)) {
                    d.done = false
                } else {
                    if (e.state.tableHeight > b) {
                        a.width -= Ext.getScrollbarSize().width;
                        e.state.parallelDone = false;
                        c.invalidate()
                    }
                }
            }
        }
        return a
    },
    getColumnContainerSize: function(f) {
        var h = f.paddingContext.getPaddingInfo(), b = 0, e = 0, g, d, c, a;
        if (!f.widthModel.shrinkWrap) {
            ++e;
            c = f.getProp("innerWidth");
            g = (typeof c == "number");
            if (g) {
                ++b;
                c -= h.width;
                if (c < 0) {
                    c = 0
                }
            }
        }
        if (!f.heightModel.shrinkWrap) {
            ++e;
            a = f.getProp("innerHeight");
            d = (typeof a == "number");
            if (d) {
                ++b;
                a -= h.height;
                if (a < 0) {
                    a = 0
                }
            }
        }
        return {
            width    : c,
            height   : a,
            needed   : e,
            got      : b,
            gotAll   : b == e,
            gotWidth : g,
            gotHeight: d
        }
    },
    publishInnerCtSize    : function(e) {
        var d             = this, c = e.state.boxPlan.targetSize, b = e.peek("contentWidth"), a;
        d.owner.tooNarrow = e.state.boxPlan.tooNarrow;
        if ((b != null) && !d.owner.isColumn) {
            c.width = b;
            a       = d.owner.ownerCt.view;
            if (a.scrollFlags.y) {
                c.width += Ext.getScrollbarSize().width
            }
        }
        return d.callParent(arguments)
    }
});
Ext.define("Ext.grid.ColumnManager", {
    alternateClassName            : ["Ext.grid.ColumnModel"],
    columns                       : null,
    constructor                   : function(b, a) {
        this.headerCt = b;
        if (a) {
            this.secondHeaderCt = a
        }
    },
    getColumns                    : function() {
        if (!this.columns) {
            this.cacheColumns()
        }
        return this.columns
    },
    getHeaderIndex                : function(a) {
        if (a.isGroupHeader) {
            a = a.down(":not([isGroupHeader])")
        }
        return Ext.Array.indexOf(this.getColumns(), a)
    },
    getHeaderAtIndex              : function(a) {
        var b = this.getColumns();
        return b.length ? b[a] : null
    },
    getHeaderById                 : function(e) {
        var c = this.getColumns(), a = c.length, b, d;
        for (b = 0; b < a; ++b) {
            d = c[b];
            if (d.getItemId() === e) {
                return d
            }
        }
        return null
    },
    getVisibleHeaderClosestToIndex: function(b) {
        var a = this.getHeaderAtIndex(b);
        if (a && a.hidden) {
            a = a.next(":not([hidden])") || a.prev(":not([hidden])")
        }
        return a
    },
    cacheColumns                  : function() {
        this.columns = this.headerCt.getVisibleGridColumns();
        if (this.secondHeaderCt) {
            Ext.Array.push(this.columns, this.secondHeaderCt.getVisibleGridColumns())
        }
    },
    invalidate                    : function() {
        this.columns = null;
        if (this.rootColumns) {
            this.rootColumns.invalidate()
        }
    }
}, function() {
    this.createAlias("indexOf", "getHeaderIndex")
});
Ext.define("Ext.panel.Table", {
    extend              : "Ext.panel.Panel",
    alias               : "widget.tablepanel",
    uses                : ["Ext.selection.RowModel", "Ext.selection.CellModel", "Ext.selection.CheckboxModel", "Ext.grid.plugin.BufferedRenderer", "Ext.grid.header.Container", "Ext.grid.locking.Lockable"],
    extraBaseCls        : Ext.baseCSSPrefix + "grid",
    extraBodyCls        : Ext.baseCSSPrefix + "grid-body",
    layout              : "fit",
    hasView             : false,
    viewType            : null,
    selType             : "rowmodel",
    scroll              : true,
    deferRowRender      : true,
    sortableColumns     : true,
    enableLocking       : false,
    scrollerOwner       : true,
    enableColumnMove    : true,
    sealedColumns       : false,
    enableColumnResize  : true,
    rowLines            : true,
    colLinesCls         : Ext.baseCSSPrefix + "grid-with-col-lines",
    rowLinesCls         : Ext.baseCSSPrefix + "grid-with-row-lines",
    noRowLinesCls       : Ext.baseCSSPrefix + "grid-no-row-lines",
    hiddenHeaderCtCls   : Ext.baseCSSPrefix + "grid-header-ct-hidden",
    hiddenHeaderCls     : Ext.baseCSSPrefix + "grid-header-hidden",
    resizeMarkerCls     : Ext.baseCSSPrefix + "grid-resize-marker",
    emptyCls            : Ext.baseCSSPrefix + "grid-empty",
    initComponent       : function() {
        var f = this, g = f.columns || f.colModel, b, e, a, c = f.store = Ext.data.StoreManager.lookup(f.store || "ext-empty-store"), d;
        if (f.columnLines) {
            f.addCls(f.colLinesCls)
        }
        f.addCls(f.rowLines ? f.rowLinesCls : f.noRowLinesCls);
        if (g instanceof Ext.grid.header.Container) {
            g.isRootHeader = true;
            f.headerCt     = g
        } else {
            if (f.enableLocking || f.hasLockedColumns(g)) {
                f.self.mixin("lockable", Ext.grid.locking.Lockable);
                f.injectLockable()
            } else {
                if (Ext.isArray(g)) {
                    g = {items: g}
                }
                Ext.apply(g, {
                    grid              : f,
                    forceFit          : f.forceFit,
                    sortable          : f.sortableColumns,
                    enableColumnMove  : f.enableColumnMove,
                    enableColumnResize: f.enableColumnResize,
                    sealed            : f.sealedColumns,
                    isRootHeader      : true
                });
                if (Ext.isDefined(f.enableColumnHide)) {
                    g.enableColumnHide = f.enableColumnHide
                }
                if (!f.headerCt) {
                    f.headerCt = new Ext.grid.header.Container(g)
                }
            }
        }
        f.columns    = f.headerCt.getGridColumns();
        f.scrollTask = new Ext.util.DelayedTask(f.syncHorizontalScroll, f);
        f.addEvents("reconfigure", "viewready");
        f.bodyCls = f.bodyCls || "";
        f.bodyCls += (" " + f.extraBodyCls);
        f.cls     = f.cls || "";
        f.cls += (" " + f.extraBaseCls);
        delete f.autoScroll;
        if (!f.hasView) {
            d = f.headerCt.getGridColumns();
            if (c.buffered && !c.remoteSort) {
                for (e = 0, a = d.length; e < a; e++) {
                    d[e].sortable = false
                }
            }
            if (f.hideHeaders) {
                f.headerCt.height        = 0;
                f.headerCt.hiddenHeaders = true;
                f.headerCt.addCls(f.hiddenHeaderCtCls);
                f.addCls(f.hiddenHeaderCls);
                if (Ext.isIEQuirks) {
                    f.headerCt.style = {display: "none"}
                }
            }
            f.relayHeaderCtEvents(f.headerCt);
            f.features = f.features || [];
            if (!Ext.isArray(f.features)) {
                f.features = [f.features]
            }
            f.dockedItems = [].concat(f.dockedItems || []);
            f.dockedItems.unshift(f.headerCt);
            f.viewConfig = f.viewConfig || {};
            b            = f.getView();
            f.items      = [b];
            f.hasView    = true;
            if (!f.hideHeaders) {
                b.on({
                    scroll: {
                        fn     : f.onHorizontalScroll,
                        element: "el",
                        scope  : f
                    }
                })
            }
            f.bindStore(c, true);
            f.mon(b, {
                viewready: f.onViewReady,
                refresh  : f.onRestoreHorzScroll,
                scope    : f
            })
        }
        f.relayEvents(f.view, ["beforeitemmousedown", "beforeitemmouseup", "beforeitemmouseenter", "beforeitemmouseleave", "beforeitemclick", "beforeitemdblclick", "beforeitemcontextmenu", "itemmousedown", "itemmouseup", "itemmouseenter", "itemmouseleave", "itemclick", "itemdblclick", "itemcontextmenu", "beforecellclick", "cellclick", "beforecelldblclick", "celldblclick", "beforecellcontextmenu", "cellcontextmenu", "beforecellmousedown", "cellmousedown", "beforecellmouseup", "cellmouseup", "beforecellkeydown", "cellkeydown", "beforecontainermousedown", "beforecontainermouseup", "beforecontainermouseover", "beforecontainermouseout", "beforecontainerclick", "beforecontainerdblclick", "beforecontainercontextmenu", "containermouseup", "containermouseover", "containermouseout", "containerclick", "containerdblclick", "containercontextmenu", "selectionchange", "beforeselect", "select", "beforedeselect", "deselect"]);
        f.callParent(arguments);
        f.addStateEvents(["columnresize", "columnmove", "columnhide", "columnshow", "sortchange", "filterchange"]);
        if (!f.lockable && f.headerCt) {
            f.headerCt.on("afterlayout", f.onRestoreHorzScroll, f)
        }
    },
    hasLockedColumns    : function(c) {
        var b, a, d;
        if (Ext.isObject(c)) {
            c = c.items
        }
        for (b = 0, a = c.length; b < a; b++) {
            d = c[b];
            if (!d.processed && d.locked) {
                return true
            }
        }
    },
    relayHeaderCtEvents : function(a) {
        this.relayEvents(a, ["columnresize", "columnmove", "columnhide", "columnshow", "columnschanged", "sortchange", "headerclick", "headercontextmenu", "headertriggerclick"])
    },
    getState            : function() {
        var b = this, c = b.callParent(), a = b.store.getState();
        c     = b.addPropertyToState(c, "columns", b.headerCt.getColumnsState());
        if (a) {
            c.storeState = a
        }
        return c
    },
    applyState          : function(e) {
        var d = this, f = e.sort, a = e.storeState, b = d.store, c = e.columns;
        delete e.columns;
        d.callParent(arguments);
        if (c) {
            d.headerCt.applyColumnsState(c)
        }
        if (f) {
            if (b.remoteSort) {
                b.sort({
                    property : f.property,
                    direction: f.direction,
                    root     : f.root
                }, null, false)
            } else {
                b.sort(f.property, f.direction)
            }
        } else {
            if (a) {
                b.applyState(a)
            }
        }
    },
    getStore            : function() {
        return this.store
    },
    getView             : function() {
        var a = this, b;
        if (!a.view) {
            b = a.getSelectionModel();
            Ext.widget(Ext.apply({
                grid               : a,
                deferInitialRefresh: a.deferRowRender !== false,
                trackOver          : a.trackMouseOver !== false,
                scroll             : a.scroll,
                xtype              : a.viewType,
                store              : a.store,
                headerCt           : a.headerCt,
                columnLines        : a.columnLines,
                rowLines           : a.rowLines,
                selModel           : b,
                features           : a.features,
                panel              : a,
                emptyText          : a.emptyText || ""
            }, a.viewConfig));
            if (a.view.emptyText) {
                a.view.emptyText = '<div class="' + a.emptyCls + '">' + a.view.emptyText + "</div>"
            }
            a.view.getComponentLayout().headerCt = a.headerCt;
            a.mon(a.view, {
                uievent: a.processEvent,
                scope  : a
            });
            b.view          = a.view;
            a.headerCt.view = a.view
        }
        return a.view
    },
    setAutoScroll       : Ext.emptyFn,
    processEvent        : function(g, i, j, a, h, d, c, k) {
        var f = this, b;
        if (h !== -1) {
            b = f.columnManager.getColumns()[h];
            return b.processEvent.apply(b, arguments)
        }
    },
    determineScrollbars : function() {
    },
    invalidateScroller  : function() {
    },
    scrollByDeltaY      : function(b, a) {
        this.getView().scrollBy(0, b, a)
    },
    scrollByDeltaX      : function(b, a) {
        this.getView().scrollBy(b, 0, a)
    },
    afterCollapse       : function() {
        var a = this;
        a.saveScrollPos();
        a.saveScrollPos();
        a.callParent(arguments)
    },
    afterExpand         : function() {
        var a = this;
        a.callParent(arguments);
        a.restoreScrollPos();
        a.restoreScrollPos()
    },
    saveScrollPos       : Ext.emptyFn,
    restoreScrollPos    : Ext.emptyFn,
    onHeaderResize      : function() {
        this.delayScroll()
    },
    onHeaderMove        : function(e, f, a, b, d) {
        var c = this;
        if (c.optimizedColumnMove === false) {
            c.view.refresh()
        } else {
            c.view.moveColumn(b, d, a)
        }
        c.delayScroll()
    },
    onHeaderHide        : function(a, b) {
        this.view.refresh();
        this.delayScroll()
    },
    onHeaderShow        : function(a, b) {
        this.view.refresh();
        this.delayScroll()
    },
    delayScroll         : function() {
        var a = this.getScrollTarget().el;
        if (a) {
            this.scrollTask.delay(10, null, null, [a.dom.scrollLeft])
        }
    },
    onViewReady         : function() {
        this.fireEvent("viewready", this)
    },
    onRestoreHorzScroll : function() {
        var a = this.scrollLeftPos;
        if (a) {
            this.syncHorizontalScroll(a, true)
        }
    },
    getScrollerOwner    : function() {
        var a = this;
        if (!this.scrollerOwner) {
            a = this.up("[scrollerOwner]")
        }
        return a
    },
    getLhsMarker        : function() {
        var a = this;
        return a.lhsMarker || (a.lhsMarker = Ext.DomHelper.append(a.el, {cls: a.resizeMarkerCls}, true))
    },
    getRhsMarker        : function() {
        var a = this;
        return a.rhsMarker || (a.rhsMarker = Ext.DomHelper.append(a.el, {cls: a.resizeMarkerCls}, true))
    },
    getSelectionModel   : function() {
        var c = this, a = c.selModel, e, d, b;
        if (!a) {
            a = {};
            e = true
        }
        if (!a.events) {
            b = a.selType || c.selType;
            e = !a.mode;
            a = c.selModel = Ext.create("selection." + b, a)
        }
        if (c.simpleSelect) {
            d = "SIMPLE"
        } else {
            if (c.multiSelect) {
                d = "MULTI"
            }
        }
        Ext.applyIf(a, {allowDeselect: c.allowDeselect});
        if (d && e) {
            a.setSelectionMode(d)
        }
        if (!a.hasRelaySetup) {
            c.relayEvents(a, ["selectionchange", "beforeselect", "beforedeselect", "select", "deselect"]);
            a.hasRelaySetup = true
        }
        if (c.disableSelection) {
            a.locked = true
        }
        return a
    },
    getScrollTarget     : function() {
        var a = this.getScrollerOwner(), b = a.query("tableview");
        return b[1] || b[0]
    },
    onHorizontalScroll  : function(a, b) {
        this.syncHorizontalScroll(b.scrollLeft)
    },
    syncHorizontalScroll: function(d, b) {
        var c = this, a;
        b     = b === true;
        if (c.rendered && (b || d !== c.scrollLeftPos)) {
            if (b) {
                a                   = c.getScrollTarget();
                a.el.dom.scrollLeft = d
            }
            c.headerCt.el.dom.scrollLeft = d;
            c.scrollLeftPos              = d
        }
    },
    onStoreLoad         : Ext.emptyFn,
    getEditorParent     : function() {
        return this.body
    },
    bindStore           : function(b, c) {
        var d   = this, a = d.getView(), e = b && b.buffered, f;
        d.store = b;
        f       = d.findPlugin("bufferedrenderer");
        if (f) {
            d.verticalScroller = f;
            if (f.store) {
                f.bindStore(b)
            }
        } else {
            if (e) {
                d.verticalScroller = f = d.addPlugin(Ext.apply({ptype: "bufferedrenderer"}, d.initialConfig.verticalScroller))
            }
        }
        if (a.store !== b) {
            if (c) {
                a.bindStore(b, false, "dataSource")
            } else {
                a.bindStore(b, false)
            }
        }
        d.mon(b, {
            load : d.onStoreLoad,
            scope: d
        });
        d.storeRelayers = d.relayEvents(b, ["filterchange"]);
        if (f) {
            d.invalidateScrollerOnRefresh = false
        }
        if (d.invalidateScrollerOnRefresh !== undefined) {
            a.preserveScrollOnRefresh = !d.invalidateScrollerOnRefresh
        }
    },
    unbindStore         : function() {
        var b = this, a = b.store;
        if (a) {
            b.store = null;
            b.mun(a, {
                load : b.onStoreLoad,
                scope: b
            });
            Ext.destroy(b.storeRelayers)
        }
    },
    reconfigure         : function(b, e) {
        var f = this, a = f.getView(), d, h = f.store, g = f.headerCt, c = g ? g.items.getRange() : f.columns;
        if (e) {
            e = Ext.Array.slice(e)
        }
        f.fireEvent("beforereconfigure", f, b, e, h, c);
        if (f.lockable) {
            f.reconfigureLockable(b, e)
        } else {
            Ext.suspendLayouts();
            if (e) {
                delete f.scrollLeftPos;
                g.removeAll();
                g.add(e)
            }
            if (b && (b = Ext.StoreManager.lookup(b)) !== h) {
                if (f.store) {
                    f.unbindStore()
                }
                d                     = a.deferInitialRefresh;
                a.deferInitialRefresh = false;
                f.bindStore(b);
                a.deferInitialRefresh = d
            } else {
                f.getView().refresh()
            }
            g.setSortState();
            Ext.resumeLayouts(true)
        }
        f.fireEvent("reconfigure", f, b, e, h, c)
    },
    beforeDestroy       : function() {
        var a = this.scrollTask;
        if (a) {
            a.cancel();
            this.scrollTask = null
        }
        this.callParent()
    },
    onDestroy           : function() {
        if (this.lockable) {
            this.destroyLockable()
        }
        this.callParent()
    }
});
Ext.define("Ext.view.TableLayout", {
    extend              : "Ext.layout.component.Auto",
    requires            : ["Ext.util.CSS"],
    alias               : ["layout.tableview"],
    type                : "tableview",
    beginLayout         : function(d) {
        var c = this, b = c.owner.lockingPartner, a = c.owner;
        c.callParent(arguments);
        if (b) {
            c.lockedGrid                    = c.owner.up("[lockable]");
            c.lockedGrid.needsRowHeightSync = true;
            if (!d.lockingPartner) {
                d.lockingPartner = d.context.getItem(b, b.el);
                if (d.lockingPartner && !d.lockingPartner.lockingPartner) {
                    d.lockingPartner.lockingPartner = d
                }
            }
        }
        d.headerContext = d.context.getCmp(c.headerCt);
        if (c.owner.body.dom) {
            d.bodyContext = d.getEl(c.owner.body)
        }
        if (Ext.isWebKit) {
            a.el.select(a.getBodySelector()).setStyle("table-layout", "auto")
        }
    },
    calculate           : function(f) {
        var e = this, c = e.lockingPartner, a = e.owner, d = 0, b;
        if (f.headerContext.hasProp("columnWidthsDone")) {
            if (!e.setColumnWidths(f)) {
                e.done = false;
                return
            }
            f.state.columnWidthsSynced = true;
            if (f.bodyContext) {
                b = e.owner.el.down("." + a.ownerCt.emptyCls, true);
                if (!b) {
                    d = f.bodyContext.el.dom.offsetHeight;
                    f.bodyContext.setHeight(d, false)
                } else {
                    d = b.offsetHeight
                }
                f.setProp("contentHeight", d)
            }
            if (c && !c.state.columnWidthsSynced) {
                e.done = false
            } else {
                e.callParent(arguments)
            }
        } else {
            e.done = false
        }
    },
    measureContentHeight: function(b) {
        var a = b.lockingPartner;
        if (!b.bodyContext || (b.state.columnWidthsSynced && (!a || a.state.columnWidthsSynced))) {
            return this.callParent(arguments)
        }
    },
    setColumnWidths     : function(d) {
        var m = this, c = m.owner, b = d.context, f = m.headerCt.getVisibleGridColumns(), e, j = 0, l = f.length, k = 0, a = 0, n, h, g = !Ext.isBorderBox;
        if (b) {
            b.currentLayout = m
        }
        for (j = 0; j < l; j++) {
            e = f[j];
            n = b.getCmp(e);
            h = n.props.width;
            if (isNaN(h)) {
                n.getProp("width");
                return false
            }
            k += h;
            if (g && c.columnLines) {
                if (!a) {
                    a = b.getCmp(e).borderInfo.width || 1
                }
                h -= a
            }
            c.body.select(c.getColumnSizerSelector(e)).setWidth(h)
        }
        c.el.select(c.getBodySelector()).setWidth(k);
        return true
    },
    finishedLayout      : function() {
        var b = this, a = b.owner;
        b.callParent(arguments);
        if (Ext.isWebKit) {
            a.el.select(a.getBodySelector()).setStyle("table-layout", "")
        }
        if (a.refreshCounter && b.lockedGrid && b.lockedGrid.syncRowHeight && b.lockedGrid.needsRowHeightSync) {
            b.lockedGrid.syncRowHeights();
            b.lockedGrid.needsRowHeightSync = false
        }
    }
});
Ext.define("Ext.view.NodeCache", {
    constructor   : function(a) {
        this.view = a;
        this.clear();
        this.el = new Ext.dom.AbstractElement.Fly()
    },
    clear         : function(e) {
        var c = this, d = this.elements, a, b;
        if (e) {
            for (a in d) {
                b = d[a];
                b.parentNode.removeChild(b)
            }
        }
        c.elements = {};
        c.count    = c.startIndex = 0;
        c.endIndex = -1
    },
    fill          : function(b, f) {
        var d = this, e = d.elements = {}, c, a = b.length;
        if (!f) {
            f = 0
        }
        for (c = 0; c < a; c++) {
            e[f + c] = b[c]
        }
        d.startIndex = f;
        d.endIndex   = f + a - 1;
        d.count      = a;
        return this
    },
    insert        : function(f, b) {
        var d = this, e = d.elements, c, a = b.length;
        if (d.count) {
            if (f < d.count) {
                for (c = d.endIndex + a; c >= f + a; c--) {
                    e[c] = e[c - a];
                    e[c].setAttribute("data-recordIndex", c)
                }
            }
            d.endIndex = d.endIndex + a
        } else {
            d.startIndex = f;
            d.endIndex   = f + a - 1
        }
        for (c = 0; c < a; c++, f++) {
            e[f] = b[c];
            e[f].setAttribute("data-recordIndex", f)
        }
        d.count += a
    },
    item          : function(c, b) {
        var d = this.elements[c], a = null;
        if (d) {
            a = b ? this.elements[c] : this.el.attach(this.elements[c])
        }
        return a
    },
    first         : function(a) {
        return this.item(this.startIndex, a)
    },
    last          : function(a) {
        return this.item(this.endIndex, a)
    },
    getCount      : function() {
        return this.count
    },
    slice         : function(e, b) {
        var d = this.elements, a = [], c;
        if (arguments.length < 2) {
            b = this.endIndex
        } else {
            b = Math.min(this.endIndex, b - 1)
        }
        for (c = e || this.startIndex; c <= b; c++) {
            a.push(d[c])
        }
        return a
    },
    replaceElement: function(d, c, a) {
        var e = this.elements, b = (typeof d === "number") ? d : this.indexOf(d);
        if (b > -1) {
            c = Ext.getDom(c);
            if (a) {
                d = e[b];
                d.parentNode.insertBefore(c, d);
                Ext.removeNode(d);
                c.setAttribute("data-recordIndex", b)
            }
            this.elements[b] = c
        }
        return this
    },
    indexOf       : function(b) {
        var c = this.elements, a;
        b     = Ext.getDom(b);
        for (a = this.startIndex; a <= this.endIndex; a++) {
            if (c[a] === b) {
                return a
            }
        }
        return -1
    },
    removeRange   : function(b, f, d) {
        var h = this, a = h.elements, e, g, c, j;
        if (f === undefined) {
            f = h.count
        } else {
            f = Math.min(h.endIndex + 1, f + 1)
        }
        if (!b) {
            b = 0
        }
        c = f - b;
        for (g = b, j = f; g < h.endIndex; g++, j++) {
            if (d && g < f) {
                Ext.removeNode(a[g])
            }
            if (j <= h.endIndex) {
                e = a[g] = a[j];
                e.setAttribute("data-recordIndex", g)
            } else {
                delete a[g]
            }
        }
        h.count -= c;
        h.endIndex -= c
    },
    removeElement : function(k, c) {
        var g = this, j, i, a = g.elements, d, e, b = 0, f, h;
        if (Ext.isArray(k)) {
            j = k;
            k = [];
            e = j.length;
            for (b = 0; b < e; b++) {
                i = j[b];
                if (typeof i !== "number") {
                    i = g.indexOf(i)
                }
                if (i >= g.startIndex && i <= g.endIndex) {
                    k[k.length] = i
                }
            }
            Ext.Array.sort(k);
            e = k.length
        } else {
            if (k < g.startIndex || k > g.endIndex) {
                return
            }
            e = 1;
            k = [k]
        }
        for (f = h = k[0], b = 0; f <= g.endIndex; f++, h++) {
            if (b < e && f === k[b]) {
                h++;
                b++;
                if (c) {
                    Ext.removeNode(a[f])
                }
            }
            if (h <= g.endIndex && h >= g.startIndex) {
                d = a[f] = a[h];
                d.setAttribute("data-recordIndex", f)
            } else {
                delete a[f]
            }
        }
        g.endIndex -= e;
        g.count -= e
    },
    scroll        : function(e, k, c) {
        var j = this, a = j.elements, m = e.length, g, d, b, f, h = j.view.getNodeContainer(), l = document.createDocumentFragment();
        if (k == -1) {
            for (g = (j.endIndex - c) + 1; g <= j.endIndex; g++) {
                d = a[g];
                delete a[g];
                d.parentNode.removeChild(d)
            }
            j.endIndex -= c;
            f = j.view.bufferRender(e, j.startIndex -= m);
            for (g = 0; g < m; g++) {
                a[j.startIndex + g] = f[g];
                l.appendChild(f[g])
            }
            h.insertBefore(l, h.firstChild)
        } else {
            b = j.startIndex + c;
            for (g = j.startIndex; g < b; g++) {
                d = a[g];
                delete a[g];
                d.parentNode.removeChild(d)
            }
            j.startIndex = g;
            f            = j.view.bufferRender(e, j.endIndex + 1);
            for (g = 0; g < m; g++) {
                a[j.endIndex += 1] = f[g];
                l.appendChild(f[g])
            }
            h.appendChild(l)
        }
        j.count = j.endIndex - j.startIndex + 1
    }
});
Ext.define("Ext.view.Table", {
    extend                  : "Ext.view.View",
    alias                   : "widget.tableview",
    requires                : ["Ext.grid.CellContext", "Ext.view.TableLayout", "Ext.view.NodeCache", "Ext.util.DelayedTask", "Ext.util.MixedCollection"],
    componentLayout         : "tableview",
    baseCls                 : Ext.baseCSSPrefix + "grid-view",
    firstCls                : Ext.baseCSSPrefix + "grid-cell-first",
    lastCls                 : Ext.baseCSSPrefix + "grid-cell-last",
    headerRowSelector       : "tr." + Ext.baseCSSPrefix + "grid-header-row",
    selectedItemCls         : Ext.baseCSSPrefix + "grid-row-selected",
    beforeSelectedItemCls   : Ext.baseCSSPrefix + "grid-row-before-selected",
    selectedCellCls         : Ext.baseCSSPrefix + "grid-cell-selected",
    focusedItemCls          : Ext.baseCSSPrefix + "grid-row-focused",
    beforeFocusedItemCls    : Ext.baseCSSPrefix + "grid-row-before-focused",
    tableFocusedFirstCls    : Ext.baseCSSPrefix + "grid-table-focused-first",
    tableSelectedFirstCls   : Ext.baseCSSPrefix + "grid-table-selected-first",
    tableOverFirstCls       : Ext.baseCSSPrefix + "grid-table-over-first",
    overItemCls             : Ext.baseCSSPrefix + "grid-row-over",
    beforeOverItemCls       : Ext.baseCSSPrefix + "grid-row-before-over",
    altRowCls               : Ext.baseCSSPrefix + "grid-row-alt",
    dirtyCls                : Ext.baseCSSPrefix + "grid-dirty-cell",
    rowClsRe                : new RegExp("(?:^|\\s*)" + Ext.baseCSSPrefix + "grid-row-(first|last|alt)(?:\\s+|$)", "g"),
    cellRe                  : new RegExp(Ext.baseCSSPrefix + "grid-cell-([^\\s]+) ", ""),
    positionBody            : true,
    trackOver               : true,
    getRowClass             : null,
    stripeRows              : true,
    markDirty               : true,
    tpl                     : "{%values.view.tableTpl.applyOut(values, out)%}",
    tableTpl                : ["{%", 'var view=values.view,tableCls=["' + Ext.baseCSSPrefix + '" + view.id + "-table ' + Ext.baseCSSPrefix + 'grid-table"];', "if (view.columnLines) tableCls[tableCls.length]=view.ownerCt.colLinesCls;", "if (view.rowLines) tableCls[tableCls.length]=view.ownerCt.rowLinesCls;", "%}", '<table role="presentation" id="{view.id}-table" class="{[tableCls.join(" ")]}" border="0" cellspacing="0" cellpadding="0" style="{tableStyle}" tabIndex="-1">', "{[view.renderColumnSizer(out)]}", "{[view.renderTHead(values, out)]}", "{[view.renderTFoot(values, out)]}", '<tbody id="{view.id}-body">', "{%", "view.renderRows(values.rows, values.viewStartIndex, out);", "%}", "</tbody>", "</table>", {priority: 0}],
    rowTpl                  : ["{%", 'var dataRowCls = values.recordIndex === -1 ? "" : " ' + Ext.baseCSSPrefix + 'grid-data-row";', "%}", '<tr role="row" {[values.rowId ? ("id=\\"" + values.rowId + "\\"") : ""]} ', 'data-boundView="{view.id}" ', 'data-recordId="{record.internalId}" ', 'data-recordIndex="{recordIndex}" ', 'class="{[values.itemClasses.join(" ")]} {[values.rowClasses.join(" ")]}{[dataRowCls]}" ', '{rowAttr:attributes} tabIndex="-1">', '<tpl for="columns">{%', "parent.view.renderCell(values, parent.record, parent.recordIndex, xindex - 1, out, parent)", "%}", "</tpl>", "</tr>", {priority: 0}],
    cellTpl                 : ['<td role="gridcell" class="{tdCls}" {tdAttr} id="{[Ext.id()]}">', '<div {unselectableAttr} class="' + Ext.baseCSSPrefix + 'grid-cell-inner {innerCls}"', 'style="text-align:{align};<tpl if="style">{style}</tpl>">{value}</div>', "</td>", {priority: 0}],
    refreshSelmodelOnRefresh: false,
    tableValues             : {},
    rowValues               : {
        itemClasses: [],
        rowClasses : []
    },
    cellValues              : {classes: [Ext.baseCSSPrefix + "grid-cell " + Ext.baseCSSPrefix + "grid-td"]},
    renderBuffer            : document.createElement("div"),
    constructor             : function(a) {
        if (a.grid.isTree) {
            a.baseCls = Ext.baseCSSPrefix + "tree-view"
        }
        this.callParent([a])
    },
    initComponent           : function() {
        var b = this, a = b.scroll;
        this.addEvents("beforecellclick", "cellclick", "beforecelldblclick", "celldblclick", "beforecellcontextmenu", "cellcontextmenu", "beforecellmousedown", "cellmousedown", "beforecellmouseup", "cellmouseup", "beforecellkeydown", "cellkeydown");
        b.body       = new Ext.dom.Element.Fly();
        b.body.id    = b.id + "gridBody";
        b.autoScroll = undefined;
        if (!b.trackOver) {
            b.overItemCls       = null;
            b.beforeOverItemCls = null
        }
        if (a === true || a === "both") {
            b.autoScroll = true
        } else {
            if (a === "horizontal") {
                b.overflowX = "auto"
            } else {
                if (a === "vertical") {
                    b.overflowY = "auto"
                }
            }
        }
        b.selModel.view = b;
        b.headerCt.view = b;
        b.grid.view     = b;
        b.initFeatures(b.grid);
        delete b.grid;
        b.tpl          = b.getTpl("tpl");
        b.itemSelector = b.getItemSelector();
        b.all          = new Ext.view.NodeCache(b);
        b.callParent()
    },
    moveColumn              : function(a, n, d) {
        var m = this, k = (d > 1) ? document.createDocumentFragment() : undefined, c = n, o = m.getGridColumns().length, g = o - 1, b = (m.firstCls || m.lastCls) && (n === 0 || n == o || a === 0 || a == g), f, e, r, h, l, q, p;
        if (m.rendered && n !== a) {
            r = m.el.query(m.getDataRowSelector());
            if (n > a && k) {
                c -= d
            }
            for (f = 0, h = r.length; f < h; f++) {
                l = r[f];
                q = l.childNodes;
                if (b) {
                    if (q.length === 1) {
                        Ext.fly(q[0]).addCls(m.firstCls);
                        Ext.fly(q[0]).addCls(m.lastCls);
                        continue
                    }
                    if (a === 0) {
                        Ext.fly(q[0]).removeCls(m.firstCls);
                        Ext.fly(q[1]).addCls(m.firstCls)
                    } else {
                        if (a === g) {
                            Ext.fly(q[g]).removeCls(m.lastCls);
                            Ext.fly(q[g - 1]).addCls(m.lastCls)
                        }
                    }
                    if (n === 0) {
                        Ext.fly(q[0]).removeCls(m.firstCls);
                        Ext.fly(q[a]).addCls(m.firstCls)
                    } else {
                        if (n === o) {
                            Ext.fly(q[g]).removeCls(m.lastCls);
                            Ext.fly(q[a]).addCls(m.lastCls)
                        }
                    }
                }
                if (k) {
                    for (e = 0; e < d; e++) {
                        k.appendChild(q[a])
                    }
                    l.insertBefore(k, q[c] || null)
                } else {
                    l.insertBefore(q[a], q[c] || null)
                }
            }
            p = m.el.query(m.getBodySelector());
            for (f = 0, h = p.length; f < h; f++) {
                l = p[f];
                if (k) {
                    for (e = 0; e < d; e++) {
                        k.appendChild(l.childNodes[a])
                    }
                    l.insertBefore(k, l.childNodes[c] || null)
                } else {
                    l.insertBefore(l.childNodes[a], l.childNodes[c] || null)
                }
            }
        }
    },
    scrollToTop             : Ext.emptyFn,
    addElListener           : function(a, c, b) {
        this.mon(this, a, c, b, {element: "el"})
    },
    getGridColumns          : function() {
        return this.ownerCt.columnManager.getColumns()
    },
    getHeaderAtIndex        : function(a) {
        return this.ownerCt.columnManager.getHeaderAtIndex(a)
    },
    getCell                 : function(a, b) {
        var c = this.getNode(a, true);
        return Ext.fly(c).down(b.getCellSelector())
    },
    getFeature              : function(b) {
        var a = this.featuresMC;
        if (a) {
            return a.get(b)
        }
    },
    findFeature             : function(a) {
        if (this.features) {
            return Ext.Array.findBy(this.features, function(b) {
                if (b.ftype === a) {
                    return true
                }
            })
        }
    },
    initFeatures            : function(d) {
        var f        = this, c, e, b, a;
        f.tableTpl   = Ext.XTemplate.getTpl(this, "tableTpl");
        f.rowTpl     = Ext.XTemplate.getTpl(this, "rowTpl");
        f.cellTpl    = Ext.XTemplate.getTpl(this, "cellTpl");
        f.featuresMC = new Ext.util.MixedCollection();
        e            = f.features = f.constructFeatures();
        a = e ? e.length : 0;
        for (c = 0; c < a; c++) {
            b      = e[c];
            b.view = f;
            b.grid = d;
            f.featuresMC.add(b);
            b.init(d)
        }
    },
    renderTHead             : function(b, c) {
        var e = b.view.headerFns, a, d;
        if (e) {
            for (d = 0, a = e.length; d < a; ++d) {
                e[d].call(this, b, c)
            }
        }
    },
    addHeaderFn             : function() {
        var a = this.headerFns;
        if (!a) {
            a = this.headerFns = []
        }
        a.push(fn)
    },
    renderTFoot             : function(b, c) {
        var e = b.view.footerFns, a, d;
        if (e) {
            for (d = 0, a = e.length; d < a; ++d) {
                e[d].call(this, b, c)
            }
        }
    },
    addFooterFn             : function(a) {
        var b = this.footerFns;
        if (!b) {
            b = this.footerFns = []
        }
        b.push(a)
    },
    addTableTpl             : function(a) {
        return this.addTpl("tableTpl", a)
    },
    addRowTpl               : function(a) {
        return this.addTpl("rowTpl", a)
    },
    addCellTpl              : function(a) {
        return this.addTpl("cellTpl", a)
    },
    addTpl                  : function(e, d) {
        var c = this, a, b;
        d     = Ext.Object.chain(d);
        if (!d.isTemplate) {
            d.applyOut = c.tplApplyOut
        }
        for (a = c[e]; d.priority < a.priority; a = a.nextTpl) {
            b = a
        }
        if (b) {
            b.nextTpl = d
        } else {
            c[e] = d
        }
        d.nextTpl = a;
        return d
    },
    tplApplyOut             : function(a, b) {
        if (this.before) {
            if (this.before(a, b) === false) {
                return
            }
        }
        this.nextTpl.applyOut(a, b);
        if (this.after) {
            this.after(a, b)
        }
    },
    constructFeatures       : function() {
        var f = this, e = f.features, d, b, c = 0, a;
        if (e) {
            b = [];
            a = e.length;
            for (; c < a; c++) {
                d = e[c];
                if (!d.isFeature) {
                    d = Ext.create("feature." + d.ftype, d)
                }
                b[c] = d
            }
        }
        return b
    },
    beforeRender            : function() {
        var a = this;
        a.callParent();
        if (!a.enableTextSelection) {
            a.protoEl.unselectable()
        }
    },
    onViewScroll            : function(b, a) {
        this.callParent(arguments);
        this.fireEvent("bodyscroll", b, a)
    },
    createRowElement        : function(a, b) {
        var c = this, d = c.renderBuffer;
        c.tpl.overwrite(d, c.collectData([a], b));
        return Ext.fly(d).down(c.getNodeContainerSelector(), true).firstChild
    },
    bufferRender            : function(a, b) {
        var c = this, d = c.renderBuffer;
        c.tpl.overwrite(d, c.collectData(a, b));
        return Ext.Array.toArray(Ext.fly(d).down(c.getNodeContainerSelector(), true).childNodes)
    },
    collectData             : function(a, b) {
        this.rowValues.view = this;
        return {
            view          : this,
            rows          : a,
            viewStartIndex: b,
            tableStyle    : this.bufferedRenderer ? ("position:absolute;top:" + this.bufferedRenderer.bodyTop) : ""
        }
    },
    collectNodes            : function(a) {
        this.all.fill(this.getNodeContainer().childNodes, this.all.startIndex)
    },
    refreshSize             : function() {
        var c = this, b, a = c.getBodySelector();
        if (a) {
            c.body.attach(c.el.child(a, true))
        }
        if (!c.hasLoadingHeight) {
            b = c.up("tablepanel");
            Ext.suspendLayouts();
            c.callParent();
            b.updateLayout();
            Ext.resumeLayouts(true)
        }
    },
    statics                 : {
        getBoundView: function(a) {
            return Ext.getCmp(a.getAttribute("data-boundView"))
        }
    },
    getRecord               : function(b) {
        b = this.getNode(b);
        if (b) {
            var a = b.getAttribute("data-recordIndex");
            if (a) {
                a = parseInt(a, 10);
                if (a > -1) {
                    return this.store.data.getAt(a)
                }
            }
            return this.dataSource.data.get(b.getAttribute("data-recordId"))
        }
    },
    indexOf                 : function(a) {
        a = this.getNode(a, false);
        if (!a && a !== 0) {
            return -1
        }
        return this.all.indexOf(a)
    },
    indexInStore            : function(b) {
        b = this.getNode(b, true);
        if (!b && b !== 0) {
            return -1
        }
        var a = b.getAttribute("data-recordIndex");
        if (a) {
            return parseInt(a, 10)
        }
        return this.dataSource.indexOf(this.getRecord(b))
    },
    renderRows              : function(e, d, b) {
        var f     = this.rowValues, a = e.length, c;
        f.view    = this;
        f.columns = this.ownerCt.columnManager.getColumns();
        for (c = 0; c < a; c++, d++) {
            f.itemClasses.length = f.rowClasses.length = 0;
            this.renderRow(e[c], d, b)
        }
        f.view = f.columns = f.record = null
    },
    renderColumnSizer       : function(b) {
        var d = this.getGridColumns(), a = d.length, c, f, e;
        for (c = 0; c < a; c++) {
            f = d[c];
            e = f.hidden ? 0 : (f.lastBox ? f.lastBox.width : Ext.grid.header.Container.prototype.defaultWidth);
            b.push('<colgroup><col class="', Ext.baseCSSPrefix, "grid-cell-", d[c].getItemId(), '" style="width:' + e + 'px"></colgroup>')
        }
    },
    renderRow               : function(f, a, e) {
        var h         = this, d = a === -1, g = h.selModel, k = h.rowValues, c = k.itemClasses, b = k.rowClasses, j, i = h.rowTpl;
        k.record      = f;
        k.recordId    = f.internalId;
        k.recordIndex = a;
        k.rowId       = h.getRowId(f);
        k.itemCls     = k.rowCls = "";
        if (!k.columns) {
            k.columns = h.ownerCt.columnManager.getColumns()
        }
        c.length = b.length = 0;
        if (!d) {
            c[0] = Ext.baseCSSPrefix + "grid-row";
            if (g && g.isRowSelected) {
                if (g.isRowSelected(a + 1)) {
                    c.push(h.beforeSelectedItemCls)
                }
                if (g.isRowSelected(f)) {
                    c.push(h.selectedItemCls)
                }
            }
            if (h.stripeRows && a % 2 !== 0) {
                b.push(h.altRowCls)
            }
            if (h.getRowClass) {
                j = h.getRowClass(f, a, null, h.dataSource);
                if (j) {
                    b.push(j)
                }
            }
        }
        if (e) {
            i.applyOut(k, e)
        } else {
            return i.apply(k)
        }
    },
    renderCell              : function(c, f, e, h, d) {
        var j         = this, g = j.selModel, i = j.cellValues, b = i.classes, a = f.data[c.dataIndex], l = j.cellTpl, m, k;
        i.record      = f;
        i.column      = c;
        i.recordIndex = e;
        i.columnIndex = h;
        i.cellIndex   = h;
        i.align       = c.align;
        i.tdCls       = c.tdCls;
        i.innerCls    = c.innerCls;
        i.style       = i.tdAttr = "";
        i.unselectableAttr = j.enableTextSelection ? "" : 'unselectable="on"';
        if (c.renderer && c.renderer.call) {
            m = c.renderer.call(c.scope || j.ownerCt, a, i, f, e, h, j.dataSource, j);
            if (i.css) {
                f.cssWarning = true;
                i.tdCls += " " + i.css;
                delete i.css
            }
        } else {
            m = a
        }
        i.value = (m == null || m === "") ? "&#160;" : m;
        b[1]    = Ext.baseCSSPrefix + "grid-cell-" + c.getItemId();
        k       = 2;
        if (c.tdCls) {
            b[k++] = c.tdCls
        }
        if (j.markDirty && f.isModified(c.dataIndex)) {
            b[k++] = j.dirtyCls
        }
        if (c.isFirstVisible) {
            b[k++] = j.firstCls
        }
        if (c.isLastVisible) {
            b[k++] = j.lastCls
        }
        if (!j.enableTextSelection) {
            b[k++] = Ext.baseCSSPrefix + "unselectable"
        }
        b[k++] = i.tdCls;
        if (g && g.isCellSelected && g.isCellSelected(j, e, h)) {
            b[k++] = (j.selectedCellCls)
        }
        b.length = k;
        i.tdCls  = b.join(" ");
        l.applyOut(i, d);
        i.column = null
    },
    getNode                 : function(c, b) {
        var d, a = this.callParent(arguments);
        if (a && a.tagName) {
            if (b) {
                if (!(d = Ext.fly(a)).is(this.dataRowSelector)) {
                    return d.down(this.dataRowSelector, true)
                }
            } else {
                if (b === false) {
                    if (!(d = Ext.fly(a)).is(this.itemSelector)) {
                        return d.up(this.itemSelector, null, true)
                    }
                }
            }
        }
        return a
    },
    getRowId                : function(a) {
        return this.id + "-record-" + a.internalId
    },
    constructRowId          : function(a) {
        return this.id + "-record-" + a
    },
    getNodeById             : function(b, a) {
        b = this.constructRowId(b);
        return this.retrieveNode(b, a)
    },
    getNodeByRecord         : function(a, b) {
        var c = this.getRowId(a);
        return this.retrieveNode(c, b)
    },
    retrieveNode            : function(e, c) {
        var a = this.el.getById(e, true), b = this.itemSelector, d;
        if (c === false && a) {
            if (!(d = Ext.fly(a)).is(b)) {
                return d.up(b, null, true)
            }
        }
        return a
    },
    updateIndexes           : Ext.emptyFn,
    bodySelector            : "table",
    nodeContainerSelector   : "tbody",
    itemSelector            : "tr." + Ext.baseCSSPrefix + "grid-row",
    dataRowSelector         : "tr." + Ext.baseCSSPrefix + "grid-data-row",
    cellSelector            : "td." + Ext.baseCSSPrefix + "grid-cell",
    sizerSelector           : "col." + Ext.baseCSSPrefix + "grid-cell",
    innerSelector           : "div." + Ext.baseCSSPrefix + "grid-cell-inner",
    getNodeContainer        : function() {
        return this.el.down(this.nodeContainerSelector, true)
    },
    getBodySelector         : function() {
        return this.bodySelector + "." + Ext.baseCSSPrefix + this.id + "-table"
    },
    getNodeContainerSelector: function() {
        return this.nodeContainerSelector
    },
    getColumnSizerSelector  : function(a) {
        return this.sizerSelector + "-" + a.getItemId()
    },
    getItemSelector         : function() {
        return this.itemSelector
    },
    getDataRowSelector      : function() {
        return this.dataRowSelector
    },
    getCellSelector         : function(b) {
        var a = this.cellSelector;
        if (b) {
            a += "-" + b.getItemId()
        }
        return a
    },
    getCellInnerSelector    : function(a) {
        return this.getCellSelector(a) + " " + this.innerSelector
    },
    addRowCls               : function(b, a) {
        var c = this.getNode(b, false);
        if (c) {
            Ext.fly(c).addCls(a)
        }
    },
    removeRowCls            : function(b, a) {
        var c = this.getNode(b, false);
        if (c) {
            Ext.fly(c).removeCls(a)
        }
    },
    setHighlightedItem      : function(c) {
        var b = this, a = b.highlightedItem;
        if (a && b.el.isAncestor(a) && b.isRowStyleFirst(a)) {
            b.getRowStyleTableEl(a).removeCls(b.tableOverFirstCls)
        }
        if (c && b.isRowStyleFirst(c)) {
            b.getRowStyleTableEl(c).addCls(b.tableOverFirstCls)
        }
        b.callParent(arguments)
    },
    onRowSelect             : function(b) {
        var a = this;
        a.addRowCls(b, a.selectedItemCls);
        if (a.isRowStyleFirst(b)) {
            a.getRowStyleTableEl(b).addCls(a.tableSelectedFirstCls)
        } else {
            a.addRowCls(b - 1, a.beforeSelectedItemCls)
        }
    },
    onRowDeselect           : function(b) {
        var a = this;
        a.removeRowCls(b, [a.selectedItemCls, a.focusedItemCls]);
        if (a.isRowStyleFirst(b)) {
            a.getRowStyleTableEl(b).removeCls([a.tableFocusedFirstCls, a.tableSelectedFirstCls])
        } else {
            a.removeRowCls(b - 1, [a.beforeFocusedItemCls, a.beforeSelectedItemCls])
        }
    },
    onCellSelect            : function(b) {
        var a = this.getCellByPosition(b);
        if (a) {
            a.addCls(this.selectedCellCls);
            this.scrollCellIntoView(a)
        }
    },
    onCellDeselect          : function(b) {
        var a = this.getCellByPosition(b, true);
        if (a) {
            Ext.fly(a).removeCls(this.selectedCellCls)
        }
    },
    getCellByPosition       : function(a, b) {
        if (a) {
            var c = this.getNode(a.row, true), d = this.ownerCt.columnManager.getHeaderAtIndex(a.column);
            if (d && c) {
                return Ext.fly(c).down(this.getCellSelector(d), b)
            }
        }
        return false
    },
    getFocusEl              : function() {
        var b = this, a;
        if (b.refreshCounter) {
            a = b.focusedRow;
            if (!(a && b.el.contains(a))) {
                if (b.all.getCount() && (a = b.getNode(b.all.item(0).dom, true))) {
                    b.focusRow(a)
                } else {
                    a = b.body
                }
            }
        } else {
            return b.el
        }
        return Ext.get(a)
    },
    onRowFocus              : function(d, b, a) {
        var c = this;
        if (b) {
            c.addRowCls(d, c.focusedItemCls);
            if (c.isRowStyleFirst(d)) {
                c.getRowStyleTableEl(d).addCls(c.tableFocusedFirstCls)
            } else {
                c.addRowCls(d - 1, c.beforeFocusedItemCls)
            }
            if (!a) {
                c.focusRow(d)
            }
        } else {
            c.removeRowCls(d, c.focusedItemCls);
            if (c.isRowStyleFirst(d)) {
                c.getRowStyleTableEl(d).removeCls(c.tableFocusedFirstCls)
            } else {
                c.removeRowCls(d - 1, c.beforeFocusedItemCls)
            }
        }
        if ((Ext.isIE6 || Ext.isIE7) && !c.ownerCt.rowLines) {
            c.repaintRow(d)
        }
    },
    focus                   : function(d, b) {
        var c = this, a = Ext.isIE && !b, e;
        if (a) {
            e = c.el.dom.scrollLeft
        }
        this.callParent(arguments);
        if (a) {
            c.el.dom.scrollLeft = e
        }
    },
    focusRow                : function(f, b) {
        var d = this, c, e = d.ownerCt && d.ownerCt.collapsed, a;
        if (d.isVisible(true) && !e && (f = d.getNode(f, true))) {
            d.scrollRowIntoView(f);
            a = d.getRecord(f);
            c = d.indexInStore(f);
            d.selModel.setLastFocused(a);
            d.focusedRow = f;
            d.focus(false, b, function() {
                d.fireEvent("rowfocus", a, f, c)
            })
        }
    },
    scrollRowIntoView       : function(a) {
        a = this.getNode(a, true);
        if (a) {
            Ext.fly(a).scrollIntoView(this.el, false)
        }
    },
    focusCell               : function(b) {
        var d = this, a = d.getCellByPosition(b), c = d.getRecord(b.row);
        d.focusRow(c);
        if (a) {
            d.scrollCellIntoView(a);
            d.fireEvent("cellfocus", c, a, b)
        }
    },
    scrollCellIntoView      : function(a) {
        if (a.row != null && a.column != null) {
            a = this.getCellByPosition(a)
        }
        if (a) {
            Ext.fly(a).scrollIntoView(this.el, true)
        }
    },
    scrollByDelta           : function(c, b) {
        b     = b || "scrollTop";
        var a = this.el.dom;
        a[b]  = (a[b] += c)
    },
    isDataRow               : function(a) {
        return Ext.fly(a).hasCls(Ext.baseCSSPrefix + "grid-data-row")
    },
    syncRowHeights          : function(f, a) {
        f                  = Ext.get(f);
        a                  = Ext.get(a);
        f.dom.style.height = a.dom.style.height = "";
        var d = this, e = d.rowTpl, b = f.dom.offsetHeight, c = a.dom.offsetHeight;
        if (b !== c) {
            while (e) {
                if (e.syncRowHeights) {
                    if (e.syncRowHeights(f, a) === false) {
                        break
                    }
                }
                e = e.nextTpl
            }
            b = f.dom.offsetHeight;
            c = a.dom.offsetHeight;
            if (b !== c) {
                f = f.down("[data-recordId]") || f;
                a = a.down("[data-recordId]") || a;
                if (f && a) {
                    f.dom.style.height = a.dom.style.height = "";
                    b = f.dom.offsetHeight;
                    c = a.dom.offsetHeight;
                    if (b > c) {
                        f.setHeight(b);
                        a.setHeight(b)
                    } else {
                        if (c > b) {
                            f.setHeight(c);
                            a.setHeight(c)
                        }
                    }
                }
            }
        }
    },
    onIdChanged             : function(a, g, f, c, b) {
        var e = this, d;
        if (e.viewReady) {
            d = e.getNodeById(b);
            if (d) {
                d.setAttribute("data-recordId", g.internalId);
                d.id = e.getRowId(g)
            }
        }
    },
    onUpdate                : function(f, c, k, p) {
        var t = this, m = t.rowTpl, h, q, b, j, l, r, s, e, n, o, i, d, u, g, a;
        if (t.viewReady) {
            b = t.getNodeByRecord(c, false);
            if (b) {
                n = t.overItemCls;
                o = t.overItemCls;
                i = t.focusedItemCls;
                d = t.beforeFocusedItemCls;
                u = t.selectedItemCls;
                g = t.beforeSelectedItemCls;
                h = t.indexInStore(c);
                q = Ext.fly(b, "_internal");
                j = t.createRowElement(c, h);
                if (q.hasCls(n)) {
                    Ext.fly(j).addCls(n)
                }
                if (q.hasCls(o)) {
                    Ext.fly(j).addCls(o)
                }
                if (q.hasCls(i)) {
                    Ext.fly(j).addCls(i)
                }
                if (q.hasCls(d)) {
                    Ext.fly(j).addCls(d)
                }
                if (q.hasCls(u)) {
                    Ext.fly(j).addCls(u)
                }
                if (q.hasCls(g)) {
                    Ext.fly(j).addCls(g)
                }
                a = t.ownerCt.columnManager.getColumns();
                if (Ext.isIE9m && b.mergeAttributes) {
                    b.mergeAttributes(j, true)
                } else {
                    l = j.attributes;
                    r = l.length;
                    for (e = 0; e < r; e++) {
                        s = l[e].name;
                        if (s !== "id") {
                            b.setAttribute(s, l[e].value)
                        }
                    }
                }
                if (a.length) {
                    t.updateColumns(c, t.getNode(b, true), t.getNode(j, true), a, p)
                }
                while (m) {
                    if (m.syncContent) {
                        if (m.syncContent(b, j) === false) {
                            break
                        }
                    }
                    m = m.nextTpl
                }
                t.fireEvent("itemupdate", c, h, b);
                t.refreshSize()
            }
        }
    },
    updateColumns           : function(d, c, h, b, o) {
        var s = this, i, p, q, f, k = b.length, l, e, a, j, g, n = s.editingPlugin || (s.lockingPartner && s.ownerCt.ownerLockable.view.editingPlugin), m = n && n.editing, r = s.getCellSelector();
        if (c.mergeAttributes) {
            c.mergeAttributes(h, true)
        } else {
            i = h.attributes;
            p = i.length;
            for (f = 0; f < p; f++) {
                q = i[f].name;
                if (q !== "id") {
                    c.setAttribute(q, i[f].value)
                }
            }
        }
        for (l = 0; l < k; l++) {
            e = b[l];
            if (s.shouldUpdateCell(d, e, o)) {
                r = s.getCellSelector(e);
                a = Ext.DomQuery.selectNode(r, c);
                j = Ext.DomQuery.selectNode(r, h);
                if (m) {
                    Ext.fly(a).syncContent(j)
                } else {
                    g = a.parentNode;
                    g.insertBefore(j, a);
                    g.removeChild(a)
                }
            }
        }
    },
    shouldUpdateCell        : function(b, e, d) {
        if (e.hasCustomRenderer || !d) {
            return true
        }
        if (d) {
            var a = d.length, c, f;
            for (c = 0; c < a; ++c) {
                f = d[c];
                if (f === e.dataIndex || f === b.idProperty) {
                    return true
                }
            }
        }
        return false
    },
    refresh                 : function() {
        var a = this, b = a.el && a.el.isAncestor(Ext.Element.getActiveElement());
        a.callParent(arguments);
        a.headerCt.setSortState();
        if (a.el && !a.all.getCount() && a.headerCt && a.headerCt.tooNarrow) {
            a.el.createChild({style: "position:absolute;height:1px;width:1px;left:" + (a.headerCt.getFullWidth() - 1) + "px"})
        }
        if (b) {
            a.selModel.onLastFocusChanged(null, a.selModel.lastFocused)
        }
    },
    processItemEvent        : function(f, r, n, j) {
        if (this.indexInStore(r) !== -1) {
            var l = this, o = j.getTarget(l.getCellSelector(), r), m, a = l.statics().EventMap, g = l.getSelectionModel(), k = j.type, b = l.features, h = b.length, c, q, p, d;
            if (k == "keydown" && !o && g.getCurrentPosition) {
                o = l.getCellByPosition(g.getCurrentPosition(), true)
            }
            if (o) {
                if (!o.parentNode) {
                    return false
                }
                d = l.getHeaderByCell(o);
                m = Ext.Array.indexOf(l.getGridColumns(), d)
            } else {
                m = -1
            }
            q = l.fireEvent("uievent", k, l, o, n, m, j, f, r);
            if (q === false || l.callParent(arguments) === false) {
                l.selModel.onVetoUIEvent(k, l, o, n, m, j, f, r);
                return false
            }
            for (c = 0; c < h; ++c) {
                p = b[c];
                if (p.wrapsItem) {
                    if (p.vetoEvent(f, r, n, j) === false) {
                        l.processSpecialEvent(j);
                        return false
                    }
                }
            }
            if (k == "mouseover" || k == "mouseout") {
                return true
            }
            if (!o) {
                return true
            }
            return !((l["onBeforeCell" + a[k]](o, m, f, r, n, j) === false) || (l.fireEvent("beforecell" + k, l, o, m, f, r, n, j) === false) || (l["onCell" + a[k]](o, m, f, r, n, j) === false) || (l.fireEvent("cell" + k, l, o, m, f, r, n, j) === false))
        } else {
            this.processSpecialEvent(j);
            return false
        }
    },
    processSpecialEvent     : function(h) {
        var l = this, c = l.features, k = c.length, m = h.type, d, n, f, g, b, j, a = l.ownerCt;
        l.callParent(arguments);
        if (m == "mouseover" || m == "mouseout") {
            return
        }
        for (d = 0; d < k; d++) {
            n = c[d];
            if (n.hasFeatureEvent) {
                g = h.getTarget(n.eventSelector, l.getTargetEl());
                if (g) {
                    f = n.eventPrefix;
                    b = n.getFireEventArgs("before" + f + m, l, g, h);
                    j = n.getFireEventArgs(f + m, l, g, h);
                    if ((l.fireEvent.apply(l, b) === false) || (a.fireEvent.apply(a, b) === false) || (l.fireEvent.apply(l, j) === false) || (a.fireEvent.apply(a, j) === false)) {
                        return false
                    }
                }
            }
        }
        return true
    },
    onCellMouseDown         : Ext.emptyFn,
    onCellMouseUp           : Ext.emptyFn,
    onCellClick             : Ext.emptyFn,
    onCellDblClick          : Ext.emptyFn,
    onCellContextMenu       : Ext.emptyFn,
    onCellKeyDown           : Ext.emptyFn,
    onBeforeCellMouseDown   : Ext.emptyFn,
    onBeforeCellMouseUp     : Ext.emptyFn,
    onBeforeCellClick       : Ext.emptyFn,
    onBeforeCellDblClick    : Ext.emptyFn,
    onBeforeCellContextMenu : Ext.emptyFn,
    onBeforeCellKeyDown     : Ext.emptyFn,
    expandToFit             : function(a) {
        this.autoSizeColumn(a)
    },
    autoSizeColumn          : function(a) {
        if (Ext.isNumber(a)) {
            a = this.getGridColumns[a]
        }
        if (a) {
            if (a.isGroupHeader) {
                a.autoSize();
                return
            }
            delete a.flex;
            a.setWidth(this.getMaxContentWidth(a))
        }
    },
    getMaxContentWidth      : function(d) {
        var f = this, l = f.el.query(d.getCellInnerSelector()), b = d.getWidth(), c = 0, e = l.length, j = Ext.supports.ScrollWidthInlinePaddingBug, a = f.body.select(f.getColumnSizerSelector(d)), g = Math.max, k, h;
        if (j && e > 0) {
            k = f.getCellPaddingAfter(l[0])
        }
        a.setWidth(1);
        h = d.textEl.dom.offsetWidth + d.titleEl.getPadding("lr");
        for (; c < e; c++) {
            h = g(h, l[c].scrollWidth)
        }
        if (j) {
            h += k
        }
        h = g(h, 40);
        a.setWidth(b);
        return h
    },
    getPositionByEvent      : function(f) {
        var d = this, b = f.getTarget(d.cellSelector), c = f.getTarget(d.itemSelector), a = d.getRecord(c), g = d.getHeaderByCell(b);
        return d.getPosition(a, g)
    },
    getHeaderByCell         : function(a) {
        if (a) {
            var b = a.className.match(this.cellRe);
            if (b && b[1]) {
                return this.ownerCt.columnManager.getHeaderById(b[1])
            }
        }
        return false
    },
    walkCells               : function(j, k, g, l, a, n) {
        if (!j) {
            return false
        }
        var h = this, o = j.row, d = j.column, i = h.dataSource.getCount(), b = h.ownerCt.columnManager.getColumns().length - 1, m = o, f = d, c = h.ownerCt.columnManager.getHeaderAtIndex(d);
        if (!c || c.hidden || !i) {
            return false
        }
        g = g || {};
        k = k.toLowerCase();
        switch (k) {
            case"right":
                if (d === b) {
                    if (l || o === i - 1) {
                        return false
                    }
                    if (!g.ctrlKey) {
                        m = h.walkRows(o, 1);
                        if (m !== o) {
                            f = 0
                        }
                    }
                } else {
                    if (!g.ctrlKey) {
                        f = d + 1
                    } else {
                        f = b
                    }
                }
                break;
            case"left":
                if (d === 0) {
                    if (l || o === 0) {
                        return false
                    }
                    if (!g.ctrlKey) {
                        m = h.walkRows(o, -1);
                        if (m !== o) {
                            f = b
                        }
                    }
                } else {
                    if (!g.ctrlKey) {
                        f = d - 1
                    } else {
                        f = 0
                    }
                }
                break;
            case"up":
                if (o === 0) {
                    return false
                } else {
                    if (!g.ctrlKey) {
                        m = h.walkRows(o, -1)
                    } else {
                        m = h.walkRows(-1, 1)
                    }
                }
                break;
            case"down":
                if (o === i - 1) {
                    return false
                } else {
                    if (!g.ctrlKey) {
                        m = h.walkRows(o, 1)
                    } else {
                        m = h.walkRows(i, -1)
                    }
                }
                break
        }
        if (a && a.call(n || h, {
                row   : m,
                column: f
            }) !== true) {
            return false
        } else {
            return new Ext.grid.CellContext(h).setPosition(m, f)
        }
    },
    walkRows                : function(h, a) {
        var d = this, e = 0, j = h, b, g = (d.dataSource.buffered ? d.dataSource.getTotalCount() : d.dataSource.getCount()) - 1, c = (a < 0) ? 0 : g, f = c ? 1 : -1, i = h;
        do {
            if (c ? i >= c : i <= 0) {
                return j || c
            }
            i += f;
            if ((b = Ext.fly(d.getNode(i, true))) && b.isVisible(true)) {
                e += f;
                j = i
            }
        } while (e !== a);
        return i
    },
    walkRecs                : function(b, a) {
        var g = this, h = 0, k = b, c, j = (g.store.buffered ? g.store.getTotalCount() : g.store.getCount()) - 1, e = (a < 0) ? 0 : j, i = e ? 1 : -1, f = g.store.indexOf(b), d;
        do {
            if (e ? f >= e : f <= 0) {
                return k
            }
            f += i;
            d = g.store.getAt(f);
            if ((c = Ext.fly(g.getNodeByRecord(d, true))) && c.isVisible(true)) {
                h += i;
                k = d
            }
        } while (h !== a);
        return k
    },
    getFirstVisibleRowIndex : function() {
        var c = this, b = (c.dataSource.buffered ? c.dataSource.getTotalCount() : c.dataSource.getCount()), a = c.indexOf(c.all.first()) - 1;
        do {
            a += 1;
            if (a === b) {
                return
            }
        } while (!Ext.fly(c.getNode(a, true)).isVisible(true));
        return a
    },
    getLastVisibleRowIndex  : function() {
        var b = this, a = b.indexOf(b.all.last());
        do {
            a -= 1;
            if (a === -1) {
                return
            }
        } while (!Ext.fly(b.getNode(a, true)).isVisible(true));
        return a
    },
    getHeaderCt             : function() {
        return this.headerCt
    },
    getPosition             : function(a, b) {
        return new Ext.grid.CellContext(this).setPosition(a, b)
    },
    beforeDestroy           : function() {
        var a = this;
        if (a.rendered) {
            a.el.removeAllListeners()
        }
        a.callParent(arguments)
    },
    onDestroy               : function() {
        var d = this, c = d.featuresMC, a, b;
        if (c) {
            for (b = 0, a = c.getCount(); b < a; ++b) {
                c.getAt(b).destroy()
            }
        }
        d.featuresMC = null;
        this.callParent(arguments)
    },
    onAdd                   : function(c, a, b) {
        this.callParent(arguments);
        this.doStripeRows(b)
    },
    onRemove                : function(c, a, b) {
        this.callParent(arguments);
        this.doStripeRows(b[0])
    },
    doStripeRows            : function(b, a) {
        var d = this, e, g, c, f;
        if (d.rendered && d.stripeRows) {
            e = d.getNodes(b, a);
            for (c = 0, g = e.length; c < g; c++) {
                f           = e[c];
                f.className = f.className.replace(d.rowClsRe, " ");
                b++;
                if (b % 2 === 0) {
                    f.className += (" " + d.altRowCls)
                }
            }
        }
    },
    repaintRow              : function(d) {
        var c = this.getNode(d), b = c.childNodes, a = b.length;
        while (a--) {
            b[a].className = b[a].className
        }
    },
    getRowStyleTableEl      : function(b) {
        var a = this;
        if (!b.tagName) {
            b = this.getNode(b)
        }
        return (a.isGrouping ? Ext.fly(b) : this.el).down("table.x-grid-table")
    },
    isRowStyleFirst         : function(c) {
        var b = this, a;
        if (c === -1) {
            return false
        }
        if (!c.tagName) {
            a = c;
            c = this.getNode(c)
        } else {
            a = b.indexOf(c)
        }
        return (!a || b.isGrouping && Ext.fly(c).hasCls(Ext.baseCSSPrefix + "grid-group-row"))
    },
    getCellPaddingAfter     : function(a) {
        return Ext.fly(a).getPadding("r")
    }
});
Ext.define("Ext.grid.View", {
    extend    : "Ext.view.Table",
    alias     : "widget.gridview",
    stripeRows: true,
    autoScroll: true
});
Ext.define("Ext.grid.Panel", {
    extend            : "Ext.panel.Table",
    requires          : ["Ext.grid.View"],
    alias             : ["widget.gridpanel", "widget.grid"],
    alternateClassName: ["Ext.list.ListView", "Ext.ListView", "Ext.grid.GridPanel"],
    viewType          : "gridview",
    lockable          : false,
    rowLines          : true
});
Ext.define("Ext.grid.plugin.BufferedRendererTableView", {
    override     : "Ext.view.Table",
    onAdd        : function(b, a, c) {
        var d = this, f = d.bufferedRenderer, e = d.all;
        if (d.rendered && f && (e.getCount() + a.length) > f.viewSize) {
            if (c < e.startIndex + f.viewSize && (c + a.length) > e.startIndex) {
                d.refreshView()
            } else {
                f.stretchView(d, f.getScrollHeight())
            }
        } else {
            d.callParent([b, a, c])
        }
    },
    onRemove     : function(b, a, d) {
        var c = this, e = c.bufferedRenderer;
        c.callParent([b, a, d]);
        if (c.rendered && e) {
            if (c.dataSource.getCount() > e.viewSize) {
                c.refreshView()
            } else {
                e.stretchView(c, e.getScrollHeight())
            }
        }
    },
    onDataRefresh: function() {
        var a = this;
        if (a.bufferedRenderer) {
            a.all.clear();
            a.bufferedRenderer.onStoreClear()
        }
        a.callParent()
    }
});
Ext.define("ExtThemeNeptune.panel.Table", {
    override  : "Ext.panel.Table",
    bodyBorder: true
});
Ext.define("Ext.view.DropZone", {
    extend                : "Ext.dd.DropZone",
    indicatorHtml         : '<div class="' + Ext.baseCSSPrefix + 'grid-drop-indicator-left"></div><div class="' + Ext.baseCSSPrefix + 'grid-drop-indicator-right"></div>',
    indicatorCls          : Ext.baseCSSPrefix + "grid-drop-indicator",
    constructor           : function(a) {
        var b = this;
        Ext.apply(b, a);
        if (!b.ddGroup) {
            b.ddGroup = "view-dd-zone-" + b.view.id
        }
        b.callParent([b.view.el])
    },
    fireViewEvent         : function() {
        var b = this, a;
        b.lock();
        a = b.view.fireEvent.apply(b.view, arguments);
        b.unlock();
        return a
    },
    getTargetFromEvent    : function(j) {
        var h = j.getTarget(this.view.getItemSelector()), d, c, b, f, a, g;
        if (!h) {
            d = j.getPageY();
            for (f = 0, c = this.view.getNodes(), a = c.length; f < a; f++) {
                b = c[f];
                g = Ext.fly(b).getBox();
                if (d <= g.bottom) {
                    return b
                }
            }
        }
        return h
    },
    getIndicator          : function() {
        var a = this;
        if (!a.indicator) {
            a.indicator = new Ext.Component({
                html    : a.indicatorHtml,
                cls     : a.indicatorCls,
                ownerCt : a.view,
                floating: true,
                shadow  : false
            })
        }
        return a.indicator
    },
    getPosition           : function(c, a) {
        var f = c.getXY()[1], b = Ext.fly(a).getRegion(), d;
        if ((b.bottom - f) >= (b.bottom - b.top) / 2) {
            d = "before"
        } else {
            d = "after"
        }
        return d
    },
    containsRecordAtOffset: function(d, b, f) {
        if (!b) {
            return false
        }
        var a = this.view, c = a.indexOf(b), e = a.getNode(c + f, true), g = e ? a.getRecord(e) : null;
        return g && Ext.Array.contains(d, g)
    },
    positionIndicator     : function(b, c, d) {
        var f = this, h = f.view, g = f.getPosition(d, b), j = h.getRecord(b), a = c.records, i;
        if (!Ext.Array.contains(a, j) && (g == "before" && !f.containsRecordAtOffset(a, j, -1) || g == "after" && !f.containsRecordAtOffset(a, j, 1))) {
            f.valid = true;
            if (f.overRecord != j || f.currentPosition != g) {
                i = Ext.fly(b).getY() - h.el.getY() - 1;
                if (g == "after") {
                    i += Ext.fly(b).getHeight()
                }
                f.getIndicator().setWidth(Ext.fly(h.el).getWidth()).showAt(0, i);
                f.overRecord      = j;
                f.currentPosition = g
            }
        } else {
            f.invalidateDrop()
        }
    },
    invalidateDrop        : function() {
        if (this.valid) {
            this.valid = false;
            this.getIndicator().hide()
        }
    },
    onNodeOver            : function(c, a, f, d) {
        var b = this;
        if (!Ext.Array.contains(d.records, b.view.getRecord(c))) {
            b.positionIndicator(c, d, f)
        }
        return b.valid ? b.dropAllowed : b.dropNotAllowed
    },
    notifyOut             : function(c, a, f, d) {
        var b = this;
        b.callParent(arguments);
        b.overRecord = b.currentPosition = null;
        b.valid = false;
        if (b.indicator) {
            b.indicator.hide()
        }
    },
    onContainerOver       : function(a, g, f) {
        var d = this, b = d.view, c = b.dataSource.getCount();
        if (c) {
            d.positionIndicator(b.all.last(), f, g)
        } else {
            d.overRecord = d.currentPosition = null;
            d.getIndicator().setWidth(Ext.fly(b.el).getWidth()).showAt(0, 0);
            d.valid = true
        }
        return d.dropAllowed
    },
    onContainerDrop       : function(a, c, b) {
        return this.onNodeDrop(a, null, c, b)
    },
    onNodeDrop            : function(h, a, g, f) {
        var d = this, c = false, b = {
            wait       : false,
            processDrop: function() {
                d.invalidateDrop();
                d.handleNodeDrop(f, d.overRecord, d.currentPosition);
                c = true;
                d.fireViewEvent("drop", h, f, d.overRecord, d.currentPosition)
            },
            cancelDrop : function() {
                d.invalidateDrop();
                c = true
            }
        }, i  = false;
        if (d.valid) {
            i = d.fireViewEvent("beforedrop", h, f, d.overRecord, d.currentPosition, b);
            if (b.wait) {
                return
            }
            if (i !== false) {
                if (!c) {
                    b.processDrop()
                }
            }
        }
        return i
    },
    destroy               : function() {
        Ext.destroy(this.indicator);
        delete this.indicator;
        this.callParent()
    }
});
Ext.define("Ext.grid.plugin.HeaderResizer", {
    extend               : "Ext.AbstractPlugin",
    requires             : ["Ext.dd.DragTracker", "Ext.util.Region"],
    alias                : "plugin.gridheaderresizer",
    disabled             : false,
    config               : {dynamic: false},
    colHeaderCls         : Ext.baseCSSPrefix + "column-header",
    minColWidth          : 40,
    maxColWidth          : 1000,
    wResizeCursor        : "col-resize",
    eResizeCursor        : "col-resize",
    init                 : function(a) {
        this.headerCt = a;
        a.on("render", this.afterHeaderRender, this, {single: true})
    },
    destroy              : function() {
        if (this.tracker) {
            this.tracker.destroy()
        }
    },
    afterHeaderRender    : function() {
        var b = this.headerCt, a = b.el;
        b.mon(a, "mousemove", this.onHeaderCtMouseMove, this);
        this.tracker = new Ext.dd.DragTracker({
            disabled     : this.disabled,
            onBeforeStart: Ext.Function.bind(this.onBeforeStart, this),
            onStart      : Ext.Function.bind(this.onStart, this),
            onDrag       : Ext.Function.bind(this.onDrag, this),
            onEnd        : Ext.Function.bind(this.onEnd, this),
            tolerance    : 3,
            autoStart    : 300,
            el           : a
        })
    },
    onHeaderCtMouseMove  : function(b, j) {
        var d = this, a, h, i, f, c, g;
        if (d.headerCt.dragging) {
            if (d.activeHd) {
                d.activeHd.el.dom.style.cursor = "";
                delete d.activeHd
            }
        } else {
            h = b.getTarget("." + d.colHeaderCls, 3, true);
            if (h) {
                i = Ext.getCmp(h.id);
                if (i.isOnLeftEdge(b)) {
                    f = i.previousNode("gridcolumn:not([hidden]):not([isGroupHeader])");
                    if (f) {
                        g = d.headerCt.up("tablepanel");
                        c = f.up("tablepanel");
                        if (!((c === g) || ((g.ownerCt.isXType("tablepanel")) && g.ownerCt.view.lockedGrid === c))) {
                            f = null
                        }
                    }
                } else {
                    if (i.isOnRightEdge(b)) {
                        f = i
                    } else {
                        f = null
                    }
                }
                if (f) {
                    if (f.isGroupHeader) {
                        a = f.getGridColumns();
                        f = a[a.length - 1]
                    }
                    if (f && !(f.fixed || (f.resizable === false) || d.disabled)) {
                        d.activeHd            = f;
                        i.el.dom.style.cursor = d.eResizeCursor;
                        if (i.triggerEl) {
                            i.triggerEl.dom.style.cursor = d.eResizeCursor
                        }
                    }
                } else {
                    i.el.dom.style.cursor = "";
                    if (i.triggerEl) {
                        i.triggerEl.dom.style.cursor = ""
                    }
                    d.activeHd = null
                }
            }
        }
    },
    onBeforeStart        : function(a) {
        this.dragHd = this.activeHd;
        if (!!this.dragHd && !this.headerCt.dragging) {
            this.tracker.constrainTo = this.getConstrainRegion();
            return true
        } else {
            this.headerCt.dragging = false;
            return false
        }
    },
    getConstrainRegion   : function() {
        var c = this, a = c.dragHd.el, d = 0, b, e;
        if (c.headerCt.forceFit) {
            b = c.dragHd.nextNode("gridcolumn:not([hidden]):not([isGroupHeader])");
            if (b) {
                if (!c.headerInSameGrid(b)) {
                    b = null
                }
                d = b.getWidth() - c.minColWidth
            }
        } else {
            if ((e = c.dragHd.up("tablepanel")).isLocked) {
                d = c.dragHd.up("[scrollerOwner]").getWidth() - e.getWidth() - 30
            } else {
                d = c.maxColWidth - a.getWidth()
            }
        }
        return c.adjustConstrainRegion(a.getRegion(), 0, d, 0, c.minColWidth)
    },
    onStart              : function(g) {
        var h               = this, f = h.dragHd, b = f.el.getWidth(), d = f.getOwnerHeaderCt(), k, j, l, c, a, i, m;
        h.headerCt.dragging = true;
        h.origWidth         = b;
        if (!h.dynamic) {
            l = c = d.up("tablepanel");
            if (l.ownerLockable) {
                c = l.ownerLockable
            }
            k = h.getLeftMarkerX(c);
            a = c.getLhsMarker();
            i = c.getRhsMarker();
            m = l.body.getHeight() + d.getHeight();
            j = d.getOffsetsTo(c)[1];
            a.setLocalY(j);
            i.setLocalY(j);
            a.setHeight(m);
            i.setHeight(m);
            h.setMarkerX(a, k);
            h.setMarkerX(i, k + b)
        }
    },
    onDrag               : function(b) {
        var a = this, c;
        if (a.dynamic) {
            a.doResize()
        } else {
            c = this.headerCt.up("tablepanel");
            if (c.ownerLockable) {
                c = c.ownerLockable
            }
            this.setMarkerX(this.getMovingMarker(c), this.calculateDragX(c))
        }
    },
    getMovingMarker      : function(a) {
        return a.getRhsMarker()
    },
    onEnd                : function(a) {
        this.headerCt.dragging = false;
        if (this.dragHd) {
            if (!this.dynamic) {
                var b = this.headerCt.up("tablepanel");
                if (b.ownerLockable) {
                    b = b.ownerLockable
                }
                this.setMarkerX(b.getLhsMarker(), -9999);
                this.setMarkerX(b.getRhsMarker(), -9999)
            }
            this.doResize()
        }
    },
    doResize             : function() {
        var c = this, b = c.dragHd, a, d;
        if (b) {
            d = c.tracker.getOffset("point");
            if (b.flex) {
                delete b.flex
            }
            Ext.suspendLayouts();
            c.adjustColumnWidth(d[0]);
            if (c.headerCt.forceFit) {
                a = b.nextNode("gridcolumn:not([hidden]):not([isGroupHeader])");
                if (a && !c.headerInSameGrid(a)) {
                    a = null
                }
                if (a) {
                    delete a.flex;
                    a.setWidth(a.getWidth() - d[0])
                }
            }
            Ext.resumeLayouts(true)
        }
    },
    headerInSameGrid     : function(b) {
        var a = this.dragHd.up("tablepanel");
        return !!b.up(a)
    },
    disable              : function() {
        this.disabled = true;
        if (this.tracker) {
            this.tracker.disable()
        }
    },
    enable               : function() {
        this.disabled = false;
        if (this.tracker) {
            this.tracker.enable()
        }
    },
    calculateDragX       : function(a) {
        return this.tracker.getXY("point")[0] - a.getX() - a.el.getBorderWidth("l")
    },
    getLeftMarkerX       : function(a) {
        return this.dragHd.getX() - a.getX() - a.el.getBorderWidth("l") - 1
    },
    setMarkerX           : function(b, a) {
        b.setLocalX(a)
    },
    adjustConstrainRegion: function(f, d, e, a, c) {
        return f.adjust(d, e, a, c)
    },
    adjustColumnWidth    : function(a) {
        this.dragHd.setWidth(this.origWidth + a)
    }
});
Ext.define("Ext.grid.header.DragZone", {
    extend           : "Ext.dd.DragZone",
    colHeaderSelector: "." + Ext.baseCSSPrefix + "column-header",
    colInnerSelector : "." + Ext.baseCSSPrefix + "column-header-inner",
    maxProxyWidth    : 120,
    constructor      : function(a) {
        this.headerCt = a;
        this.ddGroup  = this.getDDGroup();
        this.callParent([a.el]);
        this.proxy.el.addCls(Ext.baseCSSPrefix + "grid-col-dd")
    },
    getDDGroup       : function() {
        return "header-dd-zone-" + this.headerCt.up("[scrollerOwner]").id
    },
    getDragData      : function(b) {
        if (b.getTarget(this.colInnerSelector)) {
            var d = b.getTarget(this.colHeaderSelector), a, c;
            if (d) {
                a = Ext.getCmp(d.id);
                if (!this.headerCt.dragging && a.draggable && !(a.isOnLeftEdge(b) || a.isOnRightEdge(b))) {
                    c           = document.createElement("div");
                    c.innerHTML = Ext.getCmp(d.id).text;
                    return {
                        ddel  : c,
                        header: a
                    }
                }
            }
        }
        return false
    },
    onBeforeDrag     : function() {
        return !(this.headerCt.dragging || this.disabled)
    },
    onInitDrag       : function() {
        this.headerCt.dragging = true;
        this.callParent(arguments)
    },
    onDragDrop       : function() {
        this.headerCt.dragging = false;
        this.callParent(arguments)
    },
    afterRepair      : function() {
        this.callParent();
        this.headerCt.dragging = false
    },
    getRepairXY      : function() {
        return this.dragData.header.el.getXY()
    },
    disable          : function() {
        this.disabled = true
    },
    enable           : function() {
        this.disabled = false
    }
});
Ext.define("Ext.grid.header.DropZone", {
    extend            : "Ext.dd.DropZone",
    colHeaderCls      : Ext.baseCSSPrefix + "column-header",
    proxyOffsets      : [-4, -9],
    constructor       : function(a) {
        this.headerCt = a;
        this.ddGroup  = this.getDDGroup();
        this.callParent([a.el])
    },
    getDDGroup        : function() {
        return "header-dd-zone-" + this.headerCt.up("[scrollerOwner]").id
    },
    getTargetFromEvent: function(a) {
        return a.getTarget("." + this.colHeaderCls)
    },
    getTopIndicator   : function() {
        if (!this.topIndicator) {
            this.self.prototype.topIndicator     = Ext.DomHelper.append(Ext.getBody(), {
                cls : "col-move-top",
                html: "&#160;"
            }, true);
            this.self.prototype.indicatorXOffset = Math.floor((this.topIndicator.dom.offsetWidth + 1) / 2)
        }
        return this.topIndicator
    },
    getBottomIndicator: function() {
        if (!this.bottomIndicator) {
            this.self.prototype.bottomIndicator = Ext.DomHelper.append(Ext.getBody(), {
                cls : "col-move-bottom",
                html: "&#160;"
            }, true)
        }
        return this.bottomIndicator
    },
    getLocation       : function(d, b) {
        var a = d.getXY()[0], c = Ext.fly(b).getRegion(), f;
        if ((c.right - a) <= (c.right - c.left) / 2) {
            f = "after"
        } else {
            f = "before"
        }
        return {
            pos   : f,
            header: Ext.getCmp(b.id),
            node  : b
        }
    },
    positionIndicator : function(y, o, u) {
        var x = this, p = y.header, f = x.getLocation(u, o), j = f.header, d = f.pos, c, t, l, r, s, a, b, k, m, w, v, n, h, q, g;
        if (j === x.lastTargetHeader && d === x.lastDropPos) {
            return
        }
        c                  = p.nextSibling("gridcolumn:not([hidden])");
        t                  = p.previousSibling("gridcolumn:not([hidden])");
        x.lastTargetHeader = j;
        x.lastDropPos      = d;
        if (!j.draggable && d === "before" && j.getIndex() === 0) {
            return false
        }
        y.dropLocation = f;
        if ((p !== j) && ((d === "before" && c !== j) || (d === "after" && t !== j)) && !j.isDescendantOf(p)) {
            n = Ext.dd.DragDropManager.getRelated(x);
            h = n.length;
            q = 0;
            for (; q < h; q++) {
                g = n[q];
                if (g !== x && g.invalidateDrop) {
                    g.invalidateDrop()
                }
            }
            x.valid = true;
            l       = x.getTopIndicator();
            r       = x.getBottomIndicator();
            if (d === "before") {
                s = "bc-tl";
                a = "tc-bl"
            } else {
                s = "bc-tr";
                a = "tc-br"
            }
            b    = l.getAlignToXY(j.el, s);
            k    = r.getAlignToXY(j.el, a);
            m    = x.headerCt.el;
            w    = m.getX() - x.indicatorXOffset;
            v    = m.getX() + m.getWidth();
            b[0] = Ext.Number.constrain(b[0], w, v);
            k[0] = Ext.Number.constrain(k[0], w, v);
            l.setXY(b);
            r.setXY(k);
            l.show();
            r.show()
        } else {
            x.invalidateDrop()
        }
    },
    invalidateDrop    : function() {
        this.valid = false;
        this.hideIndicators()
    },
    onNodeOver        : function(c, g, f, d) {
        var h = this, j = d.header, a, k, b, i;
        if (d.header.el.dom === c) {
            a = false
        } else {
            d.isLock = d.isUnlock = false;
            k = h.getLocation(f, c).header;
            a = (j.ownerCt === k.ownerCt);
            if (!a && (!j.ownerCt.sealed && !k.ownerCt.sealed)) {
                a          = true;
                b          = j.up("tablepanel");
                i          = k.up("tablepanel");
                d.isLock   = i.isLocked && !b.isLocked;
                d.isUnlock = !i.isLocked && b.isLocked;
                if ((d.isUnlock && j.lockable === false) || (d.isLock && !j.isLockable())) {
                    a = false
                }
            }
        }
        if (a) {
            h.positionIndicator(d, c, f)
        } else {
            h.valid = false
        }
        return h.valid ? h.dropAllowed : h.dropNotAllowed
    },
    hideIndicators    : function() {
        var a = this;
        a.getTopIndicator().hide();
        a.getBottomIndicator().hide();
        a.lastTargetHeader = a.lastDropPos = null
    },
    onNodeOut         : function() {
        this.hideIndicators()
    },
    onNodeDrop        : function(n, c, q, t) {
        if (this.valid) {
            var p = t.header, h = t.dropLocation, k = h.header, s = p.ownerCt, l = s.items.indexOf(p), a = k.ownerCt, o = a.items.indexOf(k), i = this.headerCt, d = i.columnManager, b = d.getHeaderIndex(p), r = d.getHeaderIndex(k), m = p.isGroupHeader ? p.query(":not([isGroupHeader])").length : 1, j = s === a, g, f;
            if (h.pos === "after") {
                o++;
                r += k.isGroupHeader ? k.query(":not([isGroupHeader])").length : 1
            }
            if (t.isLock) {
                g = s.up("[scrollerOwner]");
                g.lock(p, o);
                t.isLock = false;
                this.onNodeDrop(n, c, q, t)
            } else {
                if (t.isUnlock) {
                    g = s.up("[scrollerOwner]");
                    g.unlock(p, o);
                    t.isUnlock = false;
                    this.onNodeDrop(n, c, q, t)
                } else {
                    this.invalidateDrop();
                    f = p.getWidth();
                    if (j) {
                        if (o === l) {
                            i.onHeaderMoved(p, m, b, r);
                            return
                        }
                        if (o > l) {
                            o -= 1
                        }
                    }
                    Ext.suspendLayouts();
                    if (j) {
                        a.move(l, o)
                    } else {
                        s.remove(p, false);
                        a.insert(o, p)
                    }
                    if (a.isGroupHeader) {
                        if (!j) {
                            p.savedFlex = p.flex;
                            delete p.flex;
                            p.width = f
                        }
                    } else {
                        if (p.savedFlex) {
                            p.flex = p.savedFlex;
                            delete p.width
                        }
                    }
                    i.purgeCache();
                    Ext.resumeLayouts(true);
                    i.onHeaderMoved(p, m, b, r)
                }
            }
        }
    }
});
Ext.define("Ext.grid.plugin.HeaderReorderer", {
    extend          : "Ext.AbstractPlugin",
    requires        : ["Ext.grid.header.DragZone", "Ext.grid.header.DropZone"],
    alias           : "plugin.gridheaderreorderer",
    init            : function(a) {
        this.headerCt = a;
        a.on({
            render: this.onHeaderCtRender,
            single: true,
            scope : this
        })
    },
    destroy         : function() {
        Ext.destroy(this.dragZone, this.dropZone)
    },
    onHeaderCtRender: function() {
        var a      = this;
        a.dragZone = new Ext.grid.header.DragZone(a.headerCt);
        a.dropZone = new Ext.grid.header.DropZone(a.headerCt);
        if (a.disabled) {
            a.dragZone.disable()
        }
    },
    enable          : function() {
        this.disabled = false;
        if (this.dragZone) {
            this.dragZone.enable()
        }
    },
    disable         : function() {
        this.disabled = true;
        if (this.dragZone) {
            this.dragZone.disable()
        }
    }
});
Ext.define("Ext.grid.header.Container", {
    extend                        : "Ext.container.Container",
    requires                      : ["Ext.grid.ColumnLayout", "Ext.grid.plugin.HeaderResizer", "Ext.grid.plugin.HeaderReorderer"],
    uses                          : ["Ext.grid.column.Column", "Ext.grid.ColumnManager", "Ext.menu.Menu", "Ext.menu.CheckItem", "Ext.menu.Separator"],
    border                        : true,
    alias                         : "widget.headercontainer",
    baseCls                       : Ext.baseCSSPrefix + "grid-header-ct",
    dock                          : "top",
    weight                        : 100,
    defaultType                   : "gridcolumn",
    detachOnRemove                : false,
    defaultWidth                  : 100,
    sortAscText                   : "Sort Ascending",
    sortDescText                  : "Sort Descending",
    sortClearText                 : "Clear Sort",
    columnsText                   : "Columns",
    headerOpenCls                 : Ext.baseCSSPrefix + "column-header-open",
    menuSortAscCls                : Ext.baseCSSPrefix + "hmenu-sort-asc",
    menuSortDescCls               : Ext.baseCSSPrefix + "hmenu-sort-desc",
    menuColsIcon                  : Ext.baseCSSPrefix + "cols-icon",
    triStateSort                  : false,
    ddLock                        : false,
    dragging                      : false,
    sortable                      : true,
    enableColumnHide              : true,
    initComponent                 : function() {
        var a           = this;
        a.headerCounter = 0;
        a.plugins       = a.plugins || [];
        if (!a.isColumn) {
            if (a.enableColumnResize) {
                a.resizer = new Ext.grid.plugin.HeaderResizer();
                a.plugins.push(a.resizer)
            }
            if (a.enableColumnMove) {
                a.reorderer = new Ext.grid.plugin.HeaderReorderer();
                a.plugins.push(a.reorderer)
            }
        }
        if (a.isColumn && (!a.items || a.items.length === 0)) {
            a.isContainer = false;
            a.layout      = {
                type     : "container",
                calculate: Ext.emptyFn
            }
        } else {
            a.layout = Ext.apply({
                type : "gridcolumn",
                align: "stretch"
            }, a.initialConfig.layout);
            if (a.isRootHeader) {
                a.grid.columnManager = a.columnManager = new Ext.grid.ColumnManager(a)
            }
        }
        a.defaults = a.defaults || {};
        Ext.applyIf(a.defaults, {
            triStateSort: a.triStateSort,
            sortable    : a.sortable
        });
        a.menuTask = new Ext.util.DelayedTask(a.updateMenuDisabledState, a);
        a.callParent();
        a.addEvents("columnresize", "headerclick", "headercontextmenu", "headertriggerclick", "columnmove", "columnhide", "columnshow", "columnschanged", "sortchange", "menucreate")
    },
    isLayoutRoot                  : function() {
        if (this.hiddenHeaders) {
            return false
        }
        return this.callParent()
    },
    getOwnerHeaderCt              : function() {
        var a = this;
        return a.isRootHeader ? a : a.up("[isRootHeader]")
    },
    onDestroy                     : function() {
        var a = this;
        if (a.menu) {
            a.menu.un("hide", a.onMenuHide, a)
        }
        a.menuTask.cancel();
        Ext.destroy(a.resizer, a.reorderer);
        a.callParent()
    },
    applyColumnsState             : function(e) {
        if (!e || !e.length) {
            return
        }
        var l = this, j = l.items.items, h = j.length, f = 0, b = e.length, k, d, a, g;
        for (k = 0; k < b; k++) {
            a = e[k];
            for (g = h; g--;) {
                d = j[g];
                if (d.getStateId && d.getStateId() == a.id) {
                    if (f !== g) {
                        l.moveHeader(g, f)
                    }
                    if (d.applyColumnState) {
                        d.applyColumnState(a)
                    }
                    ++f;
                    break
                }
            }
        }
    },
    getColumnsState               : function() {
        var b = this, a = [], c;
        b.items.each(function(d) {
            c = d.getColumnState && d.getColumnState();
            if (c) {
                a.push(c)
            }
        });
        return a
    },
    onAdd                         : function(b) {
        var a = this;
        if (!b.headerId) {
            b.headerId = b.initialConfig.id || Ext.id(null, "header-")
        }
        if (!b.getStateId()) {
            b.stateId = b.initialConfig.id || ("h" + (++a.headerCounter))
        }
        a.callParent(arguments);
        a.onColumnsChanged()
    },
    onMove                        : function() {
        this.callParent(arguments);
        this.onColumnsChanged()
    },
    onShow                        : function() {
        this.callParent(arguments);
        this.onColumnsChanged()
    },
    onColumnsChanged              : function() {
        var a = this;
        while (a) {
            a.purgeCache();
            if (a.isRootHeader) {
                break
            }
            a = a.ownerCt
        }
        if (a && a.rendered) {
            a.fireEvent("columnschanged", a)
        }
    },
    onRemove                      : function(d) {
        var b = this, a = b.ownerCt;
        b.callParent(arguments);
        if (!b.destroying) {
            b.onColumnsChanged();
            if (b.isGroupHeader && !b.items.getCount() && a) {
                b.detachComponent(d);
                Ext.suspendLayouts();
                a.remove(b);
                Ext.resumeLayouts(true)
            }
        }
    },
    applyDefaults                 : function(b) {
        var a;
        if (b && !b.isComponent && b.xtype == "rownumberer") {
            a = b
        } else {
            a = this.callParent(arguments);
            if (!b.isGroupHeader && !("width" in a) && !a.flex) {
                a.width = this.defaultWidth
            }
        }
        return a
    },
    setSortState                  : function() {
        var a = this.up("[store]").store, c = a.getFirstSorter(), b;
        if (c) {
            b = this.down("gridcolumn[dataIndex=" + c.property + "]");
            if (b) {
                b.setSortState(c.direction, false, true)
            }
        } else {
            this.clearOtherSortStates(null)
        }
    },
    getHeaderMenu                 : function() {
        var b = this.getMenu(), a;
        if (b) {
            a = b.child("#columnItem");
            if (a) {
                return a.menu
            }
        }
        return null
    },
    onHeaderVisibilityChange      : function(e, d) {
        var b = this, c = b.getHeaderMenu(), a;
        b.purgeCache();
        if (c) {
            a = b.getMenuItemForHeader(c, e);
            if (a) {
                a.setChecked(d, true)
            }
            if (c.isVisible()) {
                b.menuTask.delay(50)
            }
        }
    },
    updateMenuDisabledState       : function(g) {
        var f = this, d = f.query(":not([hidden])"), c, a = d.length, e, b, h;
        if (!g) {
            g = f.getMenu()
        }
        for (c = 0; c < a; ++c) {
            e = d[c];
            b = f.getMenuItemForHeader(g, e);
            if (b) {
                h = e.isHideable() ? "enable" : "disable";
                if (b.menu) {
                    h += "CheckChange"
                }
                b[h]()
            }
        }
    },
    getMenuItemForHeader          : function(a, b) {
        return b ? a.down("menucheckitem[headerId=" + b.id + "]") : null
    },
    onHeaderShow                  : function(c) {
        var b = this, a = b.ownerCt;
        if (b.forceFit) {
            delete b.flex
        }
        b.onHeaderVisibilityChange(c, true);
        if (!c.isGroupHeader) {
            if (a) {
                a.onHeaderShow(b, c)
            }
        }
        b.fireEvent("columnshow", b, c);
        b.fireEvent("columnschanged", this)
    },
    onHeaderHide                  : function(c) {
        var b = this, a = b.ownerCt;
        b.onHeaderVisibilityChange(c, false);
        if (!c.isGroupHeader) {
            if (a) {
                a.onHeaderHide(b, c)
            }
        }
        b.fireEvent("columnhide", b, c);
        b.fireEvent("columnschanged", this)
    },
    tempLock                      : function() {
        this.ddLock = true;
        Ext.Function.defer(function() {
            this.ddLock = false
        }, 200, this)
    },
    onHeaderResize                : function(f, b, e) {
        var d = this, a = d.view, c = d.ownerCt;
        if (a && a.body.dom) {
            d.tempLock();
            if (c) {
                c.onHeaderResize(d, f, b)
            }
        }
        d.fireEvent("columnresize", this, f, b)
    },
    onHeaderClick                 : function(c, b, a) {
        c.fireEvent("headerclick", this, c, b, a);
        this.fireEvent("headerclick", this, c, b, a)
    },
    onHeaderContextMenu           : function(c, b, a) {
        c.fireEvent("headercontextmenu", this, c, b, a);
        this.fireEvent("headercontextmenu", this, c, b, a)
    },
    onHeaderTriggerClick          : function(d, c, a) {
        var b = this;
        if (d.fireEvent("headertriggerclick", b, d, c, a) !== false && b.fireEvent("headertriggerclick", b, d, c, a) !== false) {
            b.showMenuBy(a, d)
        }
    },
    showMenuBy                    : function(b, f) {
        var d          = this.getMenu(), e = d.down("#ascItem"), c = d.down("#descItem"), a;
        d.activeHeader = d.ownerButton = f;
        f.setMenuActive(true);
        a = f.sortable ? "enable" : "disable";
        if (e) {
            e[a]()
        }
        if (c) {
            c[a]()
        }
        d.showBy(b)
    },
    onMenuHide                    : function(a) {
        a.activeHeader.setMenuActive(false)
    },
    moveHeader                    : function(a, b) {
        this.tempLock();
        this.onHeaderMoved(this.move(a, b), 1, a, b)
    },
    purgeCache                    : function() {
        var a             = this, b = a.menu;
        a.gridDataColumns = a.hideableColumns = null;
        if (a.columnManager) {
            a.columnManager.invalidate()
        }
        if (b && b.hidden) {
            b.hide();
            b.destroy();
            a.menu = null
        }
    },
    onHeaderMoved                 : function(f, a, c, e) {
        var d = this, b = d.ownerCt;
        if (b && b.onHeaderMove) {
            b.onHeaderMove(d, f, a, c, e)
        }
        d.fireEvent("columnmove", d, f, c, e)
    },
    getMenu                       : function() {
        var a = this;
        if (!a.menu) {
            a.menu = new Ext.menu.Menu({
                hideOnParentHide: false,
                items           : a.getMenuItems(),
                listeners       : {
                    hide : a.onMenuHide,
                    scope: a
                }
            });
            a.fireEvent("menucreate", a, a.menu)
        }
        a.updateMenuDisabledState(a.menu);
        return a.menu
    },
    getMenuItems                  : function() {
        var c = this, b = [], a = c.enableColumnHide ? c.getColumnMenu(c) : null;
        if (c.sortable) {
            b = [{
                itemId : "ascItem",
                text   : c.sortAscText,
                cls    : c.menuSortAscCls,
                handler: c.onSortAscClick,
                scope  : c
            }, {
                itemId : "descItem",
                text   : c.sortDescText,
                cls    : c.menuSortDescCls,
                handler: c.onSortDescClick,
                scope  : c
            }]
        }
        if (a && a.length) {
            if (c.sortable) {
                b.push("-")
            }
            b.push({
                itemId     : "columnItem",
                text       : c.columnsText,
                cls        : c.menuColsIcon,
                menu       : a,
                hideOnClick: false
            })
        }
        return b
    },
    onSortAscClick                : function() {
        var b = this.getMenu(), a = b.activeHeader;
        a.setSortState("ASC")
    },
    onSortDescClick               : function() {
        var b = this.getMenu(), a = b.activeHeader;
        a.setSortState("DESC")
    },
    getColumnMenu                 : function(f) {
        var c = [], b = 0, e, a = f.query(">gridcolumn[hideable]"), g = a.length, d;
        for (; b < g; b++) {
            e = a[b];
            d = new Ext.menu.CheckItem({
                text        : e.menuText || e.text,
                checked     : !e.hidden,
                hideOnClick : false,
                headerId    : e.id,
                menu        : e.isGroupHeader ? this.getColumnMenu(e) : undefined,
                checkHandler: this.onColumnCheckChange,
                scope       : this
            });
            c.push(d);
            e.on({destroy: Ext.Function.bind(d.destroy, d)})
        }
        return c
    },
    onColumnCheckChange           : function(a, b) {
        var c = Ext.getCmp(a.headerId);
        c[b ? "show" : "hide"]()
    },
    getColumnCount                : function() {
        return this.getGridColumns().length
    },
    getFullWidth                  : function() {
        var c = 0, b = this.getVisibleGridColumns(), e = b.length, a = 0, d;
        for (; a < e; a++) {
            d = b[a];
            if (d.getDesiredWidth) {
                c += d.getDesiredWidth() || 0
            } else {
                c += d.getWidth()
            }
        }
        return c
    },
    clearOtherSortStates          : function(a) {
        var c = this.getGridColumns(), d = c.length, b = 0;
        for (; b < d; b++) {
            if (c[b] !== a) {
                c[b].setSortState(null, true)
            }
        }
    },
    getVisibleGridColumns         : function() {
        var c = this.getGridColumns(), b = [], a = c.length, d;
        for (d = 0; d < a; d++) {
            if (!c[d].hidden) {
                b[b.length] = c[d]
            }
        }
        return b
    },
    getGridColumns                : function(g, a) {
        if (!g && this.gridDataColumns) {
            return this.gridDataColumns
        }
        var f = this, j = g || [], e, b, d, h, c;
        a     = a || f.hidden;
        if (f.items) {
            e = f.items.items;
            for (b = 0, d = e.length; b < d; b++) {
                h = e[b];
                if (h.isGroupHeader) {
                    h.getGridColumns(j, a)
                } else {
                    h.hiddenAncestor = a;
                    j.push(h)
                }
            }
        }
        if (!g) {
            f.gridDataColumns = j
        }
        if (!g && d) {
            for (b = 0, d = j.length; b < d; b++) {
                h                = j[b];
                h.isFirstVisible = h.isLastVisible = false;
                if (!(h.hidden || h.hiddenAncestor)) {
                    if (!c) {
                        h.isFirstVisible = true
                    }
                    c = h
                }
            }
            if (c) {
                c.isLastVisible = true
            }
        }
        return j
    },
    getHideableColumns            : function() {
        var b = this, a = b.hideableColumns;
        if (!a) {
            a = b.hideableColumns = b.query("[hideable]")
        }
        return a
    },
    getHeaderIndex                : function(a) {
        return this.columnManager.getHeaderIndex(a)
    },
    getHeaderAtIndex              : function(a) {
        return this.columnManager.getHeaderAtIndex(a)
    },
    getVisibleHeaderClosestToIndex: function(a) {
        return this.columnManager.getVisibleHeaderClosestToIndex(a)
    },
    autoSizeColumn                : function(b) {
        var a = this.view;
        if (a) {
            a.autoSizeColumn(b)
        }
    }
});
Ext.define("Ext.grid.column.Column", {
    extend                     : "Ext.grid.header.Container",
    alias                      : "widget.gridcolumn",
    requires                   : ["Ext.util.KeyNav", "Ext.grid.ColumnComponentLayout", "Ext.grid.ColumnLayout"],
    alternateClassName         : "Ext.grid.Column",
    baseCls                    : Ext.baseCSSPrefix + "column-header",
    hoverCls                   : Ext.baseCSSPrefix + "column-header-over",
    handleWidth                : 4,
    sortState                  : null,
    possibleSortStates         : ["ASC", "DESC"],
    childEls                   : ["titleEl", "triggerEl", "textEl"],
    noWrap                     : true,
    renderTpl                  : '<div id="{id}-titleEl" {tipMarkup}class="' + Ext.baseCSSPrefix + 'column-header-inner"><span id="{id}-textEl" class="' + Ext.baseCSSPrefix + 'column-header-text{childElCls}">{text}</span><tpl if="!menuDisabled"><div id="{id}-triggerEl" class="' + Ext.baseCSSPrefix + 'column-header-trigger{childElCls}"></div></tpl></div>{%this.renderContainer(out,values)%}',
    dataIndex                  : null,
    text                       : "&#160;",
    menuText                   : null,
    emptyCellText              : "&#160;",
    sortable                   : true,
    resizable                  : true,
    hideable                   : true,
    menuDisabled               : false,
    renderer                   : false,
    editRenderer               : false,
    align                      : "left",
    draggable                  : true,
    tooltipType                : "qtip",
    initDraggable              : Ext.emptyFn,
    tdCls                      : "",
    isHeader                   : true,
    isColumn                   : true,
    ascSortCls                 : Ext.baseCSSPrefix + "column-header-sort-ASC",
    descSortCls                : Ext.baseCSSPrefix + "column-header-sort-DESC",
    componentLayout            : "columncomponent",
    groupSubHeaderCls          : Ext.baseCSSPrefix + "group-sub-header",
    groupHeaderCls             : Ext.baseCSSPrefix + "group-header",
    clickTargetName            : "titleEl",
    detachOnRemove             : true,
    initResizable              : Ext.emptyFn,
    initComponent              : function() {
        var b = this, c, a;
        if (b.header != null) {
            b.text   = b.header;
            b.header = null
        }
        if (!b.triStateSort) {
            b.possibleSortStates.length = 2
        }
        if (b.columns != null) {
            b.isGroupHeader = true;
            b.items         = b.columns;
            b.columns       = b.flex = b.width = null;
            b.cls      = (b.cls || "") + " " + b.groupHeaderCls;
            b.sortable = b.resizable = false;
            b.align = "center"
        } else {
            if (b.flex) {
                b.minWidth = b.minWidth || Ext.grid.plugin.HeaderResizer.prototype.minColWidth
            }
        }
        b.addCls(Ext.baseCSSPrefix + "column-header-align-" + b.align);
        c = b.renderer;
        if (c) {
            if (typeof c == "string") {
                b.renderer = Ext.util.Format[c]
            }
            b.hasCustomRenderer = true
        } else {
            if (b.defaultRenderer) {
                b.scope    = b;
                b.renderer = b.defaultRenderer
            }
        }
        b.callParent(arguments);
        a = {
            element    : b.clickTargetName,
            click      : b.onTitleElClick,
            contextmenu: b.onTitleElContextMenu,
            mouseenter : b.onTitleMouseOver,
            mouseleave : b.onTitleMouseOut,
            scope      : b
        };
        if (b.resizable) {
            a.dblclick = b.onTitleElDblClick
        }
        b.on(a)
    },
    onAdd                      : function(a) {
        if (a.isColumn) {
            a.isSubHeader = true;
            a.addCls(this.groupSubHeaderCls)
        }
        if (this.hidden) {
            a.hide()
        }
        this.callParent(arguments)
    },
    onRemove                   : function(a) {
        if (a.isSubHeader) {
            a.isSubHeader = false;
            a.removeCls(this.groupSubHeaderCls)
        }
        this.callParent(arguments)
    },
    initRenderData             : function() {
        var b = this, d = "", c = b.tooltip, a = b.tooltipType == "qtip" ? "data-qtip" : "title";
        if (!Ext.isEmpty(c)) {
            d = a + '="' + c + '" '
        }
        return Ext.applyIf(b.callParent(arguments), {
            text        : b.text,
            menuDisabled: b.menuDisabled,
            tipMarkup   : d
        })
    },
    applyColumnState           : function(b) {
        var a = this;
        a.applyColumnsState(b.columns);
        if (b.hidden != null) {
            a.hidden = b.hidden
        }
        if (b.locked != null) {
            a.locked = b.locked
        }
        if (b.sortable != null) {
            a.sortable = b.sortable
        }
        if (b.width != null) {
            a.flex  = null;
            a.width = b.width
        } else {
            if (b.flex != null) {
                a.width = null;
                a.flex  = b.flex
            }
        }
    },
    getColumnState             : function() {
        var e = this, b = e.items.items, a = b ? b.length : 0, d, c = [], f = {id: e.getStateId()};
        e.savePropsToState(["hidden", "sortable", "locked", "flex", "width"], f);
        if (e.isGroupHeader) {
            for (d = 0; d < a; d++) {
                c.push(b[d].getColumnState())
            }
            if (c.length) {
                f.columns = c
            }
        } else {
            if (e.isSubHeader && e.ownerCt.hidden) {
                delete e.hidden
            }
        }
        if ("width" in f) {
            delete f.flex
        }
        return f
    },
    getStateId                 : function() {
        return this.stateId || this.headerId
    },
    setText                    : function(a) {
        this.text = a;
        if (this.rendered) {
            this.textEl.update(a)
        }
    },
    getIndex                   : function() {
        return this.isGroupColumn ? false : this.getOwnerHeaderCt().getHeaderIndex(this)
    },
    getVisibleIndex            : function() {
        return this.isGroupColumn ? false : Ext.Array.indexOf(this.getOwnerHeaderCt().getVisibleGridColumns(), this)
    },
    beforeRender               : function() {
        var b = this, a = b.up("tablepanel");
        b.callParent();
        if (a && (!b.sortable || a.sortableColumns === false) && !b.groupable && !b.lockable && (a.enableColumnHide === false || !b.getOwnerHeaderCt().getHideableColumns().length)) {
            b.menuDisabled = true
        }
        b.protoEl.unselectable()
    },
    afterRender                : function() {
        var b = this, a = b.triggerEl, c;
        b.callParent(arguments);
        if (!Ext.isIE8 || !Ext.isStrict) {
            b.mon(b.getFocusEl(), {
                focus: b.onTitleMouseOver,
                blur : b.onTitleMouseOut,
                scope: b
            })
        }
        if (a && b.self.triggerElWidth === undefined) {
            a.setStyle("display", "block");
            b.self.triggerElWidth = a.getWidth();
            a.setStyle("display", "")
        }
        b.keyNav = new Ext.util.KeyNav(b.el, {
            enter: b.onEnterKey,
            down : b.onDownKey,
            scope: b
        })
    },
    afterComponentLayout       : function(d, a, c, f) {
        var e = this, b = e.getOwnerHeaderCt();
        e.callParent(arguments);
        if (b && (c != null || e.flex) && d !== c) {
            b.onHeaderResize(e, d, true)
        }
    },
    onDestroy                  : function() {
        var a = this;
        Ext.destroy(a.textEl, a.keyNav, a.field);
        a.keyNav = null;
        a.callParent(arguments)
    },
    onTitleMouseOver           : function() {
        this.titleEl.addCls(this.hoverCls)
    },
    onTitleMouseOut            : function() {
        this.titleEl.removeCls(this.hoverCls)
    },
    onDownKey                  : function(a) {
        if (this.triggerEl) {
            this.onTitleElClick(a, this.triggerEl.dom || this.el.dom)
        }
    },
    onEnterKey                 : function(a) {
        this.onTitleElClick(a, this.el.dom)
    },
    onTitleElDblClick          : function(f, a) {
        var c = this, b, d;
        if (c.isOnLeftEdge(f)) {
            b = c.previousNode("gridcolumn:not([hidden]):not([isGroupHeader])");
            if (b && b.getOwnerHeaderCt() === c.getOwnerHeaderCt()) {
                b.autoSize()
            }
        } else {
            if (c.isOnRightEdge(f)) {
                if (c.isGroupHeader && f.getPoint().isContainedBy(c.layout.innerCt)) {
                    d = c.query("gridcolumn:not([hidden]):not([isGroupHeader])");
                    this.getOwnerHeaderCt().autoSizeColumn(d[d.length - 1]);
                    return
                }
                c.autoSize()
            }
        }
    },
    autoSize                   : function() {
        var b = this, c, e, a, d;
        if (b.isGroupHeader) {
            c = b.query("gridcolumn:not([hidden]):not([isGroupHeader])");
            e = c.length;
            d = this.getOwnerHeaderCt();
            Ext.suspendLayouts();
            for (a = 0; a < e; a++) {
                d.autoSizeColumn(c[a])
            }
            Ext.resumeLayouts(true);
            return
        }
        this.getOwnerHeaderCt().autoSizeColumn(this)
    },
    onTitleElClick             : function(d, b) {
        var c = this, a = c.getOwnerHeaderCt();
        if (a && !a.ddLock) {
            if (c.triggerEl && (d.target === c.triggerEl.dom || b === c.triggerEl.dom || d.within(c.triggerEl))) {
                a.onHeaderTriggerClick(c, d, b)
            } else {
                if (d.getKey() || (!c.isOnLeftEdge(d) && !c.isOnRightEdge(d))) {
                    c.toggleSortState();
                    a.onHeaderClick(c, d, b)
                }
            }
        }
    },
    onTitleElContextMenu       : function(d, b) {
        var c = this, a = c.getOwnerHeaderCt();
        if (a && !a.ddLock) {
            a.onHeaderContextMenu(c, d, b)
        }
    },
    processEvent               : function(f, b, a, c, d, g) {
        return this.fireEvent.apply(this, arguments)
    },
    toggleSortState            : function() {
        var b = this, a, c;
        if (b.sortable) {
            a = Ext.Array.indexOf(b.possibleSortStates, b.sortState);
            c = (a + 1) % b.possibleSortStates.length;
            b.setSortState(b.possibleSortStates[c])
        }
    },
    doSort                     : function(c) {
        var b = this.up("tablepanel"), a = b.store;
        if (b.ownerLockable && a.isNodeStore) {
            a = b.ownerLockable.lockedGrid.store
        }
        a.sort({
            property : this.getSortParam(),
            direction: c
        })
    },
    getSortParam               : function() {
        return this.dataIndex
    },
    setSortState               : function(f, e, c) {
        var d = this, g = d.ascSortCls, b = d.descSortCls, a = d.getOwnerHeaderCt(), h = d.sortState;
        f     = f || null;
        if (!d.sorting && h !== f && (d.getSortParam() != null)) {
            if (f && !c) {
                d.sorting = true;
                d.doSort(f);
                d.sorting = false
            }
            switch (f) {
                case"DESC":
                    d.addCls(b);
                    d.removeCls(g);
                    break;
                case"ASC":
                    d.addCls(g);
                    d.removeCls(b);
                    break;
                default:
                    d.removeCls([g, b])
            }
            if (a && !d.triStateSort && !e) {
                a.clearOtherSortStates(d)
            }
            d.sortState = f;
            if (d.triStateSort || f != null) {
                a.fireEvent("sortchange", a, d, f)
            }
        }
    },
    isHideable                 : function() {
        var a = {
            hideCandidate: this,
            result       : this.hideable
        };
        if (a.result) {
            this.ownerCt.bubble(this.hasOtherMenuEnabledChildren, null, [a])
        }
        return a.result
    },
    hasOtherMenuEnabledChildren: function(a) {
        var b, c;
        if (!this.isXType("headercontainer")) {
            a.result = false;
            return false
        }
        b = this.query(">:not([hidden]):not([menuDisabled])");
        c = b.length;
        if (Ext.Array.contains(b, a.hideCandidate)) {
            c--
        }
        if (c) {
            return false
        }
        a.hideCandidate = this
    },
    isLockable                 : function() {
        var a = {result: this.lockable !== false};
        if (a.result) {
            this.ownerCt.bubble(this.hasMultipleVisibleChildren, null, [a])
        }
        return a.result
    },
    isLocked                   : function() {
        return this.locked || !!this.up("[isColumn][locked]", "[isRootHeader]")
    },
    hasMultipleVisibleChildren : function(a) {
        if (!this.isXType("headercontainer")) {
            a.result = false;
            return false
        }
        if (this.query(">:not([hidden])").length > 1) {
            return false
        }
    },
    hide                       : function(c) {
        var h = this, e = h.getOwnerHeaderCt(), b = h.ownerCt, a, j, g, f, d;
        if (!h.isVisible()) {
            return h
        }
        if (!e) {
            h.callParent();
            return h
        }
        if (e.forceFit) {
            h.visibleSiblingCount = e.getVisibleGridColumns().length - 1;
            if (h.flex) {
                h.savedWidth = h.getWidth();
                h.flex       = null
            }
        }
        a = b.isGroupHeader;
        if (a && !c) {
            g = b.query(">:not([hidden])");
            if (g.length === 1 && g[0] == h) {
                h.ownerCt.hide();
                return
            }
        }
        Ext.suspendLayouts();
        if (h.isGroupHeader) {
            g = h.items.items;
            for (d = 0, f = g.length; d < f; d++) {
                j = g[d];
                if (!j.hidden) {
                    j.hide(true)
                }
            }
        }
        h.callParent();
        e.onHeaderHide(h);
        Ext.resumeLayouts(true);
        return h
    },
    show                       : function(f, g) {
        var m = this, j = m.getOwnerHeaderCt(), d = m.ownerCt, l, k, h, n, b, a, e, c, o = Ext.grid.header.Container.prototype.defaultWidth;
        if (m.isVisible()) {
            return m
        }
        if (!m.rendered) {
            m.hidden = false;
            return
        }
        a = j.el.getViewSize().width - (j.view.el.dom.scrollHeight > j.view.el.dom.clientHeight ? Ext.getScrollbarSize().width : 0);
        if (j.forceFit) {
            l = Ext.ComponentQuery.query(":not([flex])", j.getVisibleGridColumns());
            if (l.length) {
                m.width = m.savedWidth || m.width || o
            } else {
                l       = j.getVisibleGridColumns();
                k       = l.length;
                c       = m.visibleSiblingCount;
                b       = (m.savedWidth || m.width || o);
                b       = Math.min(b * (c / k), o, Math.max(a - (k * o), o));
                m.width = null;
                m.flex  = b;
                a -= b;
                e       = 0;
                for (h = 0; h < k; h++) {
                    n       = l[h];
                    n.flex  = (n.width || n.getWidth());
                    e += n.flex;
                    n.width = null
                }
                for (h = 0; h < k; h++) {
                    n      = l[h];
                    n.flex = n.flex / e * a
                }
            }
        }
        Ext.suspendLayouts();
        if (m.isSubHeader && d.hidden) {
            d.show(false, true)
        }
        m.callParent(arguments);
        if (m.isGroupHeader && g !== true && !m.query(":not([hidden])").length) {
            l = m.items.items;
            for (h = 0, k = l.length; h < k; h++) {
                n = l[h];
                if (n.hidden) {
                    n.show(true)
                }
            }
        }
        Ext.resumeLayouts(true);
        d = m.getOwnerHeaderCt();
        if (d) {
            d.onHeaderShow(m)
        }
    },
    getDesiredWidth            : function() {
        var a = this;
        if (a.rendered && a.componentLayout && a.componentLayout.lastComponentSize) {
            return a.componentLayout.lastComponentSize.width
        } else {
            if (a.flex) {
                return a.width
            } else {
                return a.width
            }
        }
    },
    getCellSelector            : function() {
        return "." + Ext.baseCSSPrefix + "grid-cell-" + this.getItemId()
    },
    getCellInnerSelector       : function() {
        return this.getCellSelector() + " ." + Ext.baseCSSPrefix + "grid-cell-inner"
    },
    isOnLeftEdge               : function(a) {
        return (a.getXY()[0] - this.getX() <= this.handleWidth)
    },
    isOnRightEdge              : function(a) {
        return (this.getX() + this.getWidth() - a.getXY()[0] <= this.handleWidth)
    },
    setMenuActive              : function(a) {
        this.titleEl[a ? "addCls" : "removeCls"](this.headerOpenCls)
    }
});
Ext.define("Ext.grid.column.RowNumberer", {
    extend            : "Ext.grid.column.Column",
    alternateClassName: "Ext.grid.RowNumberer",
    alias             : "widget.rownumberer",
    text              : "&#160",
    width             : 23,
    sortable          : false,
    draggable         : false,
    autoLock          : true,
    lockable          : false,
    align             : "right",
    constructor       : function(a) {
        var b   = this;
        b.width = b.width;
        b.callParent(arguments);
        b.scope = b
    },
    resizable         : false,
    hideable          : false,
    menuDisabled      : true,
    dataIndex         : "",
    cls               : Ext.baseCSSPrefix + "row-numberer",
    tdCls             : Ext.baseCSSPrefix + "grid-cell-row-numberer " + Ext.baseCSSPrefix + "grid-cell-special",
    innerCls          : Ext.baseCSSPrefix + "grid-cell-inner-row-numberer",
    rowspan           : undefined,
    renderer          : function(g, a, e, b, d, h) {
        var c = this.rowspan, f = h.currentPage, i = e.index;
        if (c) {
            a.tdAttr = 'rowspan="' + c + '"'
        }
        if (i == null) {
            i = b;
            if (f > 1) {
                i += (f - 1) * h.pageSize
            }
        }
        return i + 1
    }
});
Ext.define("ExtThemeNeptune.grid.column.RowNumberer", {
    override: "Ext.grid.column.RowNumberer",
    width   : 25
});
Ext.define("Ext.grid.column.Template", {
    extend            : "Ext.grid.column.Column",
    alias             : ["widget.templatecolumn"],
    requires          : ["Ext.XTemplate"],
    alternateClassName: "Ext.grid.TemplateColumn",
    initComponent     : function() {
        var a               = this;
        a.tpl               = (!Ext.isPrimitive(a.tpl) && a.tpl.compile) ? a.tpl : new Ext.XTemplate(a.tpl);
        a.hasCustomRenderer = true;
        a.callParent(arguments)
    },
    defaultRenderer   : function(c, d, a) {
        var b = Ext.apply({}, a.data, a.getAssociatedData());
        return this.tpl.apply(b)
    }
});
Ext.define("Ext.grid.feature.Feature", {
    extend          : "Ext.util.Observable",
    alias           : "feature.feature",
    wrapsItem       : false,
    isFeature       : true,
    disabled        : false,
    hasFeatureEvent : true,
    eventPrefix     : null,
    eventSelector   : null,
    view            : null,
    grid            : null,
    constructor     : function(a) {
        this.initialConfig = a;
        this.callParent(arguments)
    },
    clone           : function() {
        return new this.self(this.initialConfig)
    },
    init            : Ext.emptyFn,
    destroy         : function() {
        this.clearListeners()
    },
    getFireEventArgs: function(b, a, c, d) {
        return [b, a, c, d]
    },
    vetoEvent       : Ext.emptyFn,
    enable          : function() {
        this.disabled = false
    },
    disable         : function() {
        this.disabled = true
    }
});
Ext.define("Ext.grid.feature.AbstractSummary", {
    extend              : "Ext.grid.feature.Feature",
    alias               : "feature.abstractsummary",
    summaryRowCls       : Ext.baseCSSPrefix + "grid-row-summary",
    summaryTableCls     : Ext.plainTableCls + " " + Ext.baseCSSPrefix + "grid-table",
    summaryRowSelector  : "." + Ext.baseCSSPrefix + "grid-row-summary",
    summaryRowTpl       : {
        before  : function(a, b) {
            if (a.record.isSummary) {
                this.summaryFeature.outputSummaryRecord(a.record, a, b);
                return false
            }
        },
        priority: 1000
    },
    showSummaryRow      : true,
    init                : function() {
        var a                                            = this;
        a.view.summaryFeature                            = a;
        a.rowTpl                                         = a.view.self.prototype.rowTpl;
        a.view.addRowTpl(a.summaryRowTpl).summaryFeature = a
    },
    toggleSummaryRow    : function(a) {
        this.showSummaryRow = !!a
    },
    outputSummaryRecord : function(f, k, d) {
        var g = k.view, a = g.rowValues, c = k.columns || g.headerCt.getVisibleGridColumns(), j = c.length, e, b, h = {
            view       : g,
            record     : f,
            rowStyle   : "",
            rowClasses : [this.summaryRowCls],
            itemClasses: [],
            recordIndex: -1,
            rowId      : g.getRowId(f),
            columns    : c
        };
        for (e = 0; e < j; e++) {
            b               = c[e];
            b.savedRenderer = b.renderer;
            if (b.summaryRenderer) {
                b.renderer = b.summaryRenderer
            } else {
                if (!b.summaryType) {
                    b.renderer = Ext.emptyFn
                }
            }
            if (!b.dataIndex) {
                b.dataIndex = b.id
            }
        }
        g.rowValues = h;
        g.self.prototype.rowTpl.applyOut(h, d);
        g.rowValues = a;
        for (e = 0; e < j; e++) {
            b               = c[e];
            b.renderer      = b.savedRenderer;
            b.savedRenderer = null
        }
    },
    getSummary          : function(b, c, e, d) {
        var a = d.records;
        if (c) {
            if (Ext.isFunction(c)) {
                return b.getAggregate(c, null, a, [e])
            }
            switch (c) {
                case"count":
                    return a.length;
                case"min":
                    return b.getMin(a, e);
                case"max":
                    return b.getMax(a, e);
                case"sum":
                    return b.getSum(a, e);
                case"average":
                    return b.getAverage(a, e);
                default:
                    return ""
            }
        }
    },
    generateSummaryData : function() {
        var k = this, n = k.view.store, c = n.groups.items, g = n.proxy.reader, h = c.length, a = k.getGroupField(), e = {}, j = k.lockingPartner, d, o, f, l, q, b, p, m;
        if (k.remoteRoot && g.rawData) {
            b      = true;
            m      = {};
            l      = g.root;
            g.root = k.remoteRoot;
            g.buildExtractors(true);
            q = g.getRoot(g.rawData) || [];
            h = q.length;
            if (!g.convertRecordData) {
                g.buildExtractors()
            }
            for (d = 0; d < h; ++d) {
                p = {};
                g.convertRecordData(p, q[d]);
                m[p[a]] = p
            }
            g.root = l;
            g.buildExtractors(true)
        }
        for (d = 0; d < h; ++d) {
            o = c[d];
            if (b || o.isDirty() || !o.hasAggregate()) {
                if (b) {
                    f = k.populateRemoteRecord(o, m)
                } else {
                    f = k.populateRecord(o)
                }
                if (!j || (k.view.ownerCt === k.view.ownerCt.ownerLockable.normalGrid)) {
                    o.commit()
                }
            } else {
                f = o.getAggregateRecord()
            }
            e[o.key] = f
        }
        return e
    },
    populateRemoteRecord: function(e, c) {
        var a = e.getAggregateRecord(true), b = c[e.key], d;
        a.beginEdit();
        for (d in b) {
            if (b.hasOwnProperty(d)) {
                if (d !== a.idProperty) {
                    a.set(d, b[d])
                }
            }
        }
        a.endEdit(true);
        a.commit(true);
        return a
    },
    populateRecord      : function(j) {
        var f = this, g = f.grid.ownerLockable ? f.grid.ownerLockable.view : f.view, h = f.view.store, d = j.getAggregateRecord(), b = g.headerCt.getGridColumns(), e = b.length, c, a, k;
        d.beginEdit();
        for (c = 0; c < e; ++c) {
            a = b[c];
            k = a.dataIndex || a.id;
            d.set(k, f.getSummary(h, a.summaryType, k, j))
        }
        d.endEdit(true);
        d.commit();
        return d
    }
});
Ext.define("Ext.grid.feature.GroupStore", {
    extend             : "Ext.util.Observable",
    isStore            : true,
    constructor        : function(c, a) {
        var b = this;
        b.superclass.constructor.apply(b, arguments);
        b.groupingFeature = c;
        b.bindStore(a);
        b.processStore(a);
        b.view.dataSource = b
    },
    bindStore          : function(a) {
        var b = this;
        if (b.store) {
            Ext.destroy(b.storeListeners);
            b.store = null
        }
        if (a) {
            b.storeListeners = a.on({
                bulkremove : b.onBulkRemove,
                add        : b.onAdd,
                update     : b.onUpdate,
                refresh    : b.onRefresh,
                clear      : b.onClear,
                scope      : b,
                destroyable: true
            });
            b.store          = a
        }
    },
    processStore       : function(g) {
        var f = this, a = g.getGroups(), j = a.length, d, k, l, c = f.data, h = f.groupingFeature.groupCache, b = f.groupingFeature.clearGroupCache(), e = f.groupingFeature.startCollapsed;
        if (c) {
            c.clear()
        } else {
            c = f.data = new Ext.util.MixedCollection(false, Ext.data.Store.recordIdFn)
        }
        if (g.getCount()) {
            f.groupingFeature.startCollapsed = false;
            for (d = 0; d < j; d++) {
                k             = a[d];
                b[k.name]     = k;
                k.isCollapsed = e || (h[k.name] && h[k.name].isCollapsed);
                if (k.isCollapsed) {
                    k.placeholder = l = new g.model(null, "group-" + k.name + "-placeholder");
                    l.set(f.getGroupField(), k.name);
                    l.rows = l.children = k.children;
                    l.isCollapsedPlaceholder = true;
                    c.add(l)
                } else {
                    c.insert(f.data.length, k.children)
                }
            }
        }
    },
    isCollapsed        : function(a) {
        return this.groupingFeature.groupCache[a].isCollapsed
    },
    isInCollapsedGroup : function(a) {
        var b;
        if (this.store.isGrouped() && (b = this.groupingFeature.groupCache[a.get(this.getGroupField())])) {
            return b.isCollapsed || false
        }
        return false
    },
    getCount           : function() {
        return this.data.getCount()
    },
    getTotalCount      : function() {
        return this.data.getCount()
    },
    rangeCached        : function(b, a) {
        return a < this.getCount()
    },
    getRange           : function(d, b, c) {
        var a = this.data.getRange(d, b);
        if (c && c.callback) {
            c.callback.call(c.scope || this, a, d, b, c)
        }
        return a
    },
    getAt              : function(a) {
        return this.getRange(a, a)[0]
    },
    getById            : function(a) {
        return this.store.getById(a)
    },
    expandGroup        : function(c) {
        var b = this, a;
        if (typeof c === "string") {
            c = b.groupingFeature.groupCache[c]
        }
        if (c && c.children.length && (a = b.indexOf(c.children[0], true, true)) !== -1) {
            c.isCollapsed             = false;
            b.isExpandingOrCollapsing = 1;
            b.data.removeAt(a);
            b.fireEvent("bulkremove", b, [b.getGroupPlaceholder(c)], [a]);
            b.data.insert(a, c.children);
            b.fireEvent("add", b, c.children, a);
            b.fireEvent("groupexpand", b, c);
            b.isExpandingOrCollapsing = 0
        }
    },
    collapseGroup      : function(g) {
        var e = this, d, h, c, b, a, f;
        if (typeof g === "string") {
            g = e.groupingFeature.groupCache[g]
        }
        if (g && (a = g.children.length) && (d = e.indexOf(g.children[0], true)) !== -1) {
            g.isCollapsed             = true;
            e.isExpandingOrCollapsing = 2;
            e.data.removeRange(d, a);
            f = new Array(a);
            for (c = 0, b = d; c < a; c++, b++) {
                f[c] = b
            }
            e.fireEvent("bulkremove", e, g.children, f);
            e.data.insert(d, h = e.getGroupPlaceholder(g));
            e.fireEvent("add", e, [h], d);
            e.fireEvent("groupcollapse", e, g);
            e.isExpandingOrCollapsing = 0
        }
    },
    getGroupPlaceholder: function(a) {
        if (!a.placeholder) {
            var b = a.placeholder = new this.store.model(null, "group-" + a.name + "-placeholder");
            b.set(this.getGroupField(), a.name);
            b.rows = b.children = a.children;
            b.isCollapsedPlaceholder = true
        }
        return a.placeholder
    },
    indexOf            : function(d, h, b) {
        var e = this, a, g, c, j, f, k = 0;
        if (d && (b || !e.isInCollapsedGroup(d))) {
            a = e.store.getGroups();
            g = a.length;
            for (c = 0; c < g; c++) {
                j = a[c];
                if (j.name === this.store.getGroupString(d)) {
                    f = Ext.Array.indexOf(j.children, d);
                    return k + f
                }
                k += (h && e.isCollapsed(j.name)) ? 1 : j.children.length
            }
        }
        return -1
    },
    indexOfTotal       : function(a) {
        var b = a.index;
        if (b || b === 0) {
            return b
        }
        return this.istore.ndexOf(a)
    },
    onRefresh          : function(a) {
        this.processStore(this.store);
        this.fireEvent("refresh", this)
    },
    onBulkRemove       : function(b, a, c) {
        this.processStore(this.store);
        this.fireEvent("refresh", this)
    },
    onClear            : function(b, a, c) {
        this.processStore(this.store);
        this.fireEvent("clear", this)
    },
    onAdd              : function(b, a, c) {
        this.processStore(this.store);
        this.fireEvent("refresh", this)
    },
    onUpdate           : function(c, a, b, g) {
        var f = this, d = f.groupingFeature.getRecordGroup(a), h, e;
        if (c.isGrouped()) {
            if (g && Ext.Array.contains(g, f.groupingFeature.getGroupField())) {
                return f.onRefresh(f.store)
            }
            if (d.isCollapsed) {
                f.fireEvent("update", f, d.placeholder)
            } else {
                Ext.suspendLayouts();
                f.fireEvent("update", f, a, b, g);
                h = d.children[0];
                e = d.children[d.children.length - 1];
                if (h !== a) {
                    f.fireEvent("update", f, h, "edit")
                }
                if (e !== a && e !== h) {
                    f.fireEvent("update", f, e, "edit")
                }
                Ext.resumeLayouts(true)
            }
        } else {
            f.fireEvent("update", f, a, b, g)
        }
    }
});
Ext.define("Ext.grid.feature.Grouping", {
    extend                    : "Ext.grid.feature.Feature",
    mixins                    : {summary: "Ext.grid.feature.AbstractSummary"},
    requires                  : ["Ext.grid.feature.GroupStore"],
    alias                     : "feature.grouping",
    eventPrefix               : "group",
    groupCls                  : Ext.baseCSSPrefix + "grid-group-hd",
    eventSelector             : "." + Ext.baseCSSPrefix + "grid-group-hd",
    refreshData               : {},
    groupInfo                 : {},
    wrapsItem                 : true,
    groupHeaderTpl            : "{columnName}: {name}",
    depthToIndent             : 17,
    collapsedCls              : Ext.baseCSSPrefix + "grid-group-collapsed",
    hdCollapsedCls            : Ext.baseCSSPrefix + "grid-group-hd-collapsed",
    hdNotCollapsibleCls       : Ext.baseCSSPrefix + "grid-group-hd-not-collapsible",
    collapsibleCls            : Ext.baseCSSPrefix + "grid-group-hd-collapsible",
    ctCls                     : Ext.baseCSSPrefix + "group-hd-container",
    groupByText               : "Group by this field",
    showGroupsText            : "Show in groups",
    hideGroupedHeader         : false,
    startCollapsed            : false,
    enableGroupingMenu        : true,
    enableNoGroups            : true,
    collapsible               : true,
    expandTip                 : "Click to expand. CTRL key collapses all others",
    collapseTip               : "Click to collapse. CTRL/click collapses all others",
    showSummaryRow            : false,
    tableTpl                  : {
        before  : function(a) {
            if (this.groupingFeature.disabled || a.rows.length === 1 && a.rows[0].isSummary) {
                return
            }
            this.groupingFeature.setup(a.rows, a.view.rowValues)
        },
        after   : function(a) {
            if (this.groupingFeature.disabled || a.rows.length === 1 && a.rows[0].isSummary) {
                return
            }
            this.groupingFeature.cleanup(a.rows, a.view.rowValues)
        },
        priority: 200
    },
    groupTpl                  : ["{%", "var me = this.groupingFeature;", "if (me.disabled) {", "values.needsWrap = false;", "} else {", "me.setupRowData(values.record, values.recordIndex, values);", "values.needsWrap = !me.disabled && (values.isFirstRow || values.summaryRecord);", "}", "%}", '<tpl if="needsWrap">', '<tr data-boundView="{view.id}" data-recordId="{record.internalId}" data-recordIndex="{[values.isCollapsedGroup ? -1 : values.recordIndex]}"', 'class="{[values.itemClasses.join(" ")]} ' + Ext.baseCSSPrefix + 'grid-wrap-row<tpl if="!summaryRecord"> ' + Ext.baseCSSPrefix + 'grid-group-row</tpl>">', '<td class="' + Ext.baseCSSPrefix + 'group-hd-container" colspan="{columns.length}">', '<tpl if="isFirstRow">', "{%", 'var groupTitleStyle = (!values.view.lockingPartner || (values.view.ownerCt === values.view.ownerCt.ownerLockable.lockedGrid) || (values.view.lockingPartner.headerCt.getVisibleGridColumns().length === 0)) ? "" : "visibility:hidden";', "%}", '<div id="{groupId}" class="' + Ext.baseCSSPrefix + 'grid-group-hd {collapsibleCls}" tabIndex="0">', '<div class="' + Ext.baseCSSPrefix + 'grid-group-title" style="{[groupTitleStyle]}">', '{[values.groupHeaderTpl.apply(values.groupInfo, parent) || "&#160;"]}', "</div>", "</div>", "</tpl>", '<tpl if="summaryRecord || !isCollapsedGroup">', '<table class="', Ext.baseCSSPrefix, "{view.id}-table ", Ext.baseCSSPrefix, "grid-table", '<tpl if="summaryRecord"> ', Ext.baseCSSPrefix, 'grid-table-summary</tpl>"', 'border="0" cellspacing="0" cellpadding="0" style="width:100%">', "{[values.view.renderColumnSizer(out)]}", '<tpl if="!isCollapsedGroup">', "{%", "values.itemClasses.length = 0;", "this.nextTpl.applyOut(values, out, parent);", "%}", "</tpl>", '<tpl if="summaryRecord">', "{%me.outputSummaryRecord(values.summaryRecord, values, out);%}", "</tpl>", "</table>", "</tpl>", "</td>", "</tr>", "<tpl else>", "{%this.nextTpl.applyOut(values, out, parent);%}", "</tpl>", {
        priority      : 200,
        syncRowHeights: function(d, i) {
            d     = Ext.fly(d, "syncDest");
            i     = Ext.fly(i, "sycSrc");
            var b = this.owner, e = d.down(b.eventSelector, true), f, g = d.down(b.summaryRowSelector, true), c, a, h;
            if (e && (f = i.down(b.eventSelector, true))) {
                e.style.height = f.style.height = "";
                if ((a = e.offsetHeight) > (h = f.offsetHeight)) {
                    Ext.fly(f).setHeight(a)
                } else {
                    if (h > a) {
                        Ext.fly(e).setHeight(h)
                    }
                }
            }
            if (g && (c = i.down(b.summaryRowSelector, true))) {
                g.style.height = c.style.height = "";
                if ((a = g.offsetHeight) > (h = c.offsetHeight)) {
                    Ext.fly(c).setHeight(a)
                } else {
                    if (h > a) {
                        Ext.fly(g).setHeight(h)
                    }
                }
            }
        },
        syncContent   : function(b, g) {
            b     = Ext.fly(b, "syncDest");
            g     = Ext.fly(g, "sycSrc");
            var a = this.owner, d = b.down(a.eventSelector, true), c = g.down(a.eventSelector, true), f = b.down(a.summaryRowSelector, true), e = g.down(a.summaryRowSelector, true);
            if (d && c) {
                Ext.fly(d).syncContent(c)
            }
            if (f && e) {
                Ext.fly(f).syncContent(e)
            }
        }
    }],
    constructor               : function() {
        this.groupCache = {};
        this.callParent(arguments)
    },
    init                      : function(b) {
        var c        = this, a = c.view;
        a.isGrouping = true;
        if (c.lockingPartner && c.lockingPartner.groupCache) {
            c.groupCache = c.lockingPartner.groupCache
        }
        c.mixins.summary.init.call(c);
        c.callParent(arguments);
        a.headerCt.on({
            columnhide: c.onColumnHideShow,
            columnshow: c.onColumnHideShow,
            columnmove: c.onColumnMove,
            scope     : c
        });
        a.addTableTpl(c.tableTpl).groupingFeature                        = c;
        a.addRowTpl(Ext.XTemplate.getTpl(c, "groupTpl")).groupingFeature = c;
        a.preserveScrollOnRefresh                                        = true;
        if (a.store.buffered) {
            c.collapsible = false
        } else {
            if (this.lockingPartner && this.lockingPartner.dataSource) {
                c.dataSource = a.dataSource = this.lockingPartner.dataSource
            } else {
                c.dataSource = a.dataSource = new Ext.grid.feature.GroupStore(c, a.store)
            }
        }
        c.grid.on({reconfigure: c.onReconfigure});
        a.on({
            afterrender: c.afterViewRender,
            scope      : c,
            single     : true
        })
    },
    clearGroupCache           : function() {
        var b = this, a = b.groupCache = {};
        if (b.lockingPartner) {
            b.lockingPartner.groupCache = a
        }
        return a
    },
    vetoEvent                 : function(a, c, d, b) {
        if (b.type !== "mouseover" && b.type !== "mouseout" && b.type !== "mouseenter" && b.type !== "mouseleave" && b.getTarget(this.eventSelector)) {
            return false
        }
    },
    enable                    : function() {
        var c            = this, a = c.view, b = a.store, d;
        c.lastGroupField = c.getGroupField();
        a.isGrouping     = true;
        if (c.lastGroupIndex) {
            c.block();
            b.group(c.lastGroupIndex);
            c.unblock()
        }
        c.callParent();
        d = c.view.headerCt.getMenu().down("#groupToggleMenuItem");
        if (d) {
            d.setChecked(true, true)
        }
        c.refreshIf()
    },
    disable                   : function() {
        var d        = this, a = d.view, b = a.store, e, c;
        a.isGrouping = false;
        c            = b.groupers.first();
        if (c) {
            d.lastGroupIndex = c.property;
            d.block();
            b.clearGrouping();
            d.unblock()
        }
        d.callParent();
        e = d.view.headerCt.getMenu().down("#groupToggleMenuItem");
        if (e) {
            e.setChecked(false, true)
        }
        d.refreshIf()
    },
    refreshIf                 : function() {
        var b = this.grid.ownerCt, a = this.view;
        if (!a.store.remoteGroup && !this.blockRefresh) {
            if (b && b.lockable) {
                b.view.refresh()
            } else {
                a.refresh()
            }
        }
    },
    afterViewRender           : function() {
        var b = this, a = b.view;
        a.on({
            scope     : b,
            groupclick: b.onGroupClick
        });
        if (b.enableGroupingMenu) {
            b.injectGroupingMenu()
        }
        b.pruneGroupedHeader();
        b.lastGroupField = b.getGroupField();
        b.block();
        b.onGroupChange();
        b.unblock()
    },
    injectGroupingMenu        : function() {
        var a          = this, b = a.view.headerCt;
        b.showMenuBy   = a.showMenuBy;
        b.getMenuItems = a.getMenuItems()
    },
    onColumnHideShow          : function(c, f) {
        var j = this.view, b = j.headerCt, a = b.getMenu(), e = a.down("#groupMenuItem"), k = b.getGridColumns().length, h, g, d;
        if (e) {
            if (b.getVisibleGridColumns().length > 1) {
                e.enable()
            } else {
                e.disable()
            }
        }
        if (j.rendered) {
            h = j.el.query("." + this.ctCls);
            for (d = 0, g = h.length; d < g; ++d) {
                h[d].colSpan = k
            }
        }
    },
    onColumnMove              : function() {
        var g = this, c = g.view.store, b, e, a, d, h, f;
        if (c.isGrouped()) {
            b = c.getGroups();
            a = b.length;
            for (e = 0; e < a; e++) {
                d = b[e];
                h = d.children[0];
                f = d.children[d.children.length - 1];
                c.fireEvent("update", c, h, "edit", null);
                if (f !== h) {
                    c.fireEvent("update", c, f, "edit", null)
                }
            }
        }
    },
    showMenuBy                : function(b, g) {
        var f = this.getMenu(), c = f.down("#groupMenuItem"), a = g.groupable === false || this.view.headerCt.getVisibleGridColumns().length < 2 ? "disable" : "enable", e = f.down("#groupToggleMenuItem"), d = this.view.store.isGrouped();
        c[a]();
        if (e) {
            e.setChecked(d, true);
            e[d ? "enable" : "disable"]()
        }
        Ext.grid.header.Container.prototype.showMenuBy.apply(this, arguments)
    },
    getMenuItems              : function() {
        var f = this, c = f.groupByText, e = f.disabled || !f.getGroupField(), a = f.showGroupsText, d = f.enableNoGroups, b = f.view.headerCt.getMenuItems;
        return function() {
            var g = b.call(this);
            g.push("-", {
                iconCls: Ext.baseCSSPrefix + "group-by-icon",
                itemId : "groupMenuItem",
                text   : c,
                handler: f.onGroupMenuItemClick,
                scope  : f
            });
            if (d) {
                g.push({
                    itemId      : "groupToggleMenuItem",
                    text        : a,
                    checked     : !e,
                    checkHandler: f.onGroupToggleMenuItemClick,
                    scope       : f
                })
            }
            return g
        }
    },
    onGroupMenuItemClick      : function(c, f) {
        var d            = this, g = c.parentMenu, h = g.activeHeader, a = d.view, b = a.store;
        d.lastGroupIndex = null;
        d.block();
        d.enable();
        b.group(h.dataIndex);
        d.pruneGroupedHeader();
        d.unblock();
        d.refreshIf()
    },
    block                     : function(a) {
        this.blockRefresh = this.view.blockRefresh = true;
        if (this.lockingPartner && !a) {
            this.lockingPartner.block(true)
        }
    },
    unblock                   : function(a) {
        this.blockRefresh = this.view.blockRefresh = false;
        if (this.lockingPartner && !a) {
            this.lockingPartner.unblock(true)
        }
    },
    onGroupToggleMenuItemClick: function(a, b) {
        this[b ? "enable" : "disable"]()
    },
    pruneGroupedHeader        : function() {
        var a = this, b = a.getGroupedHeader();
        if (a.hideGroupedHeader && b) {
            Ext.suspendLayouts();
            if (a.prunedHeader && a.prunedHeader !== b) {
                a.prunedHeader.show()
            }
            a.prunedHeader = b;
            b.hide();
            Ext.resumeLayouts(true)
        }
    },
    getHeaderNode             : function(a) {
        return Ext.get(this.createGroupId(a))
    },
    getGroup                  : function(b) {
        var a = this.groupCache, c = a[b];
        if (!c) {
            c = a[b] = {isCollapsed: false}
        }
        return c
    },
    isExpanded                : function(a) {
        return !this.getGroup(a).isCollapsed
    },
    expand                    : function(b, a) {
        this.doCollapseExpand(false, b, a)
    },
    expandAll                 : function() {
        var e = this, a = e.view, d = e.groupCache, f, c = e.lockingPartner, b;
        for (f in d) {
            if (d.hasOwnProperty(f)) {
                d[f].isCollapsed = false
            }
        }
        Ext.suspendLayouts();
        a.suspendEvent("beforerefresh", "refresh");
        if (c) {
            b = c.view;
            b.suspendEvent("beforerefresh", "refresh")
        }
        e.dataSource.onRefresh();
        a.resumeEvent("beforerefresh", "refresh");
        if (c) {
            b.resumeEvent("beforerefresh", "refresh")
        }
        Ext.resumeLayouts(true);
        for (f in d) {
            if (d.hasOwnProperty(f)) {
                e.afterCollapseExpand(false, f);
                if (c) {
                    c.afterCollapseExpand(false, f)
                }
            }
        }
    },
    collapse                  : function(b, a) {
        this.doCollapseExpand(true, b, a)
    },
    isAllCollapsed            : function() {
        var b = this, a = b.groupCache, c;
        for (c in a) {
            if (a.hasOwnProperty(c)) {
                if (!a[c].isCollapsed) {
                    return false
                }
            }
        }
        return true
    },
    isAllExpanded             : function() {
        var b = this, a = b.groupCache, c;
        for (c in a) {
            if (a.hasOwnProperty(c)) {
                if (a[c].isCollapsed) {
                    return false
                }
            }
        }
        return true
    },
    collapseAll               : function() {
        var e = this, a = e.view, d = e.groupCache, f, c = e.lockingPartner, b;
        for (f in d) {
            if (d.hasOwnProperty(f)) {
                d[f].isCollapsed = true
            }
        }
        Ext.suspendLayouts();
        a.suspendEvent("beforerefresh", "refresh");
        if (c) {
            b = c.view;
            b.suspendEvent("beforerefresh", "refresh")
        }
        e.dataSource.onRefresh();
        a.resumeEvent("beforerefresh", "refresh");
        if (c) {
            b.resumeEvent("beforerefresh", "refresh")
        }
        if (c && !c.isAllCollapsed()) {
            c.collapseAll()
        }
        Ext.resumeLayouts(true);
        for (f in d) {
            if (d.hasOwnProperty(f)) {
                e.afterCollapseExpand(true, f);
                if (c) {
                    c.afterCollapseExpand(true, f)
                }
            }
        }
    },
    doCollapseExpand          : function(e, f, a) {
        var c = this, b = c.lockingPartner, d = c.groupCache[f];
        if (d.isCollapsed != e) {
            Ext.suspendLayouts();
            if (e) {
                c.dataSource.collapseGroup(d)
            } else {
                c.dataSource.expandGroup(d)
            }
            Ext.resumeLayouts(true);
            c.afterCollapseExpand(e, f, a);
            if (b) {
                b.afterCollapseExpand(e, f, false)
            }
        }
    },
    afterCollapseExpand       : function(d, f, b) {
        var c = this, a = c.view, e;
        e     = Ext.get(this.getHeaderNode(f));
        a.fireEvent(d ? "groupcollapse" : "groupexpand", a, e, f);
        if (b) {
            e.up(a.getItemSelector()).scrollIntoView(a.el, null, true)
        }
    },
    onGroupChange             : function() {
        var d = this, e = d.getGroupField(), c, a, b;
        if (d.hideGroupedHeader) {
            if (d.lastGroupField) {
                c = d.getMenuItem(d.lastGroupField);
                if (c) {
                    c.setChecked(true)
                }
            }
            if (e) {
                a = d.view.headerCt.getVisibleGridColumns();
                b = ((a.length === 1) && (a[0].dataIndex == e));
                c = d.getMenuItem(e);
                if (c && !b) {
                    c.setChecked(false)
                }
            }
        }
        d.refreshIf();
        d.lastGroupField = e
    },
    getMenuItem               : function(b) {
        var a = this.view, d = a.headerCt.down("gridcolumn[dataIndex=" + b + "]"), c = a.headerCt.getMenu();
        return d ? c.down("menuitem[headerId=" + d.id + "]") : null
    },
    onGroupKey                : function(c, b) {
        var a = this, d = a.getGroupName(b.target);
        if (d) {
            a.onGroupClick(a.view, b.target, d, b)
        }
    },
    onGroupClick              : function(a, h, j, i) {
        var f = this, d = f.groupCache, b = !f.isExpanded(j), c;
        if (f.collapsible) {
            if (i.ctrlKey) {
                Ext.suspendLayouts();
                for (c in d) {
                    if (c === j) {
                        if (b) {
                            f.expand(j)
                        }
                    } else {
                        f.doCollapseExpand(true, c, false)
                    }
                }
                Ext.resumeLayouts(true);
                return
            }
            if (b) {
                f.expand(j)
            } else {
                f.collapse(j)
            }
        }
    },
    setupRowData              : function(h, k, m) {
        var i              = this, e = i.refreshData, b = i.groupInfo, g = e.header, c = e.groupField, j = i.view.dataSource, a, l, d, f;
        m.isCollapsedGroup = false;
        m.summaryRecord    = null;
        if (e.doGrouping) {
            a = i.view.store.groupers.first();
            if (h.children) {
                l            = a.getGroupString(h.children[0]);
                m.isFirstRow = m.isLastRow = true;
                m.itemClasses.push(i.hdCollapsedCls);
                m.isCollapsedGroup = true;
                m.groupInfo        = b;
                b.groupField       = c;
                b.name             = l;
                b.groupValue       = h.children[0].get(c);
                b.columnName       = g ? g.text : c;
                m.collapsibleCls   = i.collapsible ? i.collapsibleCls : i.hdNotCollapsibleCls;
                m.groupId          = i.createGroupId(l);
                b.rows             = b.children = h.children;
                if (i.showSummaryRow) {
                    m.summaryRecord = e.summaryData[l]
                }
                return
            }
            l            = a.getGroupString(h);
            m.isFirstRow = k === 0;
            if (!m.isFirstRow) {
                d = j.getAt(k - 1);
                if (d) {
                    m.isFirstRow = !d.isEqual(a.getGroupString(d), l)
                }
            }
            m.isLastRow = k == j.getTotalCount() - 1;
            if (!m.isLastRow) {
                f = j.getAt(k + 1);
                if (f) {
                    m.isLastRow = !f.isEqual(a.getGroupString(f), l)
                }
            }
            if (m.isFirstRow) {
                b.groupField     = c;
                b.name           = l;
                b.groupValue     = h.get(c);
                b.columnName     = g ? g.text : c;
                m.collapsibleCls = i.collapsible ? i.collapsibleCls : i.hdNotCollapsibleCls;
                m.groupId        = i.createGroupId(l);
                if (!i.isExpanded(l)) {
                    m.itemClasses.push(i.hdCollapsedCls);
                    m.isCollapsedGroup = true
                }
                if (j.buffered) {
                    b.rows = b.children = []
                } else {
                    b.rows = b.children = i.getRecordGroup(h).children
                }
                m.groupInfo = b
            }
            if (m.isLastRow) {
                if (i.showSummaryRow) {
                    m.summaryRecord = e.summaryData[l]
                }
            }
        }
    },
    setup                     : function(d, e) {
        var b         = this, c = b.refreshData, a = !b.disabled && b.view.store.isGrouped();
        b.skippedRows = 0;
        if (e.view.bufferedRenderer) {
            e.view.bufferedRenderer.variableRowHeight = true
        }
        c.groupField     = b.getGroupField();
        c.header         = b.getGroupedHeader(c.groupField);
        c.doGrouping     = a;
        e.groupHeaderTpl = Ext.XTemplate.getTpl(b, "groupHeaderTpl");
        if (a && b.showSummaryRow) {
            c.summaryData = b.generateSummaryData()
        }
    },
    cleanup                   : function(b, c) {
        var a       = this.refreshData;
        c.groupInfo = c.groupHeaderTpl = c.isFirstRow = null;
        a.groupField = a.header = null
    },
    getGroupName              : function(b) {
        var d = this, a = d.view, c = d.eventSelector, e, g, f;
        g     = Ext.fly(b).findParent(c);
        if (!g) {
            f = Ext.fly(b).findParent(a.itemSelector);
            if (f) {
                g = f.down(c, true)
            }
        }
        if (g) {
            e = g.id.split(a.id + "-hd-");
            if (e.length === 2) {
                return Ext.htmlDecode(e[1])
            }
        }
    },
    getRecordGroup            : function(a) {
        var b = this.view.store.groupers.first();
        if (b) {
            return this.groupCache[b.getGroupString(a)]
        }
    },
    createGroupId             : function(a) {
        return this.view.id + "-hd-" + Ext.htmlEncode(a)
    },
    createGroupCls            : function(a) {
        return this.view.id + "-" + Ext.htmlEncode(a) + "-item"
    },
    getGroupField             : function() {
        return this.view.store.getGroupField()
    },
    getGroupedHeader          : function(b) {
        var d = this, e = d.view.headerCt, c = d.lockingPartner, a, f;
        b     = b || this.getGroupField();
        if (b) {
            a = "[dataIndex=" + b + "]";
            f = e.down(a);
            if (!f && c) {
                f = c.view.headerCt.down(a)
            }
        }
        return f || null
    },
    getFireEventArgs          : function(b, a, d, c) {
        return [b, a, d, this.getGroupName(d), c]
    },
    destroy                   : function() {
        var a  = this, b = a.dataSource;
        a.view = a.prunedHeader = a.grid = a.groupCache = a.dataSource = null;
        a.callParent();
        if (b) {
            b.bindStore(null)
        }
    },
    onReconfigure             : function(d, a, c, f, b) {
        var e = d;
        if (a && a !== f) {
            if (a.buffered !== f.buffered) {
                Ext.Error.raise("Cannot reconfigure grouping switching between buffered and non-buffered stores")
            }
            if (a.buffered) {
                e.bindStore(a);
                e.dataSource.processStore(a)
            }
        }
    }
});
Ext.define("Ext.grid.feature.RowBody", {
    extend           : "Ext.grid.feature.Feature",
    alias            : "feature.rowbody",
    rowBodyCls       : Ext.baseCSSPrefix + "grid-row-body",
    rowBodyHiddenCls : Ext.baseCSSPrefix + "grid-row-body-hidden",
    rowBodyTdSelector: "td." + Ext.baseCSSPrefix + "grid-cell-rowbody",
    eventPrefix      : "rowbody",
    eventSelector    : "tr." + Ext.baseCSSPrefix + "grid-rowbody-tr",
    tableTpl         : {
        before  : function(b, c) {
            var a = b.view, d = a.rowValues;
            this.rowBody.setup(b.rows, d)
        },
        after   : function(b, c) {
            var a = b.view, d = a.rowValues;
            this.rowBody.cleanup(b.rows, d)
        },
        priority: 100
    },
    extraRowTpl      : ["{%", "values.view.rowBodyFeature.setupRowData(values.record, values.recordIndex, values);", "this.nextTpl.applyOut(values, out, parent);", "%}", '<tr class="' + Ext.baseCSSPrefix + 'grid-rowbody-tr {rowBodyCls}">', '<td class="' + Ext.baseCSSPrefix + 'grid-cell-rowbody" colspan="{rowBodyColspan}">', '<div class="' + Ext.baseCSSPrefix + 'grid-rowbody {rowBodyDivCls}">{rowBody}</div>', "</td>", "</tr>", {
        priority      : 100,
        syncRowHeights: function(f, c) {
            var a = this.owner, b = Ext.fly(f).down(a.eventSelector, true), g, d, e;
            if (b && (g = Ext.fly(c).down(a.eventSelector, true))) {
                if ((d = b.offsetHeight) > (e = g.offsetHeight)) {
                    Ext.fly(g).setHeight(d)
                } else {
                    if (e > d) {
                        Ext.fly(b).setHeight(e)
                    }
                }
            }
        },
        syncContent   : function(b, e) {
            var a = this.owner, c = Ext.fly(b).down(a.eventSelector, true), d;
            if (c && (d = Ext.fly(e).down(a.eventSelector, true))) {
                Ext.fly(c).syncContent(d)
            }
        }
    }],
    init             : function(b) {
        var c            = this, a = c.view;
        a.rowBodyFeature = c;
        if (!a.findFeature("rowwrap")) {
            b.mon(a, {
                element  : "el",
                mousedown: c.onMouseDown,
                scope    : c
            });
            c.mon(b.getStore(), "remove", c.onStoreRemove, c)
        }
        a.headerCt.on({
            columnschanged: c.onColumnsChanged,
            scope         : c
        });
        a.addTableTpl(c.tableTpl).rowBody = c;
        a.addRowTpl(Ext.XTemplate.getTpl(this, "extraRowTpl"));
        c.callParent(arguments)
    },
    onStoreRemove    : function(b, d, c) {
        var a = this.view, e;
        if (a.rendered) {
            e = a.getNode(c);
            if (e) {
                e = Ext.fly(e).next(this.eventSelector);
                if (e) {
                    e.remove()
                }
            }
        }
    },
    onMouseDown      : function(c) {
        var b = this, a = c.getTarget(b.eventSelector);
        if (a && Ext.fly(a = a.previousSibling).is(b.view.getItemSelector())) {
            c.target = a;
            b.view.handleEvent(c)
        }
    },
    getSelectedRow   : function(a, c) {
        var b = a.getNode(c, false);
        if (b) {
            return Ext.fly(b).down(this.eventSelector)
        }
        return null
    },
    onColumnsChanged : function(d) {
        var b = this.view.el.query(this.rowBodyTdSelector), e = d.getVisibleGridColumns().length, a = b.length, c;
        for (c = 0; c < a; ++c) {
            b[c].colSpan = e
        }
    },
    setupRowData     : function(a, c, b) {
        if (this.getAdditionalData) {
            Ext.apply(b, this.getAdditionalData(a.data, c, a, b))
        }
    },
    setup            : function(a, b) {
        b.rowBodyCls     = this.rowBodyCls;
        b.rowBodyColspan = b.view.getGridColumns().length
    },
    cleanup          : function(a, b) {
        b.rowBodyCls = b.rowBodyColspan = b.rowBody = null
    }
});
Ext.define("Ext.grid.feature.RowWrap", {
    extend          : "Ext.grid.feature.Feature",
    alias           : "feature.rowwrap",
    rowWrapTd       : "td." + Ext.baseCSSPrefix + "grid-rowwrap",
    hasFeatureEvent : false,
    tableTpl        : {
        before  : function(a, b) {
            if (a.view.bufferedRenderer) {
                a.view.bufferedRenderer.variableRowHeight = true
            }
        },
        priority: 200
    },
    wrapTpl         : ['<tr data-boundView="{view.id}" data-recordId="{record.internalId}" data-recordIndex="{recordIndex}" class="{[values.itemClasses.join(" ")]} ' + Ext.baseCSSPrefix + 'grid-wrap-row">', '<td class="' + Ext.baseCSSPrefix + "grid-rowwrap " + Ext.baseCSSPrefix + 'grid-td" colSpan="{columns.length}">', '<table class="' + Ext.baseCSSPrefix + "{view.id}-table " + Ext.baseCSSPrefix + 'grid-table" border="0" cellspacing="0" cellpadding="0">', "{[values.view.renderColumnSizer(out)]}", "{%", "values.itemClasses.length = 0;", "this.nextTpl.applyOut(values, out, parent)", "%}", "</table>", "</td>", "</tr>", {priority: 200}],
    init            : function(a) {
        var b = this;
        b.view.addTableTpl(b.tableTpl);
        b.view.addRowTpl(Ext.XTemplate.getTpl(b, "wrapTpl"));
        b.view.headerCt.on({
            columnhide: b.onColumnHideShow,
            columnshow: b.onColumnHideShow,
            scope     : b
        })
    },
    onColumnHideShow: function() {
        var b = this.view, c = b.el.query(this.rowWrapTd), e = b.headerCt.getVisibleGridColumns().length, a = c.length, d;
        for (d = 0; d < a; ++d) {
            c[d].colSpan = e
        }
    }
});
Ext.define("Ext.grid.locking.HeaderContainer", {
    extend           : "Ext.grid.header.Container",
    requires         : ["Ext.grid.ColumnManager"],
    constructor      : function(d) {
        var c      = this, a, b, g = [], f = d.lockedGrid, e = d.normalGrid;
        c.lockable = d;
        c.callParent();
        f.columnManager.rootColumns = e.columnManager.rootColumns = d.columnManager = c.columnManager = new Ext.grid.ColumnManager(f.headerCt, e.headerCt);
        a = f.headerCt.events;
        for (b in a) {
            if (a.hasOwnProperty(b)) {
                g.push(b)
            }
        }
        c.relayEvents(f.headerCt, g);
        c.relayEvents(e.headerCt, g)
    },
    getRefItems      : function() {
        return this.lockable.lockedGrid.headerCt.getRefItems().concat(this.lockable.normalGrid.headerCt.getRefItems())
    },
    getGridColumns   : function() {
        return this.lockable.lockedGrid.headerCt.getGridColumns().concat(this.lockable.normalGrid.headerCt.getGridColumns())
    },
    getColumnsState  : function() {
        var b = this, a = b.lockable.lockedGrid.headerCt.getColumnsState(), c = b.lockable.normalGrid.headerCt.getColumnsState();
        return a.concat(c)
    },
    applyColumnsState: function(g) {
        var o = this, e = o.lockable.lockedGrid, f = e.headerCt, m = o.lockable.normalGrid.headerCt, p = Ext.Array.toValueMap(f.items.items, "headerId"), h = Ext.Array.toValueMap(m.items.items, "headerId"), l = [], n = [], k = 1, b = g.length, j, a, d, c;
        for (j = 0; j < b; j++) {
            c = g[j];
            d = p[c.id];
            a = d || h[c.id];
            if (a) {
                if (a.applyColumnState) {
                    a.applyColumnState(c)
                }
                if (a.locked === undefined) {
                    a.locked = !!d
                }
                if (a.locked) {
                    l.push(a);
                    if (!a.hidden && typeof a.width == "number") {
                        k += a.width
                    }
                } else {
                    n.push(a)
                }
            }
        }
        if (l.length + n.length == f.items.getCount() + m.items.getCount()) {
            f.removeAll(false);
            m.removeAll(false);
            f.add(l);
            m.add(n);
            e.setWidth(k)
        }
    }
});
Ext.define("Ext.grid.locking.View", {
    alternateClassName: "Ext.grid.LockingView",
    mixins            : {observable: "Ext.util.Observable"},
    isLockingView     : true,
    eventRelayRe      : /^(beforeitem|beforecontainer|item|container|cell|refresh)/,
    constructor       : function(c) {
        var f = this, h = [], a = f.eventRelayRe, b = c.locked.getView(), g = c.normal.getView(), d, e;
        Ext.apply(f, {
            lockedView: b,
            normalView: g,
            lockedGrid: c.locked,
            normalGrid: c.normal,
            panel     : c.panel
        });
        f.mixins.observable.constructor.call(f, c);
        d = b.events;
        for (e in d) {
            if (d.hasOwnProperty(e) && a.test(e)) {
                h.push(e)
            }
        }
        f.relayEvents(b, h);
        f.relayEvents(g, h);
        g.on({
            scope         : f,
            itemmouseleave: f.onItemMouseLeave,
            itemmouseenter: f.onItemMouseEnter
        });
        b.on({
            scope         : f,
            itemmouseleave: f.onItemMouseLeave,
            itemmouseenter: f.onItemMouseEnter
        });
        f.panel.on({
            render: f.onPanelRender,
            scope : f
        })
    },
    onPanelRender     : function() {
        var c = this, b = c.loadMask, a = {
            target: c.panel,
            msg   : c.loadingText,
            msgCls: c.loadingCls,
            useMsg: c.loadingUseMsg,
            store : c.panel.store
        };
        c.el  = c.panel.body;
        c.fireEvent("render", c);
        if (b) {
            if (Ext.isObject(b)) {
                a = Ext.apply(a, b)
            }
            c.loadMask = new Ext.LoadMask(a)
        }
    },
    getGridColumns    : function() {
        var a = this.lockedGrid.headerCt.getVisibleGridColumns();
        return a.concat(this.normalGrid.headerCt.getVisibleGridColumns())
    },
    getEl             : function(a) {
        return this.getViewForColumn(a).getEl()
    },
    getViewForColumn  : function(b) {
        var a = this.lockedView, c;
        a.headerCt.cascade(function(d) {
            if (d === b) {
                c = true;
                return false
            }
        });
        return c ? a : this.normalView
    },
    onItemMouseEnter  : function(c, b) {
        var f = this, d = f.lockedView, a = f.normalView, e;
        if (c.trackOver) {
            if (c !== d) {
                a = d
            }
            e = a.getNode(b, false);
            a.highlightItem(e)
        }
    },
    onItemMouseLeave  : function(c, b) {
        var e = this, d = e.lockedView, a = e.normalView;
        if (c.trackOver) {
            if (c !== d) {
                a = d
            }
            a.clearHighlight()
        }
    },
    relayFn           : function(c, b) {
        b     = b || [];
        var a = this.lockedView;
        a[c].apply(a, b);
        a = this.normalView;
        a[c].apply(a, b)
    },
    getSelectionModel : function() {
        return this.panel.getSelectionModel()
    },
    getStore          : function() {
        return this.panel.store
    },
    getNode           : function(b, a) {
        return this.normalView.getNode(b, a)
    },
    getCell           : function(b, c) {
        var a = this.getViewForColumn(c), d = a.getNode(b, true);
        return Ext.fly(d).down(c.getCellSelector())
    },
    indexOf           : function(b) {
        var a = this.lockedView.indexOf(b);
        if (!a) {
            a = this.normalView.indexOf(b)
        }
        return a
    },
    focus             : function() {
        var b = this.getSelectionModel().getCurrentPosition(), a = b ? b.view : this.normalView;
        a.focus()
    },
    focusRow          : function(a) {
        this.normalView.focusRow(a)
    },
    focusCell         : function(a) {
        a.view.focusCell(a)
    },
    isVisible         : function(a) {
        return this.panel.isVisible(a)
    },
    getRecord         : function(b) {
        var a = this.lockedView.getRecord(b);
        if (!a) {
            a = this.normalView.getRecord(b)
        }
        return a
    },
    scrollBy          : function() {
        var a = this.normalView;
        a.scrollBy.apply(a, arguments)
    },
    addElListener     : function(a, c, b) {
        this.relayFn("addElListener", arguments)
    },
    refreshNode       : function() {
        this.relayFn("refreshNode", arguments)
    },
    refresh           : function() {
        this.relayFn("refresh", arguments)
    },
    bindStore         : function() {
        this.relayFn("bindStore", arguments)
    },
    addRowCls         : function() {
        this.relayFn("addRowCls", arguments)
    },
    removeRowCls      : function() {
        this.relayFn("removeRowCls", arguments)
    },
    destroy           : function() {
        var b = this, a = b.loadMask;
        b.clearListeners();
        if (a && a.bindStore) {
            a.bindStore(null)
        }
    }
});
Ext.define("Ext.grid.locking.Lockable", {
    alternateClassName       : "Ext.grid.Lockable",
    requires                 : ["Ext.grid.locking.View", "Ext.grid.header.Container", "Ext.grid.locking.HeaderContainer", "Ext.view.Table"],
    syncRowHeight            : true,
    headerCounter            : 0,
    scrollDelta              : 40,
    lockedGridCls            : Ext.baseCSSPrefix + "grid-inner-locked",
    unlockText               : "Unlock",
    lockText                 : "Lock",
    bothCfgCopy              : ["invalidateScrollerOnRefresh", "hideHeaders", "enableColumnHide", "enableColumnMove", "enableColumnResize", "sortableColumns", "columnLines", "rowLines"],
    normalCfgCopy            : ["verticalScroller", "verticalScrollDock", "verticalScrollerType", "scroll"],
    lockedCfgCopy            : [],
    determineXTypeToCreate   : function(e) {
        var c = this, g, d, b, f, a;
        if (c.subGridXType) {
            g = c.subGridXType
        } else {
            if (!e) {
                return "gridpanel"
            }
            d = this.getXTypes().split("/");
            b = d.length;
            f = d[b - 1];
            a = d[b - 2];
            if (a !== "tablepanel") {
                g = a
            } else {
                g = f
            }
        }
        return g
    },
    injectLockable           : function() {
        this.lockable = true;
        this.hasView  = true;
        var n         = this, a = Ext.getScrollbarSize().height, o = n.store = Ext.StoreManager.lookup(n.store), j = n.getSelectionModel(), k, b, e, l, g, d, c, h, q, f, m, p = n.findPlugin("bufferedrenderer");
        k                                                                                                          = n.constructLockableFeatures();
        if (n.features) {
            n.features = null
        }
        b         = n.constructLockablePlugins();
        n.plugins = b.topPlugins;
        e         = Ext.apply({
            id           : n.id + "-locked",
            isLocked     : true,
            ownerLockable: n,
            xtype        : n.determineXTypeToCreate(true),
            store        : o,
            scrollerOwner: false,
            animate      : false,
            scroll       : a ? false : "vertical",
            selModel     : j,
            border       : false,
            cls          : n.lockedGridCls,
            isLayoutRoot : function() {
                return false
            },
            features     : k.lockedFeatures,
            plugins      : b.lockedPlugins
        }, n.lockedGridConfig);
        l         = Ext.apply({
            id           : n.id + "-normal",
            isLocked     : false,
            ownerLockable: n,
            xtype        : n.determineXTypeToCreate(),
            store        : o,
            scrollerOwner: false,
            selModel     : j,
            border       : false,
            isLayoutRoot : function() {
                return false
            },
            features     : k.normalFeatures,
            plugins      : b.normalPlugins
        }, n.normalGridConfig);
        n.addCls(Ext.baseCSSPrefix + "grid-locked");
        Ext.copyTo(l, n, n.bothCfgCopy, true);
        Ext.copyTo(e, n, n.bothCfgCopy, true);
        Ext.copyTo(l, n, n.normalCfgCopy, true);
        Ext.copyTo(e, n, n.lockedCfgCopy, true);
        for (g = 0; g < n.normalCfgCopy.length; g++) {
            delete n[n.normalCfgCopy[g]]
        }
        for (g = 0; g < n.lockedCfgCopy.length; g++) {
            delete n[n.lockedCfgCopy[g]]
        }
        n.addEvents("processcolumns", "lockcolumn", "unlockcolumn");
        n.addStateEvents(["lockcolumn", "unlockcolumn"]);
        d                          = n.processColumns(n.columns);
        e.width                    = d.lockedWidth + Ext.num(j.headerWidth, 0) + (d.locked.items.length ? 1 : 0);
        e.columns                  = d.locked;
        l.columns                  = d.normal;
        l.flex                     = 1;
        e.viewConfig               = n.lockedViewConfig || {};
        e.viewConfig.loadingUseMsg = false;
        e.viewConfig.loadMask      = false;
        if (a) {
            e.viewConfig.style = "border-bottom:" + a + "px solid #f6f6f6;" + (e.viewConfig.style || "")
        }
        l.viewConfig          = n.normalViewConfig || {};
        l.viewConfig.loadMask = false;
        Ext.applyIf(e.viewConfig, n.viewConfig);
        Ext.applyIf(l.viewConfig, n.viewConfig);
        n.lockedGrid = Ext.ComponentManager.create(e);
        if (n.isTree) {
            n.lockedGrid.getView().animate = false;
            l.store                        = n.lockedGrid.view.store;
            l.deferRowRender               = false;
            l.viewConfig.stripeRows        = n.lockedGrid.view.stripeRows;
            l.rowLines                     = n.lockedGrid.rowLines
        }
        q                           = n.lockedGrid.getView();
        l.viewConfig.lockingPartner = q;
        n.normalGrid                = Ext.ComponentManager.create(l);
        q.lockingPartner            = f = n.normalGrid.getView();
        n.view = new Ext.grid.locking.View({
            loadingText  : f.loadingText,
            loadingCls   : f.loadingCls,
            loadingUseMsg: f.loadingUseMsg,
            loadMask     : n.loadMask !== false,
            locked       : n.lockedGrid,
            normal       : n.normalGrid,
            panel        : n
        });
        m      = p ? {} : {
            scroll: {
                fn     : n.onLockedViewScroll,
                element: "el",
                scope  : n
            }
        };
        if (a) {
            n.lockedGrid.on({
                afterlayout: n.afterLockedViewLayout,
                scope      : n
            });
            q.getOverflowStyle();
            if (q.scrollFlags.y) {
                n.lockedGrid.headerCt.forceFit = true
            } else {
                m.mousewheel = {
                    fn     : n.onLockedViewMouseWheel,
                    element: "el",
                    scope  : n
                }
            }
        }
        q.on(m);
        m = p ? {} : {
            scroll: {
                fn     : n.onNormalViewScroll,
                element: "el",
                scope  : n
            },
            scope : n
        };
        f.on(m);
        c          = n.lockedGrid.headerCt;
        h          = n.normalGrid.headerCt;
        n.headerCt = n.view.headerCt = new Ext.grid.locking.HeaderContainer(n);
        c.lockedCt         = true;
        c.lockableInjected = true;
        h.lockableInjected = true;
        c.on({
            add         : {
                buffer: 1,
                scope : n,
                fn    : n.onLockedHeaderAdd
            },
            columnshow  : n.onLockedHeaderShow,
            columnhide  : n.onLockedHeaderHide,
            sortchange  : n.onLockedHeaderSortChange,
            columnresize: n.onLockedHeaderResize,
            scope       : n
        });
        h.on({
            sortchange: n.onNormalHeaderSortChange,
            scope     : n
        });
        n.modifyHeaderCt();
        n.items = [n.lockedGrid, n.normalGrid];
        n.relayHeaderCtEvents(c);
        n.relayHeaderCtEvents(h);
        n.storeRelayers = n.relayEvents(o, ["filterchange"]);
        n.layout        = {
            type : "hbox",
            align: "stretch"
        }
    },
    getLockingViewConfig     : function() {
        return {
            xclass: "Ext.grid.locking.View",
            locked: this.lockedGrid,
            normal: this.normalGrid,
            panel : this
        }
    },
    processColumns           : function(c) {
        var e, g, b, j = this.dummyHdrCtr || (this.self.prototype.dummyHdrCtr = new Ext.grid.header.Container()), h = [], d = [], a = {
            itemId           : "lockedHeaderCt",
            stretchMaxPartner: "^^>>#normalHeaderCt",
            items            : h
        }, f           = {
            itemId           : "normalHeaderCt",
            stretchMaxPartner: "^^>>#lockedHeaderCt",
            items            : d
        }, k           = {
            lockedWidth: 0,
            locked     : a,
            normal     : f
        };
        if (Ext.isObject(c)) {
            Ext.applyIf(a, c);
            Ext.applyIf(f, c);
            Ext.apply(j, c);
            c = c.items
        }
        for (e = 0, g = c.length; e < g; ++e) {
            b = c[e];
            if (!b.isComponent) {
                b = j.lookupComponent(j.applyDefaults(b))
            }
            b.processed = true;
            if (b.locked || b.autoLock) {
                if (!b.hidden) {
                    k.lockedWidth += this.getColumnWidth(b) || j.defaultWidth
                }
                h.push(b)
            } else {
                d.push(b)
            }
            if (!b.headerId) {
                b.headerId = (b.initialConfig || b).id || ("h" + (++this.headerCounter))
            }
        }
        this.fireEvent("processcolumns", this, h, d);
        return k
    },
    getColumnWidth           : function(e) {
        var b = e.width || 0, d, a, c;
        if (!b && e.isGroupHeader) {
            d = e.items.items;
            a = d.length;
            for (c = 0; c < a; c++) {
                b += this.getColumnWidth(d[c])
            }
        }
        return b
    },
    afterLockedViewLayout    : function() {
        var c = this, b = c.lockedGrid.getView(), a = b.el.dom, d = (c.normalGrid.headerCt.tooNarrow ? Ext.getScrollbarSize().height : 0);
        if (b.scrollFlags.x && a.scrollWidth > a.clientWidth) {
            d = 0
        }
        b.el.dom.style.borderBottomWidth = d + "px";
        if (!Ext.isBorderBox) {
            b.el.setHeight(b.lastBox.height)
        }
    },
    onLockedViewMouseWheel   : function(h) {
        var d = this, g = -d.scrollDelta, a = g * h.getWheelDeltas().y, b = d.lockedGrid.getView().el.dom, c, f;
        if (!d.ignoreMousewheel) {
            if (b) {
                c = b.scrollTop !== b.scrollHeight - b.clientHeight;
                f = b.scrollTop !== 0
            }
            if ((a < 0 && f) || (a > 0 && c)) {
                h.stopEvent();
                b.scrollTop += a;
                d.normalGrid.getView().el.dom.scrollTop = b.scrollTop;
                d.onNormalViewScroll()
            }
        }
    },
    onLockedViewScroll       : function() {
        var e = this, d = e.lockedGrid.getView(), c = e.normalGrid.getView(), g = c.el.dom, f = d.el.dom, a, b;
        if (g.scrollTop !== f.scrollTop) {
            g.scrollTop = f.scrollTop;
            if (e.store.buffered) {
                b                = d.el.child("table", true);
                a                = c.el.child("table", true);
                a.style.position = "absolute";
                a.style.top      = b.style.top
            }
        }
    },
    onNormalViewScroll       : function() {
        var e = this, d = e.lockedGrid.getView(), c = e.normalGrid.getView(), g = c.el.dom, f = d.el.dom, a, b;
        if (g.scrollTop !== f.scrollTop) {
            f.scrollTop = g.scrollTop;
            if (e.store.buffered) {
                b                = d.el.child("table", true);
                a                = c.el.child("table", true);
                b.style.position = "absolute";
                b.style.top      = a.style.top
            }
        }
    },
    syncRowHeights           : function() {
        var e = this, a, d = e.lockedGrid.getView(), b = e.normalGrid.getView(), f = d.all.slice(), h = b.all.slice(), c = f.length, g;
        if (h.length === c) {
            for (a = 0; a < c; a++) {
                b.syncRowHeights(f[a], h[a])
            }
            g                  = b.el.dom.scrollTop;
            b.el.dom.scrollTop = g;
            d.el.dom.scrollTop = g
        }
    },
    modifyHeaderCt           : function() {
        var a                              = this;
        a.lockedGrid.headerCt.getMenuItems = a.getMenuItems(a.lockedGrid.headerCt.getMenuItems, true);
        a.normalGrid.headerCt.getMenuItems = a.getMenuItems(a.normalGrid.headerCt.getMenuItems, false);
        a.lockedGrid.headerCt.showMenuBy   = Ext.Function.createInterceptor(a.lockedGrid.headerCt.showMenuBy, a.showMenuBy);
        a.normalGrid.headerCt.showMenuBy   = Ext.Function.createInterceptor(a.normalGrid.headerCt.showMenuBy, a.showMenuBy)
    },
    onUnlockMenuClick        : function() {
        this.unlock()
    },
    onLockMenuClick          : function() {
        this.lock()
    },
    showMenuBy               : function(b, f) {
        var e = this.getMenu(), c = e.down("#unlockItem"), d = e.down("#lockItem"), a = c.prev();
        if (f.lockable === false) {
            a.hide();
            c.hide();
            d.hide()
        } else {
            a.show();
            c.show();
            d.show();
            if (!c.initialConfig.disabled) {
                c.setDisabled(f.lockable === false)
            }
            if (!d.initialConfig.disabled) {
                d.setDisabled(!f.isLockable())
            }
        }
    },
    getMenuItems             : function(f, c) {
        var g = this, h = g.unlockText, a = g.lockText, i = Ext.baseCSSPrefix + "hmenu-unlock", b = Ext.baseCSSPrefix + "hmenu-lock", e = Ext.Function.bind(g.onUnlockMenuClick, g), d = Ext.Function.bind(g.onLockMenuClick, g);
        return function() {
            var j = f.call(this);
            j.push("-", {
                itemId  : "unlockItem",
                cls     : i,
                text    : h,
                handler : e,
                disabled: !c
            });
            j.push({
                itemId  : "lockItem",
                cls     : b,
                text    : a,
                handler : d,
                disabled: c
            });
            return j
        }
    },
    syncLockedWidth          : function() {
        var e = this, b = e.lockedGrid, d = b.view, c = d.el.dom, g = e.normalGrid, f = b.headerCt.getVisibleGridColumns().length, a = g.headerCt.getVisibleGridColumns().length;
        Ext.suspendLayouts();
        if (a) {
            g.show();
            if (f) {
                if (!b.headerCt.forceFit) {
                    delete b.flex;
                    b.setWidth(b.headerCt.getFullWidth())
                }
                b.addCls(e.lockedGridCls);
                b.show()
            } else {
                b.getView().refresh();
                b.hide()
            }
            d.el.setStyle(d.getOverflowStyle());
            e.ignoreMousewheel = d.scrollFlags.y
        } else {
            g.hide();
            c.style.borderBottomWidth = "0";
            b.flex                    = 1;
            delete b.width;
            b.removeCls(e.lockedGridCls);
            b.show();
            d.el.setStyle(g.view.getOverflowStyle());
            e.ignoreMousewheel = true
        }
        Ext.resumeLayouts(true);
        return [f, a]
    },
    onLockedHeaderAdd        : function() {
        if (!this.ignoreAddLockedColumn) {
            this.syncLockedWidth()
        }
    },
    onLockedHeaderResize     : function() {
        this.syncLockedWidth()
    },
    onLockedHeaderHide       : function() {
        this.syncLockedWidth()
    },
    onLockedHeaderShow       : function() {
        this.syncLockedWidth()
    },
    onLockedHeaderSortChange : function(b, c, a) {
        if (a) {
            this.normalGrid.headerCt.clearOtherSortStates(null, true)
        }
    },
    onNormalHeaderSortChange : function(b, c, a) {
        if (a) {
            this.lockedGrid.headerCt.clearOtherSortStates(null, true)
        }
    },
    lock                     : function(c, i) {
        var e = this, d = e.normalGrid, b = e.lockedGrid, f = d.headerCt, g = b.headerCt, h, a;
        c     = c || f.getMenu().activeHeader;
        a     = c.ownerCt;
        if (!c.isLockable()) {
            return
        }
        if (c.flex) {
            c.width = c.getWidth();
            c.flex  = null
        }
        Ext.suspendLayouts();
        a.remove(c, false);
        c.locked                = true;
        e.ignoreAddLockedColumn = true;
        if (Ext.isDefined(i)) {
            g.insert(i, c)
        } else {
            g.add(c)
        }
        e.ignoreAddLockedColumn = false;
        h                       = e.syncLockedWidth();
        if (h[0]) {
            b.getView().refresh()
        }
        if (h[1]) {
            d.getView().refresh()
        }
        Ext.resumeLayouts(true);
        e.fireEvent("lockcolumn", e, c)
    },
    unlock                   : function(b, e) {
        var d = this, f = d.normalGrid, h = d.lockedGrid, g = f.headerCt, c = h.headerCt, a;
        if (!Ext.isDefined(e)) {
            e = 0
        }
        b = b || c.getMenu().activeHeader;
        Ext.suspendLayouts();
        b.ownerCt.remove(b, false);
        b.locked = false;
        g.insert(e, b);
        a = d.syncLockedWidth();
        if (a[0]) {
            h.getView().refresh()
        }
        if (a[1]) {
            f.getView().refresh()
        }
        Ext.resumeLayouts(true);
        d.fireEvent("unlockcolumn", d, b)
    },
    reconfigureLockable      : function(a, b) {
        var c = this, f = c.store, e = c.lockedGrid, d = c.normalGrid;
        Ext.suspendLayouts();
        if (b) {
            e.headerCt.removeAll();
            d.headerCt.removeAll();
            b                       = c.processColumns(b);
            c.ignoreAddLockedColumn = true;
            e.headerCt.add(b.locked.items);
            c.ignoreAddLockedColumn = false;
            d.headerCt.add(b.normal.items);
            c.syncLockedWidth()
        }
        if (a && a !== f) {
            a       = Ext.data.StoreManager.lookup(a);
            c.store = a;
            e.bindStore(a);
            d.bindStore(a)
        } else {
            e.getView().refresh();
            d.getView().refresh()
        }
        Ext.resumeLayouts(true)
    },
    constructLockableFeatures: function() {
        var e = this.features, c, d, f, g, b = 0, a;
        if (e) {
            f = [];
            g = [];
            a = e.length;
            for (; b < a; b++) {
                c = e[b];
                if (!c.isFeature) {
                    c = Ext.create("feature." + c.ftype, c)
                }
                switch (c.lockableScope) {
                    case"locked":
                        f.push(c);
                        break;
                    case"normal":
                        g.push(c);
                        break;
                    default:
                        c.lockableScope = "both";
                        f.push(c);
                        g.push(d = c.clone());
                        d.lockingPartner = c;
                        c.lockingPartner = d
                }
            }
        }
        return {
            normalFeatures: g,
            lockedFeatures: f
        }
    },
    constructLockablePlugins : function() {
        var c = this.plugins, f, b, a, h, j, d, e = 0, g;
        if (c) {
            h = [];
            j = [];
            d = [];
            g = c.length;
            for (; e < g; e++) {
                f = c[e];
                switch (f.lockableScope) {
                    case"both":
                        j.push(a = f.clonePlugin());
                        d.push(b = f.clonePlugin());
                        a.lockingPartner = b;
                        b.lockingPartner = a;
                        Ext.destroy(f);
                        break;
                    case"locked":
                        j.push(f);
                        break;
                    case"normal":
                        d.push(f);
                        break;
                    default:
                        h.push(f)
                }
            }
        }
        return {
            topPlugins   : h,
            normalPlugins: d,
            lockedPlugins: j
        }
    },
    destroyLockable          : function() {
        Ext.destroy(this.view)
    }
}, function() {
    this.borrow(Ext.AbstractComponent, ["constructPlugin"])
});
Ext.define("Ext.tree.View", {
    extend               : "Ext.view.Table",
    alias                : "widget.treeview",
    requires             : ["Ext.data.NodeStore"],
    isTreeView           : true,
    loadingCls           : Ext.baseCSSPrefix + "grid-tree-loading",
    expandedCls          : Ext.baseCSSPrefix + "grid-tree-node-expanded",
    leafCls              : Ext.baseCSSPrefix + "grid-tree-node-leaf",
    expanderSelector     : "." + Ext.baseCSSPrefix + "tree-expander",
    checkboxSelector     : "." + Ext.baseCSSPrefix + "tree-checkbox",
    expanderIconOverCls  : Ext.baseCSSPrefix + "tree-expander-over",
    nodeAnimWrapCls      : Ext.baseCSSPrefix + "tree-animator-wrap",
    blockRefresh         : true,
    loadMask             : false,
    rootVisible          : true,
    deferInitialRefresh  : false,
    expandDuration       : 250,
    collapseDuration     : 250,
    toggleOnDblClick     : true,
    stripeRows           : false,
    uiFields             : ["expanded", "loaded", "checked", "expandable", "leaf", "icon", "iconCls", "loading", "qtip", "qtitle"],
    treeRowTpl           : ["{%", "this.processRowValues(values);", "this.nextTpl.applyOut(values, out, parent);", 'delete values.rowAttr["data-qtip"];', 'delete values.rowAttr["data-qtitle"];', "%}", {
        priority        : 10,
        processRowValues: function(d) {
            var b     = d.record, a = d.view, e = b.get("qtip"), c = b.get("qttle");
            d.rowAttr = {};
            if (e) {
                d.rowAttr["data-qtip"] = e
            }
            if (c) {
                d.rowAttr["data-qtitle"] = c
            }
            if (b.isExpanded()) {
                d.rowClasses.push(a.expandedCls)
            }
            if (b.isLeaf()) {
                d.rowClasses.push(a.leafCls)
            }
            if (b.isLoading()) {
                d.rowClasses.push(a.loadingCls)
            }
        }
    }],
    initComponent        : function() {
        var b = this, c = b.panel.getStore(), a = b.store;
        if (b.initialConfig.animate === undefined) {
            b.animate = Ext.enableFx
        }
        if (!a || a === c) {
            b.store = a = new Ext.data.NodeStore({
                treeStore  : c,
                recursive  : true,
                rootVisible: b.rootVisible
            })
        }
        if (b.node) {
            b.setRootNode(b.node)
        }
        b.animQueue = {};
        b.animWraps = {};
        b.addEvents("afteritemexpand", "afteritemcollapse", "nodedragover");
        b.callParent(arguments);
        b.addRowTpl(Ext.XTemplate.getTpl(b, "treeRowTpl"))
    },
    onBeforeFill         : function(b, a) {
        this.store.suspendEvents()
    },
    onFillComplete       : function(e, d, b) {
        var c = this, a = c.store, f = a.indexOf(b[0]);
        a.resumeEvents();
        d.triggerUIUpdate();
        if (!b.length || f === -1) {
            return
        }
        c.onAdd(c.store, b, f);
        c.refreshPartner()
    },
    onBeforeSort         : function() {
        this.store.suspendEvents()
    },
    onSort               : function(a) {
        if (a.isStore) {
            this.store.resumeEvents();
            this.refresh();
            this.refreshPartner()
        }
    },
    refreshPartner       : function() {
        var a = this.lockingPartner;
        if (a) {
            a.refresh()
        }
    },
    getMaskStore         : function() {
        return this.panel.getStore()
    },
    afterRender          : function() {
        var a = this;
        a.callParent(arguments);
        a.el.on({
            scope    : a,
            delegate : a.expanderSelector,
            mouseover: a.onExpanderMouseOver,
            mouseout : a.onExpanderMouseOut,
            click    : {
                delegate: a.checkboxSelector,
                fn      : a.onCheckboxChange,
                scope   : a
            }
        })
    },
    afterComponentLayout : function() {
        this.callParent(arguments);
        var a = this.stretcher;
        if (a) {
            a.setWidth((this.getWidth() - Ext.getScrollbarSize().width))
        }
    },
    processUIEvent       : function(a) {
        if (a.getTarget("." + this.nodeAnimWrapCls, this.el)) {
            return false
        }
        return this.callParent(arguments)
    },
    onClear              : function() {
        this.store.removeAll()
    },
    setRootNode          : function(b) {
        var a = this;
        a.store.setNode(b);
        a.node = b
    },
    onCheckboxChange     : function(d, a) {
        var c = this, b = d.getTarget(c.getItemSelector(), c.getTargetEl());
        if (b) {
            c.onCheckChange(c.getRecord(b))
        }
    },
    onCheckChange        : function(a) {
        var b = a.get("checked");
        if (Ext.isBoolean(b)) {
            b = !b;
            a.set("checked", b);
            this.fireEvent("checkchange", a, b)
        }
    },
    getChecked           : function() {
        var a = [];
        this.node.cascadeBy(function(b) {
            if (b.get("checked")) {
                a.push(b)
            }
        });
        return a
    },
    isItemChecked        : function(a) {
        return a.get("checked")
    },
    createAnimWrap       : function(a, b) {
        var f = this, e = f.getNode(a), d, c, g = [];
        f.renderColumnSizer(g);
        c = Ext.get(e);
        d = c.insertSibling({
            tag : "tr",
            html: ['<td colspan="' + f.panel.headerCt.getColumnCount() + '">', '<div class="' + f.nodeAnimWrapCls + '">', '<table class="' + Ext.baseCSSPrefix + f.id + "-table " + Ext.baseCSSPrefix + 'grid-table" style="border:0" cellspacing="0" cellpadding="0">', g.join(""), "<tbody></tbody></table>", "</div>", "</td>"].join("")
        }, "after");
        return {
            record    : a,
            node      : e,
            el        : d,
            expanding : false,
            collapsing: false,
            animating : false,
            animateEl : d.down("div"),
            targetEl  : d.down("tbody")
        }
    },
    getAnimWrap          : function(d, a) {
        if (!this.animate) {
            return null
        }
        var b = this.animWraps, c = b[d.internalId];
        if (a !== false) {
            while (!c && d) {
                d = d.parentNode;
                if (d) {
                    c = b[d.internalId]
                }
            }
        }
        return c
    },
    doAdd                : function(c, g) {
        var h = this, a = h.bufferRender(c, g, true), e = c[0], i = e.parentNode, j = h.all, l, d = h.getAnimWrap(i), k, b, f;
        if (!d || !d.expanding) {
            return h.callParent(arguments)
        }
        i = d.record;
        k = d.targetEl;
        b = k.dom.childNodes;
        f = b.length;
        l = g - h.indexInStore(i) - 1;
        if (!f || l >= f) {
            k.appendChild(a)
        } else {
            Ext.fly(b[l]).insertSibling(a, "before", true)
        }
        j.insert(g, a);
        if (d.isAnimating) {
            h.onExpand(i)
        }
    },
    onRemove             : function(f, a, b) {
        var d = this, e, c;
        if (d.viewReady) {
            e = d.store.getCount() === 0;
            if (e) {
                d.refresh()
            } else {
                for (c = b.length - 1; c >= 0; --c) {
                    d.doRemove(a[c], b[c])
                }
            }
            if (d.hasListeners.itemremove) {
                for (c = b.length - 1; c >= 0; --c) {
                    d.fireEvent("itemremove", a[c], b[c])
                }
            }
        }
    },
    doRemove             : function(a, c) {
        var g = this, d = g.all, b = g.getAnimWrap(a), f = d.item(c), e = f ? f.dom : null;
        if (!e || !b || !b.collapsing) {
            return g.callParent(arguments)
        }
        b.targetEl.dom.insertBefore(e, b.targetEl.dom.firstChild);
        d.removeElement(c)
    },
    onBeforeExpand       : function(d, b, c) {
        var e = this, a;
        if (e.rendered && e.all.getCount() && e.animate) {
            if (e.getNode(d)) {
                a = e.getAnimWrap(d, false);
                if (!a) {
                    a = e.animWraps[d.internalId] = e.createAnimWrap(d);
                    a.animateEl.setHeight(0)
                } else {
                    if (a.collapsing) {
                        a.targetEl.select(e.itemSelector).remove()
                    }
                }
                a.expanding  = true;
                a.collapsing = false
            }
        }
    },
    onExpand             : function(i) {
        var h = this, f = h.animQueue, a = i.getId(), c = h.getNode(i), g = c ? h.indexOf(c) : -1, e, b, j, d = Ext.isIEQuirks ? 1 : 0;
        if (h.singleExpand) {
            h.ensureSingleExpand(i)
        }
        if (g === -1) {
            return
        }
        e = h.getAnimWrap(i, false);
        if (!e) {
            i.isExpandingOrCollapsing = false;
            h.fireEvent("afteritemexpand", i, g, c);
            h.refreshSize();
            return
        }
        b = e.animateEl;
        j = e.targetEl;
        b.stopAnimation();
        f[a]               = true;
        b.dom.style.height = d + "px";
        b.animate({
            from     : {height: d},
            to       : {height: j.getHeight()},
            duration : h.expandDuration,
            listeners: {
                afteranimate: function() {
                    var k = j.query(h.itemSelector);
                    if (k.length) {
                        e.el.insertSibling(k, "before", true)
                    }
                    e.el.remove();
                    h.refreshSize();
                    delete h.animWraps[e.record.internalId];
                    delete f[a]
                }
            },
            callback : function() {
                i.isExpandingOrCollapsing = false;
                h.fireEvent("afteritemexpand", i, g, c)
            }
        });
        e.isAnimating = true
    },
    onBeforeCollapse     : function(e, b, c, g, d) {
        var f = this, a;
        if (f.rendered && f.all.getCount()) {
            if (f.animate) {
                if (Ext.Array.contains(e.stores, f.store)) {
                    a = f.getAnimWrap(e);
                    if (!a) {
                        a = f.animWraps[e.internalId] = f.createAnimWrap(e, c)
                    } else {
                        if (a.expanding) {
                            a.targetEl.select(this.itemSelector).remove()
                        }
                    }
                    a.expanding  = false;
                    a.collapsing = true;
                    a.callback   = g;
                    a.scope      = d
                }
            } else {
                f.onCollapseCallback = g;
                f.onCollapseScope    = d
            }
        }
    },
    onCollapse           : function(d) {
        var f = this, a = f.animQueue, h = d.getId(), e = f.getNode(d), c = e ? f.indexOf(e) : -1, b = f.getAnimWrap(d), g;
        if (!f.all.getCount() || !Ext.Array.contains(d.stores, f.store)) {
            return
        }
        if (!b) {
            d.isExpandingOrCollapsing = false;
            f.fireEvent("afteritemcollapse", d, c, e);
            f.refreshSize();
            Ext.callback(f.onCollapseCallback, f.onCollapseScope);
            f.onCollapseCallback = f.onCollapseScope = null;
            return
        }
        g    = b.animateEl;
        a[h] = true;
        g.stopAnimation();
        g.animate({
            to       : {height: Ext.isIEQuirks ? 1 : 0},
            duration : f.collapseDuration,
            listeners: {
                afteranimate: function() {
                    b.el.remove();
                    f.refreshSize();
                    delete f.animWraps[b.record.internalId];
                    delete a[h]
                }
            },
            callback : function() {
                d.isExpandingOrCollapsing = false;
                f.fireEvent("afteritemcollapse", d, c, e);
                Ext.callback(b.callback, b.scope);
                b.callback = b.scope = null
            }
        });
        b.isAnimating = true
    },
    isAnimating          : function(a) {
        return !!this.animQueue[a.getId()]
    },
    expand               : function(d, c, g, e) {
        var f = this, b = !!f.animate, a;
        if (!b || !d.isExpandingOrCollapsing) {
            if (!d.isLeaf()) {
                d.isExpandingOrCollapsing = b
            }
            Ext.suspendLayouts();
            a = d.expand(c, g, e);
            Ext.resumeLayouts(true);
            return a
        }
    },
    collapse             : function(c, b, f, d) {
        var e = this, a = !!e.animate;
        if (!a || !c.isExpandingOrCollapsing) {
            if (!c.isLeaf()) {
                c.isExpandingOrCollapsing = a
            }
            return c.collapse(b, f, d)
        }
    },
    toggle               : function(b, a, d, c) {
        if (b.isExpanded()) {
            this.collapse(b, a, d, c)
        } else {
            this.expand(b, a, d, c)
        }
    },
    onItemDblClick       : function(a, e, c) {
        var d = this, b = d.editingPlugin;
        d.callParent(arguments);
        if (d.toggleOnDblClick && a.isExpandable() && !(b && b.clicksToEdit === 2)) {
            d.toggle(a)
        }
    },
    onBeforeItemMouseDown: function(a, c, b, d) {
        if (d.getTarget(this.expanderSelector, c)) {
            return false
        }
        return this.callParent(arguments)
    },
    onItemClick          : function(a, c, b, d) {
        if (d.getTarget(this.expanderSelector, c) && a.isExpandable()) {
            this.toggle(a, d.ctrlKey);
            return false
        }
        return this.callParent(arguments)
    },
    onExpanderMouseOver  : function(b, a) {
        b.getTarget(this.cellSelector, 10, true).addCls(this.expanderIconOverCls)
    },
    onExpanderMouseOut   : function(b, a) {
        b.getTarget(this.cellSelector, 10, true).removeCls(this.expanderIconOverCls)
    },
    getStoreListeners    : function() {
        var b = this, a = b.callParent(arguments);
        return Ext.apply(a, {
            beforeexpand  : b.onBeforeExpand,
            expand        : b.onExpand,
            beforecollapse: b.onBeforeCollapse,
            collapse      : b.onCollapse,
            write         : b.onStoreWrite,
            datachanged   : b.onStoreDataChanged
        })
    },
    onBindStore          : function() {
        var a = this, b = a.getTreeStore();
        a.callParent(arguments);
        a.mon(b, {
            scope       : a,
            beforefill  : a.onBeforeFill,
            fillcomplete: a.onFillComplete
        });
        if (!b.remoteSort) {
            a.mon(b, {
                scope     : a,
                beforesort: a.onBeforeSort,
                sort      : a.onSort
            })
        }
    },
    onUnbindStore        : function() {
        var a = this, b = a.getTreeStore();
        a.callParent(arguments);
        a.mun(b, {
            scope       : a,
            beforefill  : a.onBeforeFill,
            fillcomplete: a.onFillComplete
        });
        if (!b.remoteSort) {
            a.mun(b, {
                scope     : a,
                beforesort: a.onBeforeSort,
                sort      : a.onSort
            })
        }
    },
    getTreeStore         : function() {
        return this.panel.store
    },
    ensureSingleExpand   : function(b) {
        var a = b.parentNode;
        if (a) {
            a.eachChild(function(c) {
                if (c !== b && c.isExpanded()) {
                    c.collapse()
                }
            })
        }
    },
    shouldUpdateCell     : function(b, e, d) {
        if (d) {
            var c = 0, a = d.length;
            for (; c < a; ++c) {
                if (Ext.Array.contains(this.uiFields, d[c])) {
                    return true
                }
            }
        }
        return this.callParent(arguments)
    },
    onStoreWrite         : function(b, a) {
        var c = this.panel.store;
        c.fireEvent("write", c, a)
    },
    onStoreDataChanged   : function(b, a) {
        var c = this.panel.store;
        c.fireEvent("datachanged", c)
    }
});
Ext.define("Ext.grid.plugin.BufferedRendererTreeView", {
    override: "Ext.tree.View",
    onRemove: function(b, a, d) {
        var c = this;
        if (c.rendered && c.bufferedRenderer) {
            c.refreshView()
        } else {
            c.callParent([b, a, d])
        }
    }
});
Ext.define("Ext.grid.plugin.BufferedRenderer", {
    extend                 : "Ext.AbstractPlugin",
    requires               : ["Ext.grid.plugin.BufferedRendererTableView", "Ext.grid.plugin.BufferedRendererTreeView"],
    alias                  : "plugin.bufferedrenderer",
    lockableScope          : "both",
    percentageFromEdge     : 0.35,
    variableRowHeight      : false,
    numFromEdge            : 8,
    trailingBufferZone     : 10,
    leadingBufferZone      : 20,
    synchronousRender      : true,
    scrollToLoadBuffer     : 200,
    viewSize               : 0,
    rowHeight              : 21,
    position               : 0,
    lastScrollDirection    : 1,
    bodyTop                : 0,
    init                   : function(c) {
        var d = this, a = c.view, b = {
            scroll     : {
                fn     : d.onViewScroll,
                element: "el",
                scope  : d
            },
            boxready   : d.onViewResize,
            resize     : d.onViewResize,
            refresh    : d.onViewRefresh,
            scope      : d,
            destroyable: true
        };
        if (!d.variableRowHeight && c.ownerLockable) {
            c.ownerLockable.syncRowHeight = false
        }
        if (c.isTree || c.ownerLockable && c.ownerLockable.isTree) {
            a.blockRefresh = false;
            a.loadMask     = true
        }
        if (a.positionBody) {
            b.refresh = d.onViewRefresh
        }
        d.grid                    = c;
        d.view                    = a;
        a.bufferedRenderer        = d;
        a.preserveScrollOnRefresh = true;
        d.bindStore(a.dataSource);
        a.getViewRange  = function() {
            return d.getViewRange()
        };
        d.position      = 0;
        d.gridListeners = c.on("reconfigure", d.onReconfigure, d);
        d.viewListeners = a.on(b)
    },
    bindStore              : function(a) {
        var b = this;
        if (b.store) {
            b.unbindStore()
        }
        b.storeListeners = a.on({
            scope      : b,
            clear      : b.onStoreClear,
            destroyable: true
        });
        b.store          = a;
        if (b.view.componentLayout.layoutCount) {
            b.onViewResize(b.view, 0, b.view.getHeight())
        }
    },
    onReconfigure          : function(b, a) {
        if (a && a !== this.store) {
            this.bindStore(a)
        }
    },
    unbindStore            : function() {
        this.storeListeners.destroy();
        this.store = null
    },
    onStoreClear           : function() {
        var a = this;
        if (a.view.rendered && !a.store.isDestroyed) {
            if (a.scrollTop !== 0) {
                a.ignoreNextScrollEvent = true;
                a.view.el.dom.scrollTop = a.bodyTop = a.scrollTop = 0
            }
            a.position = a.scrollHeight = 0;
            a.lastScrollDirection = a.scrollOffset = null;
            delete a.rowHeight
        }
    },
    onViewRefresh          : function() {
        var c = this, a = c.view, d = c.scrollHeight, b;
        if (a.all.getCount()) {
            delete c.rowHeight
        }
        b = c.getScrollHeight();
        if (!d || b != d) {
            c.stretchView(a, b)
        }
        if (c.scrollTop !== a.el.dom.scrollTop) {
            c.onViewScroll()
        } else {
            c.setBodyTop(c.bodyTop);
            if (a.all.getCount()) {
                c.viewSize = 0;
                c.onViewResize(a, null, a.getHeight())
            }
        }
    },
    onViewResize           : function(c, e, a, b, g) {
        if (!g || a !== g) {
            var f      = this, d;
            d          = Math.ceil(a / f.rowHeight) + f.trailingBufferZone + f.leadingBufferZone;
            f.viewSize = f.setViewSize(d)
        }
    },
    stretchView            : function(b, a) {
        var e = this, d = (e.store.buffered ? e.store.getTotalCount() : e.store.getCount());
        if (e.stretcher) {
            e.stretcher.dom.style.marginTop = (a - 1) + "px"
        } else {
            var c = b.el;
            if (b.refreshCounter) {
                b.fixedNodes++
            }
            if (d && (e.view.all.endIndex === d - 1)) {
                a = e.bodyTop + b.body.dom.offsetHeight
            }
            this.stretcher = c.createChild({
                style: {
                    width    : "1px",
                    height   : "1px",
                    marginTop: (a - 1) + "px",
                    left     : 0,
                    position : "absolute"
                }
            }, c.dom.firstChild)
        }
    },
    setViewSize            : function(g) {
        if (g !== this.viewSize) {
            this.scrollTop = this.view.el.dom.scrollTop;
            var e          = this, b = e.store, d = e.view.all.getCount(), f, a, c = e.lockingPartner;
            e.viewSize     = b.viewSize = g;
            if (d) {
                f = e.view.all.startIndex;
                a = Math.min(f + g - 1, (b.buffered ? b.getTotalCount() : b.getCount()) - 1);
                if (c) {
                    c.disable()
                }
                e.renderRange(f, a);
                if (c) {
                    c.enable()
                }
            }
        }
        return g
    },
    getViewRange           : function() {
        var b = this, c = b.view.all, a = b.store;
        if (a.data.getCount()) {
            return a.getRange(c.startIndex, c.startIndex + (b.viewSize || b.store.defaultViewSize) - 1)
        } else {
            return []
        }
    },
    scrollTo               : function(i, c, l, n) {
        var f = this, h = f.view, m = h.el.dom, j = f.store, g = j.buffered ? j.getTotalCount() : j.getCount(), e, b, d, a, k;
        i     = Math.min(Math.max(i, 0), g - 1);
        e     = Math.max(Math.min(i - ((f.leadingBufferZone + f.trailingBufferZone) / 2), g - f.viewSize + 1), 0);
        k     = e * f.rowHeight;
        b     = Math.min(e + f.viewSize - 1, g - 1);
        j.getRange(e, b, {
            callback: function(p, q, o) {
                f.renderRange(q, o, true);
                d                    = j.data.getRange(i, i)[0];
                a                    = h.getNode(d, false);
                h.body.dom.style.top = k + "px";
                f.position           = f.scrollTop = m.scrollTop = k = Math.min(Math.max(0, k - h.body.getOffsetsTo(a)[1]), m.scrollHeight - m.clientHeight);
                if (Ext.isIE) {
                    m.scrollTop = k
                }
                if (c) {
                    h.selModel.select(d)
                }
                if (l) {
                    l.call(n || f, i, d)
                }
            }
        })
    },
    onViewScroll           : function(d, j) {
        var f = this, h = f.store, i = (h.buffered ? h.getTotalCount() : h.getCount()), c, a, b = f.scrollTop = f.view.el.dom.scrollTop, g = false;
        if (f.ignoreNextScrollEvent) {
            f.ignoreNextScrollEvent = false;
            return
        }
        if (!(f.disabled || i < f.viewSize)) {
            c = b - f.position;
            a = c > 0 ? 1 : -1;
            if (Math.abs(c) >= 20 || (a !== f.lastScrollDirection)) {
                f.lastScrollDirection = a;
                f.handleViewScroll(f.lastScrollDirection);
                g = true
            }
        }
        if (!g) {
            if (f.lockingPartner && f.lockingPartner.scrollTop !== b) {
                f.lockingPartner.view.el.dom.scrollTop = b
            }
        }
    },
    handleViewScroll       : function(g) {
        var e = this, f = e.view.all, b = e.store, h = e.viewSize, a = (b.buffered ? b.getTotalCount() : b.getCount()), d, c;
        if (g == -1) {
            if (f.startIndex) {
                if ((e.getFirstVisibleRowIndex() - f.startIndex) < e.numFromEdge) {
                    d = Math.max(0, e.getLastVisibleRowIndex() + e.trailingBufferZone - h)
                }
            }
        } else {
            if (f.endIndex < a - 1) {
                if ((f.endIndex - e.getLastVisibleRowIndex()) < e.numFromEdge) {
                    d = Math.max(0, e.getFirstVisibleRowIndex() - e.trailingBufferZone)
                }
            }
        }
        if (d != null) {
            c = Math.min(d + h - 1, a - 1);
            if (d !== f.startIndex || c !== f.endIndex) {
                e.renderRange(d, c);
                return
            }
        }
        if (e.lockingPartner && e.lockingPartner.view.el && e.lockingPartner.scrollTop !== e.scrollTop) {
            e.lockingPartner.view.el.dom.scrollTop = e.scrollTop
        }
    },
    renderRange            : function(e, a, d) {
        var c = this, b = c.store;
        if (b.rangeCached(e, a)) {
            c.cancelLoad();
            if (c.synchronousRender || d) {
                c.onRangeFetched(null, e, a)
            } else {
                if (!c.renderTask) {
                    c.renderTask = new Ext.util.DelayedTask(c.onRangeFetched, c, null, false)
                }
                c.renderTask.delay(1, null, null, [null, e, a])
            }
        } else {
            c.attemptLoad(e, a)
        }
    },
    onRangeFetched         : function(g, b, e, c) {
        var i = this, k = i.view, d, m = k.all, a, l = 0, f = b * i.rowHeight, j, h = i.lockingPartner;
        if (k.isDestroyed) {
            return
        }
        if (!g) {
            g = i.store.getRange(b, e);
            if (!g) {
                return
            }
        }
        if (b > m.endIndex || e < m.startIndex) {
            m.clear(true);
            j = f
        }
        if (!m.getCount()) {
            k.doAdd(g, b)
        } else {
            if (e > m.endIndex) {
                a = Math.max(b - m.startIndex, 0);
                if (i.variableRowHeight) {
                    l = m.item(m.startIndex + a, true).offsetTop
                }
                m.scroll(Ext.Array.slice(g, m.endIndex + 1 - b), 1, a, b, e);
                if (i.variableRowHeight) {
                    j = i.bodyTop + l
                } else {
                    j = f
                }
            } else {
                a = Math.max(m.endIndex - e, 0);
                d = m.startIndex;
                m.scroll(Ext.Array.slice(g, 0, m.startIndex - b), -1, a, b, e);
                if (i.variableRowHeight) {
                    j = i.bodyTop - m.item(d, true).offsetTop
                } else {
                    j = f
                }
            }
        }
        i.position = i.scrollTop;
        if (k.positionBody) {
            i.setBodyTop(j, f)
        }
        if (h && !h.disabled && !c) {
            h.onRangeFetched(g, b, e, true);
            if (h.scrollTop !== i.scrollTop) {
                h.view.el.dom.scrollTop = i.scrollTop
            }
        }
    },
    setBodyTop             : function(d, f) {
        var e = this, b = e.view, c = e.store, a = b.body.dom, g;
        d     = Math.floor(d);
        if (f !== undefined) {
            g = d - f;
            d = f
        }
        a.style.position = "absolute";
        a.style.top      = (e.bodyTop = d) + "px";
        if (g) {
            e.scrollTop = e.position = b.el.dom.scrollTop -= g
        }
        if (b.all.endIndex === (c.buffered ? c.getTotalCount() : c.getCount()) - 1) {
            e.stretchView(b, e.bodyTop + a.offsetHeight)
        }
    },
    getFirstVisibleRowIndex: function(i, c, b, f) {
        var g = this, h = g.view, k = h.all, a = k.elements, d = h.el.dom.clientHeight, e, j;
        if (k.getCount() && g.variableRowHeight) {
            if (!arguments.length) {
                i = k.startIndex;
                c = k.endIndex;
                b = g.scrollTop;
                f = b + d;
                if (g.bodyTop > f || g.bodyTop + h.body.getHeight() < b) {
                    return Math.floor(g.scrollTop / g.rowHeight)
                }
                e = i + Math.min(g.numFromEdge + ((g.lastScrollDirection == -1) ? g.leadingBufferZone : g.trailingBufferZone), Math.floor((c - i) / 2))
            } else {
                e = i + Math.floor((c - i) / 2)
            }
            j = g.bodyTop + a[e].offsetTop;
            if (j + a[e].offsetHeight < b) {
                return g.getFirstVisibleRowIndex(e + 1, c, b, f)
            }
            if (j <= b) {
                return e
            } else {
                if (e !== i) {
                    return g.getFirstVisibleRowIndex(i, e - 1, b, f)
                }
            }
        }
        return Math.floor(g.scrollTop / g.rowHeight)
    },
    getLastVisibleRowIndex : function(j, c, b, f) {
        var h = this, i = h.view, l = i.all, a = l.elements, d = i.el.dom.clientHeight, e, k, g;
        if (l.getCount() && h.variableRowHeight) {
            if (!arguments.length) {
                j = l.startIndex;
                c = l.endIndex;
                b = h.scrollTop;
                f = b + d;
                if (h.bodyTop > f || h.bodyTop + i.body.getHeight() < b) {
                    return Math.floor(h.scrollTop / h.rowHeight) + Math.ceil(d / h.rowHeight)
                }
                e = c - Math.min(h.numFromEdge + ((h.lastScrollDirection == 1) ? h.leadingBufferZone : h.trailingBufferZone), Math.floor((c - j) / 2))
            } else {
                e = j + Math.floor((c - j) / 2)
            }
            k = h.bodyTop + a[e].offsetTop;
            if (k > f) {
                return h.getLastVisibleRowIndex(j, e - 1, b, f)
            }
            g = k + a[e].offsetHeight;
            if (g >= f) {
                return e
            } else {
                if (e !== c) {
                    return h.getLastVisibleRowIndex(e + 1, c, b, f)
                }
            }
        }
        return h.getFirstVisibleRowIndex() + Math.ceil(d / h.rowHeight)
    },
    getScrollHeight        : function() {
        var d = this, a = d.view, b = d.store, c = !d.hasOwnProperty("rowHeight"), e = d.store.getCount();
        if (!e) {
            return 0
        }
        if (c) {
            if (a.all.getCount()) {
                d.rowHeight = Math.floor(a.body.getHeight() / a.all.getCount())
            }
        }
        return this.scrollHeight = Math.floor((b.buffered ? b.getTotalCount() : b.getCount()) * d.rowHeight)
    },
    attemptLoad            : function(c, a) {
        var b = this;
        if (b.scrollToLoadBuffer) {
            if (!b.loadTask) {
                b.loadTask = new Ext.util.DelayedTask(b.doAttemptLoad, b, [])
            }
            b.loadTask.delay(b.scrollToLoadBuffer, b.doAttemptLoad, b, [c, a])
        } else {
            b.store.getRange(c, a, {
                callback : b.onRangeFetched,
                scope    : b,
                fireEvent: false
            })
        }
    },
    cancelLoad             : function() {
        if (this.loadTask) {
            this.loadTask.cancel()
        }
    },
    doAttemptLoad          : function(b, a) {
        this.store.getRange(b, a, {
            callback : this.onRangeFetched,
            scope    : this,
            fireEvent: false
        })
    },
    destroy                : function() {
        var b = this, a = b.view;
        if (a && a.el) {
            a.el.un("scroll", b.onViewScroll, b)
        }
        Ext.destroy(b.viewListeners, b.storeListeners, b.gridListeners)
    }
});
Ext.define("Ext.resizer.Splitter", {
    extend                : "Ext.Component",
    requires              : ["Ext.XTemplate"],
    uses                  : ["Ext.resizer.SplitterTracker"],
    alias                 : "widget.splitter",
    childEls              : ["collapseEl"],
    renderTpl             : ['<tpl if="collapsible===true">', '<div id="{id}-collapseEl" class="', Ext.baseCSSPrefix, "collapse-el ", Ext.baseCSSPrefix, 'layout-split-{collapseDir}{childElCls}">&#160;', "</div>", "</tpl>"],
    baseCls               : Ext.baseCSSPrefix + "splitter",
    collapsedClsInternal  : Ext.baseCSSPrefix + "splitter-collapsed",
    canResize             : true,
    collapsible           : false,
    collapseOnDblClick    : true,
    defaultSplitMin       : 40,
    defaultSplitMax       : 1000,
    collapseTarget        : "next",
    horizontal            : false,
    vertical              : false,
    size                  : 5,
    getTrackerConfig      : function() {
        return {
            xclass  : "Ext.resizer.SplitterTracker",
            el      : this.el,
            splitter: this
        }
    },
    beforeRender          : function() {
        var a = this, b = a.getCollapseTarget();
        a.callParent();
        if (b.collapsed) {
            a.addCls(a.collapsedClsInternal)
        }
        if (!a.canResize) {
            a.addCls(a.baseCls + "-noresize")
        }
        Ext.applyIf(a.renderData, {
            collapseDir: a.getCollapseDirection(),
            collapsible: a.collapsible || b.collapsible
        });
        a.protoEl.unselectable()
    },
    onRender              : function() {
        var b = this, a;
        b.callParent(arguments);
        if (b.performCollapse !== false) {
            if (b.renderData.collapsible) {
                b.mon(b.collapseEl, "click", b.toggleTargetCmp, b)
            }
            if (b.collapseOnDblClick) {
                b.mon(b.el, "dblclick", b.toggleTargetCmp, b)
            }
        }
        b.mon(b.getCollapseTarget(), {
            collapse      : b.onTargetCollapse,
            expand        : b.onTargetExpand,
            beforeexpand  : b.onBeforeTargetExpand,
            beforecollapse: b.onBeforeTargetCollapse,
            scope         : b
        });
        if (b.canResize) {
            b.tracker = Ext.create(b.getTrackerConfig());
            b.relayEvents(b.tracker, ["beforedragstart", "dragstart", "dragend"])
        }
        a = b.collapseEl;
        if (a) {
            a.lastCollapseDirCls = b.collapseDirProps[b.collapseDirection].cls
        }
    },
    getCollapseDirection  : function() {
        var f = this, c = f.collapseDirection, e, a, b, d;
        if (!c) {
            e = f.collapseTarget;
            if (e.isComponent) {
                c = e.collapseDirection
            }
            if (!c) {
                d = f.ownerCt.layout.type;
                if (e.isComponent) {
                    b = f.ownerCt.items;
                    a = Number(b.indexOf(e) === b.indexOf(f) - 1) << 1 | Number(d === "hbox")
                } else {
                    a = Number(f.collapseTarget === "prev") << 1 | Number(d === "hbox")
                }
                c = ["bottom", "right", "top", "left"][a]
            }
            f.collapseDirection = c
        }
        f.setOrientation((c === "top" || c === "bottom") ? "horizontal" : "vertical");
        return c
    },
    getCollapseTarget     : function() {
        var a = this;
        return a.collapseTarget.isComponent ? a.collapseTarget : a.collapseTarget === "prev" ? a.previousSibling() : a.nextSibling()
    },
    setCollapseEl         : function(b) {
        var a = this.collapseEl;
        if (a) {
            a.setDisplayed(b)
        }
    },
    onBeforeTargetExpand  : function(a) {
        this.setCollapseEl("none")
    },
    onBeforeTargetCollapse: function() {
        this.setCollapseEl("none")
    },
    onTargetCollapse      : function(a) {
        this.el.addCls([this.collapsedClsInternal, this.collapsedCls]);
        this.setCollapseEl("")
    },
    onTargetExpand        : function(a) {
        this.el.removeCls([this.collapsedClsInternal, this.collapsedCls]);
        this.setCollapseEl("")
    },
    collapseDirProps      : {
        top   : {cls: Ext.baseCSSPrefix + "layout-split-top"},
        right : {cls: Ext.baseCSSPrefix + "layout-split-right"},
        bottom: {cls: Ext.baseCSSPrefix + "layout-split-bottom"},
        left  : {cls: Ext.baseCSSPrefix + "layout-split-left"}
    },
    orientationProps      : {
        horizontal: {
            opposite     : "vertical",
            fixedAxis    : "height",
            stretchedAxis: "width"
        },
        vertical  : {
            opposite     : "horizontal",
            fixedAxis    : "width",
            stretchedAxis: "height"
        }
    },
    applyCollapseDirection: function() {
        var c = this, b = c.collapseEl, d = c.collapseDirProps[c.collapseDirection], a;
        if (b) {
            a = b.lastCollapseDirCls;
            if (a) {
                b.removeCls(a)
            }
            b.addCls(b.lastCollapseDirCls = d.cls)
        }
    },
    applyOrientation      : function() {
        var e         = this, c = e.orientation, d = e.orientationProps[c], f = e.size, b = d.fixedAxis, g = d.stretchedAxis, a = e.baseCls + "-";
        e[c]          = true;
        e[d.opposite] = false;
        if (!e.hasOwnProperty(b) || e[b] === "100%") {
            e[b] = f
        }
        if (!e.hasOwnProperty(g) || e[g] === f) {
            e[g] = "100%"
        }
        e.removeCls(a + d.opposite);
        e.addCls(a + c)
    },
    setOrientation        : function(a) {
        var b = this;
        if (b.orientation !== a) {
            b.orientation = a;
            b.applyOrientation()
        }
    },
    updateOrientation     : function() {
        delete this.collapseDirection;
        this.getCollapseDirection();
        this.applyCollapseDirection()
    },
    toggleTargetCmp       : function(d, b) {
        var c = this.getCollapseTarget(), f = c.placeholder, a;
        if (Ext.isFunction(c.expand) && Ext.isFunction(c.collapse)) {
            if (f && !f.hidden) {
                a = true
            } else {
                a = !c.hidden
            }
            if (a) {
                if (c.collapsed) {
                    c.expand()
                } else {
                    if (c.collapseDirection) {
                        c.collapse()
                    } else {
                        c.collapse(this.renderData.collapseDir)
                    }
                }
            }
        }
    },
    setSize               : function() {
        var a = this;
        a.callParent(arguments);
        if (Ext.isIE && a.el) {
            a.el.repaint()
        }
    },
    beforeDestroy         : function() {
        Ext.destroy(this.tracker);
        this.callParent()
    }
});
Ext.define("Ext.resizer.BorderSplitter", {
    extend          : "Ext.resizer.Splitter",
    uses            : ["Ext.resizer.BorderSplitterTracker"],
    alias           : "widget.bordersplitter",
    collapseTarget  : null,
    getTrackerConfig: function() {
        var a    = this.callParent();
        a.xclass = "Ext.resizer.BorderSplitterTracker";
        return a
    }
});
Ext.define("Ext.layout.container.Border", {
    extend                : "Ext.layout.container.Container",
    alias                 : "layout.border",
    alternateClassName    : "Ext.layout.BorderLayout",
    requires              : ["Ext.resizer.BorderSplitter", "Ext.fx.Anim", "Ext.layout.container.border.Region"],
    targetCls             : Ext.baseCSSPrefix + "border-layout-ct",
    itemCls               : [Ext.baseCSSPrefix + "border-item", Ext.baseCSSPrefix + "box-item"],
    type                  : "border",
    isBorderLayout        : true,
    padding               : undefined,
    percentageRe          : /(\d+)%/,
    horzMarginProp        : "left",
    padOnContainerProp    : "left",
    padNotOnContainerProp : "right",
    axisProps             : {
        horz: {
            borderBegin: "west",
            borderEnd  : "east",
            horizontal : true,
            posProp    : "x",
            sizeProp   : "width",
            sizePropCap: "Width"
        },
        vert: {
            borderBegin: "north",
            borderEnd  : "south",
            horizontal : false,
            posProp    : "y",
            sizeProp   : "height",
            sizePropCap: "Height"
        }
    },
    centerRegion          : null,
    manageMargins         : true,
    panelCollapseAnimate  : true,
    panelCollapseMode     : "placeholder",
    regionWeights         : {
        north : 20,
        south : 10,
        center: 0,
        west  : -10,
        east  : -20
    },
    beginAxis             : function(l, b, v) {
        var t = this, c = t.axisProps[v], q = !c.horizontal, k = c.sizeProp, o = 0, a = l.childItems, f = a.length, s, p, n, g, r, e, j, m, d, u, h;
        for (p = 0; p < f; ++p) {
            n           = a[p];
            r           = n.target;
            n.layoutPos = {};
            if (r.region) {
                n.region = e = r.region;
                n.isCenter = r.isCenter;
                n.isHorz   = r.isHorz;
                n.isVert   = r.isVert;
                n.weight   = r.weight || t.regionWeights[e] || 0;
                b[r.id]    = n;
                if (r.isCenter) {
                    s              = n;
                    g              = r.flex;
                    l.centerRegion = s;
                    continue
                }
                if (q !== n.isVert) {
                    continue
                }
                n.reverseWeighting = (e == c.borderEnd);
                m                  = r[k];
                d                  = typeof m;
                if (!r.collapsed) {
                    if (d == "string" && (j = t.percentageRe.exec(m))) {
                        n.percentage = parseInt(j[1], 10)
                    } else {
                        if (r.flex) {
                            o += n.flex = r.flex
                        }
                    }
                }
            }
        }
        if (s) {
            u = s.target;
            if ((h = u.placeholderFor)) {
                if (!g && q === h.collapsedVertical()) {
                    g              = 0;
                    s.collapseAxis = v
                }
            } else {
                if (u.collapsed && (q === u.collapsedVertical())) {
                    g              = 0;
                    s.collapseAxis = v
                }
            }
        }
        if (g == null) {
            g = 1
        }
        o += g;
        return Ext.apply({
            before   : q ? "top" : "left",
            totalFlex: o
        }, c)
    },
    beginLayout           : function(d) {
        var k = this, j = k.getLayoutItems(), e = k.padding, l = typeof e, o = false, p, n, b, g, f, a, c, h, m;
        if (e) {
            if (l == "string" || l == "number") {
                e = Ext.util.Format.parseBox(e)
            }
        } else {
            e = d.getEl("getTargetEl").getPaddingInfo();
            o = true
        }
        d.outerPad       = e;
        d.padOnContainer = o;
        for (g = 0, b = j.length; g < b; ++g) {
            n = j[g];
            a = k.getSplitterTarget(n);
            if (a) {
                c = undefined;
                h = !!n.hidden;
                if (!a.split) {
                    if (a.isCollapsingOrExpanding) {
                        c = !!a.collapsed
                    }
                } else {
                    if (h !== a.hidden) {
                        c = !a.hidden
                    }
                }
                if (c) {
                    n.show()
                } else {
                    if (c === false) {
                        n.hide()
                    }
                }
            }
        }
        k.callParent(arguments);
        j                = d.childItems;
        b                = j.length;
        f                = {};
        d.borderAxisHorz = k.beginAxis(d, f, "horz");
        d.borderAxisVert = k.beginAxis(d, f, "vert");
        for (g = 0; g < b; ++g) {
            p = j[g];
            a = k.getSplitterTarget(p.target);
            if (a) {
                m = f[a.id];
                if (!m) {
                    m        = d.getEl(a.el, k);
                    m.region = a.region
                }
                p.collapseTarget = a = m;
                p.weight           = a.weight;
                p.reverseWeighting = a.reverseWeighting;
                a.splitter         = p;
                p.isHorz           = a.isHorz;
                p.isVert           = a.isVert
            }
        }
        k.sortWeightedItems(j, "reverseWeighting");
        k.setupSplitterNeighbors(j)
    },
    calculate             : function(d) {
        var l   = this, a = l.getContainerSize(d), h = d.childItems, c = h.length, b = d.borderAxisHorz, j = d.borderAxisVert, e = d.outerPad, n = d.padOnContainer, g, p, k, o, m, f;
        b.begin = e[l.padOnContainerProp];
        j.begin = e.top;
        m       = b.end = b.flexSpace = a.width + (n ? e[l.padOnContainerProp] : -e[l.padNotOnContainerProp]);
        f = j.end = j.flexSpace = a.height + (n ? e.top : -e.bottom);
        for (g = 0; g < c; ++g) {
            p = h[g];
            k = p.getMarginInfo();
            if (p.isHorz || p.isCenter) {
                b.addUnflexed(k.width);
                m -= k.width
            }
            if (p.isVert || p.isCenter) {
                j.addUnflexed(k.height);
                f -= k.height
            }
            if (!p.flex && !p.percentage) {
                if (p.isHorz || (p.isCenter && p.collapseAxis === "horz")) {
                    o = p.getProp("width");
                    b.addUnflexed(o);
                    if (p.collapseTarget) {
                        m -= o
                    }
                } else {
                    if (p.isVert || (p.isCenter && p.collapseAxis === "vert")) {
                        o = p.getProp("height");
                        j.addUnflexed(o);
                        if (p.collapseTarget) {
                            f -= o
                        }
                    }
                }
            }
        }
        for (g = 0; g < c; ++g) {
            p = h[g];
            k = p.getMarginInfo();
            if (p.percentage) {
                if (p.isHorz) {
                    o = Math.ceil(m * p.percentage / 100);
                    o = p.setWidth(o);
                    b.addUnflexed(o)
                } else {
                    if (p.isVert) {
                        o = Math.ceil(f * p.percentage / 100);
                        o = p.setHeight(o);
                        j.addUnflexed(o)
                    }
                }
            }
        }
        for (g = 0; g < c; ++g) {
            p = h[g];
            if (!p.isCenter) {
                l.calculateChildAxis(p, b);
                l.calculateChildAxis(p, j)
            }
        }
        if (l.finishAxis(d, j) + l.finishAxis(d, b) < 2) {
            l.done = false
        } else {
            l.finishPositions(h)
        }
    },
    calculateChildAxis    : function(k, c) {
        var a = k.collapseTarget, g = "set" + c.sizePropCap, e = c.sizeProp, d = k.getMarginInfo()[e], i, b, f, h, j;
        if (a) {
            i = a.region
        } else {
            i = k.region;
            f = k.flex
        }
        b = i == c.borderBegin;
        if (!b && i != c.borderEnd) {
            k[g](c.end - c.begin - d);
            h = c.begin
        } else {
            if (f) {
                j = Math.ceil(c.flexSpace * (f / c.totalFlex));
                j = k[g](j)
            } else {
                if (k.percentage) {
                    j = k.peek(e)
                } else {
                    j = k.getProp(e)
                }
            }
            j += d;
            if (b) {
                h = c.begin;
                c.begin += j
            } else {
                c.end = h = c.end - j
            }
        }
        k.layoutPos[c.posProp] = h
    },
    finishAxis            : function(d, c) {
        var b = c.end - c.begin, a = d.centerRegion;
        if (a) {
            a["set" + c.sizePropCap](b - a.getMarginInfo()[c.sizeProp]);
            a.layoutPos[c.posProp] = c.begin
        }
        return Ext.isNumber(b) ? 1 : 0
    },
    finishPositions       : function(e) {
        var c = e.length, b, a, d = this.horzMarginProp;
        for (b = 0; b < c; ++b) {
            a = e[b];
            a.setProp("x", a.layoutPos.x + a.marginInfo[d]);
            a.setProp("y", a.layoutPos.y + a.marginInfo.top)
        }
    },
    getLayoutItems        : function() {
        var a = this.owner, e = (a && a.items && a.items.items) || [], d = e.length, b = [], c = 0, f, g;
        for (; c < d; c++) {
            f = e[c];
            g = f.placeholderFor;
            if (f.hidden || ((!f.floated || f.isCollapsingOrExpanding === 2) && !(g && g.isCollapsingOrExpanding === 2))) {
                b.push(f)
            }
        }
        return b
    },
    getPlaceholder        : function(a) {
        return a.getPlaceholder && a.getPlaceholder()
    },
    getSplitterTarget     : function(b) {
        var a = b.collapseTarget;
        if (a && a.collapsed) {
            return a.placeholder || a
        }
        return a
    },
    isItemBoxParent       : function(a) {
        return true
    },
    isItemShrinkWrap      : function(a) {
        return true
    },
    insertSplitter        : function(d, c, f, b) {
        var g    = d.region, e = Ext.apply({
            xtype         : "bordersplitter",
            collapseTarget: d,
            id            : d.id + "-splitter",
            hidden        : f,
            canResize     : d.splitterResize !== false,
            splitterFor   : d
        }, b), a = c + ((g === "south" || g === "east") ? 0 : 1);
        if (d.collapseMode === "mini") {
            e.collapsedCls = d.collapsedCls
        }
        d.splitter = this.owner.add(a, e)
    },
    onAdd                 : function(e, b) {
        var d = this, h = e.placeholderFor, g = e.region, c, f, a;
        d.callParent(arguments);
        if (g) {
            Ext.apply(e, d.regionFlags[g]);
            if (e.initBorderRegion) {
                e.initBorderRegion()
            }
            if (g === "center") {
                d.centerRegion = e
            } else {
                c = e.split;
                f = !!e.hidden;
                if (typeof c === "object") {
                    a = c;
                    c = true
                }
                if ((e.isHorz || e.isVert) && (c || e.collapseMode == "mini")) {
                    d.insertSplitter(e, b, f || !c, a)
                }
            }
            if (!e.hasOwnProperty("collapseMode")) {
                e.collapseMode = d.panelCollapseMode
            }
            if (!e.hasOwnProperty("animCollapse")) {
                if (e.collapseMode !== "placeholder") {
                    e.animCollapse = false
                } else {
                    e.animCollapse = d.panelCollapseAnimate
                }
            }
        } else {
            if (h) {
                Ext.apply(e, d.regionFlags[h.region]);
                e.region = h.region;
                e.weight = h.weight
            }
        }
    },
    onDestroy             : function() {
        this.centerRegion = null;
        this.callParent()
    },
    onRemove              : function(b) {
        var a = this, d = b.region, c = b.splitter;
        if (d) {
            if (b.isCenter) {
                a.centerRegion = null
            }
            delete b.isCenter;
            delete b.isHorz;
            delete b.isVert;
            if (c) {
                a.owner.doRemove(c, true);
                delete b.splitter
            }
        }
        a.callParent(arguments)
    },
    regionMeta            : {
        center: {splitterDelta: 0},
        north : {splitterDelta: 1},
        south : {splitterDelta: -1},
        west  : {splitterDelta: 1},
        east  : {splitterDelta: -1}
    },
    regionFlags           : {
        center: {
            isCenter: true,
            isHorz  : false,
            isVert  : false
        },
        north : {
            isCenter         : false,
            isHorz           : false,
            isVert           : true,
            collapseDirection: "top"
        },
        south : {
            isCenter         : false,
            isHorz           : false,
            isVert           : true,
            collapseDirection: "bottom"
        },
        west  : {
            isCenter         : false,
            isHorz           : true,
            isVert           : false,
            collapseDirection: "left"
        },
        east  : {
            isCenter         : false,
            isHorz           : true,
            isVert           : false,
            collapseDirection: "right"
        }
    },
    setupSplitterNeighbors: function(l) {
        var o = {}, e = l.length, n = this.touchedRegions, g, f, a, k, d, h, m, b, c;
        for (g = 0; g < e; ++g) {
            h = l[g].target;
            m = h.region;
            if (h.isCenter) {
                a = h
            } else {
                if (m) {
                    c = n[m];
                    for (f = 0, k = c.length; f < k; ++f) {
                        d = o[c[f]];
                        if (d) {
                            d.neighbors.push(h)
                        }
                    }
                    if (h.placeholderFor) {
                        b = h.placeholderFor.splitter
                    } else {
                        b = h.splitter
                    }
                    if (b) {
                        b.neighbors = []
                    }
                    o[m] = b
                }
            }
        }
        if (a) {
            c = n.center;
            for (f = 0, k = c.length; f < k; ++f) {
                d = o[c[f]];
                if (d) {
                    d.neighbors.push(a)
                }
            }
        }
    },
    touchedRegions        : {
        center: ["north", "south", "east", "west"],
        north : ["north", "east", "west"],
        south : ["south", "east", "west"],
        east  : ["east", "north", "south"],
        west  : ["west", "north", "south"]
    },
    sizePolicies          : {
        vert   : {
            readsWidth : 0,
            readsHeight: 1,
            setsWidth  : 1,
            setsHeight : 0
        },
        horz   : {
            readsWidth : 1,
            readsHeight: 0,
            setsWidth  : 0,
            setsHeight : 1
        },
        flexAll: {
            readsWidth : 0,
            readsHeight: 0,
            setsWidth  : 1,
            setsHeight : 1
        }
    },
    getItemSizePolicy     : function(e) {
        var d = this, a = this.sizePolicies, c, b, f, g;
        if (e.isCenter) {
            g = e.placeholderFor;
            if (g) {
                if (g.collapsedVertical()) {
                    return a.vert
                }
                return a.horz
            }
            if (e.collapsed) {
                if (e.collapsedVertical()) {
                    return a.vert
                }
                return a.horz
            }
            return a.flexAll
        }
        c = e.collapseTarget;
        if (c) {
            return c.isVert ? a.vert : a.horz
        }
        if (e.region) {
            if (e.isVert) {
                b = e.height;
                f = a.vert
            } else {
                b = e.width;
                f = a.horz
            }
            if (e.flex || (typeof b == "string" && d.percentageRe.test(b))) {
                return a.flexAll
            }
            return f
        }
        return d.autoSizePolicy
    }
}, function() {
    var a = {
        addUnflexed: function(c) {
            this.flexSpace = Math.max(this.flexSpace - c, 0)
        }
    }, b  = this.prototype.axisProps;
    Ext.apply(b.horz, a);
    Ext.apply(b.vert, a)
});
Ext.define("ExtThemeNeptune.resizer.Splitter", {
    override: "Ext.resizer.Splitter",
    size    : 8
});
Ext.define("ExtThemeNeptune.menu.Menu", {
    override     : "Ext.menu.Menu",
    showSeparator: false
});
Ext.define("ExtThemeNeptune.menu.Separator", {
    override: "Ext.menu.Separator",
    border  : true
});
Ext.define("ExtThemeNeptune.panel.Tool", {
    override: "Ext.panel.Tool",
    height  : 16,
    width   : 16
});
Ext.define("Ext.resizer.SplitterTracker", {
    extend                   : "Ext.dd.DragTracker",
    requires                 : ["Ext.util.Region"],
    enabled                  : true,
    overlayCls               : Ext.baseCSSPrefix + "resizable-overlay",
    createDragOverlay        : function() {
        var a;
        a = this.overlay = Ext.getBody().createChild({
            cls : this.overlayCls,
            html: "&#160;"
        });
        a.unselectable();
        a.setSize(Ext.Element.getViewWidth(true), Ext.Element.getViewHeight(true));
        a.show()
    },
    getPrevCmp               : function() {
        var a = this.getSplitter();
        return a.previousSibling(":not([hidden])")
    },
    getNextCmp               : function() {
        var a = this.getSplitter();
        return a.nextSibling(":not([hidden])")
    },
    onBeforeStart            : function(h) {
        var d = this, f = d.getPrevCmp(), a = d.getNextCmp(), c = d.getSplitter().collapseEl, g = h.getTarget(), b;
        if (!f || !a) {
            return false
        }
        if (c && g === d.getSplitter().collapseEl.dom) {
            return false
        }
        if (a.collapsed || f.collapsed) {
            return false
        }
        d.prevBox     = f.getEl().getBox();
        d.nextBox     = a.getEl().getBox();
        d.constrainTo = b = d.calculateConstrainRegion();
        if (!b) {
            return false
        }
        return b
    },
    onStart                  : function(b) {
        var a = this.getSplitter();
        this.createDragOverlay();
        a.addCls(a.baseCls + "-active")
    },
    calculateConstrainRegion : function() {
        var g = this, a = g.getSplitter(), h = a.getWidth(), i = a.defaultSplitMin, b = a.orientation, e = g.prevBox, j = g.getPrevCmp(), c = g.nextBox, f = g.getNextCmp(), l, k, d;
        if (b === "vertical") {
            d = {
                prevCmp   : j,
                nextCmp   : f,
                prevBox   : e,
                nextBox   : c,
                defaultMin: i,
                splitWidth: h
            };
            l = new Ext.util.Region(e.y, g.getVertPrevConstrainRight(d), e.bottom, g.getVertPrevConstrainLeft(d));
            k = new Ext.util.Region(c.y, g.getVertNextConstrainRight(d), c.bottom, g.getVertNextConstrainLeft(d))
        } else {
            l = new Ext.util.Region(e.y + (j.minHeight || i), e.right, (j.maxHeight ? e.y + j.maxHeight : c.bottom - (f.minHeight || i)) + h, e.x);
            k = new Ext.util.Region((f.maxHeight ? c.bottom - f.maxHeight : e.y + (j.minHeight || i)) - h, c.right, c.bottom - (f.minHeight || i), c.x)
        }
        return l.intersect(k)
    },
    performResize            : function(m, g) {
        var o = this, a = o.getSplitter(), h = a.orientation, p = o.getPrevCmp(), n = o.getNextCmp(), b = a.ownerCt, k = b.query(">[flex]"), l = k.length, c = h === "vertical", j = 0, f = c ? "width" : "height", d = 0, q, r;
        for (; j < l; j++) {
            q      = k[j];
            r      = c ? q.getWidth() : q.getHeight();
            d += r;
            q.flex = r
        }
        g = c ? g[0] : g[1];
        if (p) {
            r = o.prevBox[f] + g;
            if (p.flex) {
                p.flex = r
            } else {
                p[f] = r
            }
        }
        if (n) {
            r = o.nextBox[f] - g;
            if (n.flex) {
                n.flex = r
            } else {
                n[f] = r
            }
        }
        b.updateLayout()
    },
    endDrag                  : function() {
        var a = this;
        if (a.overlay) {
            a.overlay.remove();
            delete a.overlay
        }
        a.callParent(arguments)
    },
    onEnd                    : function(c) {
        var a = this, b = a.getSplitter();
        b.removeCls(b.baseCls + "-active");
        a.performResize(c, a.getResizeOffset())
    },
    onDrag                   : function(f) {
        var c = this, g = c.getOffset("dragTarget"), d = c.getSplitter(), b = d.getEl(), a = d.orientation;
        if (a === "vertical") {
            b.setX(c.startRegion.left + g[0])
        } else {
            b.setY(c.startRegion.top + g[1])
        }
    },
    getSplitter              : function() {
        return this.splitter
    },
    getVertPrevConstrainRight: function(a) {
        return (a.prevCmp.maxWidth ? a.prevBox.x + a.prevCmp.maxWidth : a.nextBox.right - (a.nextCmp.minWidth || a.defaultMin)) + a.splitWidth
    },
    getVertPrevConstrainLeft : function(a) {
        return a.prevBox.x + (a.prevCmp.minWidth || a.defaultMin)
    },
    getVertNextConstrainRight: function(a) {
        return a.nextBox.right - (a.nextCmp.minWidth || a.defaultMin)
    },
    getVertNextConstrainLeft : function(a) {
        return (a.nextCmp.maxWidth ? a.nextBox.right - a.nextCmp.maxWidth : a.prevBox.x + (a.prevBox.minWidth || a.defaultMin)) - a.splitWidth
    },
    getResizeOffset          : function() {
        return this.getOffset("dragTarget")
    }
});
Ext.define("Ext.resizer.BorderSplitterTracker", {
    extend                  : "Ext.resizer.SplitterTracker",
    requires                : ["Ext.util.Region"],
    getPrevCmp              : null,
    getNextCmp              : null,
    calculateConstrainRegion: function() {
        var x = this, a = x.splitter, n = a.collapseTarget, d = a.defaultSplitMin, g = a.vertical ? "Width" : "Height", c = "min" + g, t = "max" + g, h = "get" + g, s = a.neighbors, e = s.length, m = n.el.getBox(), f = m.x, o = m.y, w = m.right, j = m.bottom, q = a.vertical ? (w - f) : (j - o), v, k, l, u, r, p, b;
        l     = (n[c] || Math.min(q, d)) - q;
        u     = n[t];
        if (!u) {
            u = 1000000000
        } else {
            u -= q
        }
        b = q;
        for (v = 0; v < e; ++v) {
            k = s[v];
            q = k[h]();
            r = q - k[t];
            p = q - (k[c] || Math.min(q, d));
            if (!isNaN(r)) {
                if (l < r) {
                    l = r
                }
            }
            if (u > p) {
                u = p
            }
        }
        if (u - l < 2) {
            return null
        }
        m = new Ext.util.Region(o, w, j, f);
        x.constraintAdjusters[x.getCollapseDirection()](m, l, u, a);
        x.dragInfo = {
            minRange  : l,
            maxRange  : u,
            targetSize: b
        };
        return m
    },
    constraintAdjusters     : {
        left  : function(c, a, b, d) {
            c[0] = c.x = c.left = c.right + a;
            c.right += b + d.getWidth()
        },
        top   : function(c, a, b, d) {
            c[1] = c.y = c.top = c.bottom + a;
            c.bottom += b + d.getHeight()
        },
        bottom: function(c, a, b, d) {
            c.bottom = c.top - a;
            c.top -= b + d.getHeight()
        },
        right : function(c, a, b, d) {
            c.right = c.left - a;
            c[0]    = c.x = c.left = c.x - b + d.getWidth()
        }
    },
    onBeforeStart           : function(g) {
        var j = this, b = j.splitter, a = b.collapseTarget, l = b.neighbors, d = j.getSplitter().collapseEl, h = g.getTarget(), c = l.length, f, k;
        if (d && h === b.collapseEl.dom) {
            return false
        }
        if (a.collapsed) {
            return false
        }
        for (f = 0; f < c; ++f) {
            k = l[f];
            if (k.collapsed && k.isHorz === a.isHorz) {
                return false
            }
        }
        if (!(j.constrainTo = j.calculateConstrainRegion())) {
            return false
        }
        return true
    },
    performResize           : function(i, h) {
        var j = this, b = j.splitter, g = b.getCollapseDirection(), a = b.collapseTarget, f = j.splitAdjusters[b.vertical ? "horz" : "vert"], k = h[f.index], d = j.dragInfo, c;
        if (g == "right" || g == "bottom") {
            k = -k
        }
        k = Math.min(Math.max(d.minRange, k), d.maxRange);
        if (k) {
            (c = b.ownerCt).suspendLayouts();
            f.adjustTarget(a, d.targetSize, k);
            c.resumeLayouts(true)
        }
    },
    splitAdjusters          : {
        horz: {
            index       : 0,
            adjustTarget: function(b, a, c) {
                b.flex = null;
                b.setSize(a + c)
            }
        },
        vert: {
            index       : 1,
            adjustTarget: function(b, a, c) {
                b.flex = null;
                b.setSize(undefined, a + c)
            }
        }
    },
    getCollapseDirection    : function() {
        return this.splitter.getCollapseDirection()
    }
});
Ext.define("Ext.selection.CellModel", {
    extend            : "Ext.selection.Model",
    alias             : "selection.cellmodel",
    requires          : ["Ext.grid.CellContext", "Ext.util.KeyNav"],
    isCellModel       : true,
    enableKeyNav      : true,
    preventWrap       : false,
    noSelection       : {
        row   : -1,
        column: -1
    },
    constructor       : function() {
        this.addEvents("deselect", "select");
        this.callParent(arguments)
    },
    bindComponent     : function(a) {
        var c         = this, b = a.ownerCt;
        c.primaryView = a;
        c.views       = c.views || [];
        c.views.push(a);
        c.bindStore(a.getStore(), true);
        a.on({
            cellmousedown: c.onMouseDown,
            refresh      : c.onViewRefresh,
            scope        : c
        });
        if (b.optimizedColumnMove !== false) {
            b.on("columnmove", c.onColumnMove, c)
        }
        if (c.enableKeyNav) {
            c.initKeyNav(a)
        }
    },
    initKeyNav        : function(a) {
        var b = this;
        if (!a.rendered) {
            a.on("render", Ext.Function.bind(b.initKeyNav, b, [a], 0), b, {single: true});
            return
        }
        a.el.set({tabIndex: -1});
        b.keyNav = new Ext.util.KeyNav({
            target           : a.el,
            ignoreInputFields: true,
            up               : b.onKeyUp,
            down             : b.onKeyDown,
            right            : b.onKeyRight,
            left             : b.onKeyLeft,
            tab              : b.onKeyTab,
            scope            : b
        })
    },
    getHeaderCt       : function() {
        var b = this.getCurrentPosition(), a = b ? b.view : this.primaryView;
        return a.headerCt
    },
    onKeyUp           : function(a) {
        this.doMove("up", a)
    },
    onKeyDown         : function(a) {
        this.doMove("down", a)
    },
    onKeyLeft         : function(a) {
        this.doMove("left", a)
    },
    onKeyRight        : function(a) {
        this.doMove("right", a)
    },
    doMove            : function(b, a) {
        this.keyNavigation = true;
        this.move(b, a);
        this.keyNavigation = false
    },
    onVetoUIEvent     : Ext.emptyFn,
    select            : function(g, e, b) {
        var d = this, f, c = d.getCurrentPosition(), a = d.view.store;
        if (g || g === 0) {
            if (g.isModel) {
                f = a.indexOf(g);
                if (f !== -1) {
                    g = {
                        row   : f,
                        column: c ? c.column : 0
                    }
                } else {
                    g = null
                }
            } else {
                if (typeof g === "number") {
                    g = {
                        row   : g,
                        column: 0
                    }
                }
            }
        }
        if (g) {
            d.selectByPosition(g, b)
        } else {
            d.deselect()
        }
    },
    deselect          : function(a, b) {
        this.selectByPosition(null, b)
    },
    move              : function(a, d) {
        var c = this, f = c.getCurrentPosition(), b;
        if (f) {
            b = f.view.walkCells(f, a, d, c.preventWrap);
            if (b) {
                b.view = f.view;
                return c.setCurrentPosition(b)
            }
        }
    },
    getCurrentPosition: function() {
        return this.selecting ? this.nextSelection : this.selection
    },
    setCurrentPosition: function(d, a) {
        var c           = this, b = c.selection;
        c.lastSelection = b;
        if (b) {
            if (d && (d.record === b.record && d.columnHeader === b.columnHeader && d.view === b.view)) {
                d = null
            } else {
                c.onCellDeselect(c.selection, a)
            }
        }
        if (d) {
            c.nextSelection = new Ext.grid.CellContext(c.primaryView).setPosition(d);
            c.selecting     = true;
            c.onCellSelect(c.nextSelection, a);
            c.selecting = false;
            return (c.selection = c.nextSelection)
        }
    },
    isCellSelected    : function(a, e, c) {
        var d = this, b, f = d.getCurrentPosition();
        if (f && f.view === a) {
            b = new Ext.grid.CellContext(a).setPosition({
                row   : e,
                column: c
            });
            return (b.record === f.record) && (b.columnHeader === f.columnHeader)
        }
    },
    onStoreRemove     : function(j, b, e) {
        var g = this, h = g.getCurrentPosition(), c, a = b.length, f, d = 0;
        g.callParent(arguments);
        if (h) {
            if (e[0] > h.row) {
                return
            }
            for (c = 0; c < a; c++) {
                f = e[c];
                if (f < h.row) {
                    d++
                } else {
                    break
                }
            }
            if (d) {
                h.setRow(h.row - d)
            }
        }
    },
    onMouseDown       : function(c, a, f, b, h, d, g) {
        if (d !== -1) {
            this.setCurrentPosition({
                view  : c,
                row   : h,
                column: f
            })
        }
    },
    onCellSelect      : function(a, b) {
        if (a && a.row !== undefined && a.row > -1) {
            this.doSelect(a.record, false, b)
        }
    },
    onCellDeselect    : function(a, b) {
        if (a && a.row !== undefined) {
            this.doDeselect(a.record, b)
        }
    },
    onSelectChange    : function(b, e, d, g) {
        var f = this, h, c, a;
        if (e) {
            h = f.nextSelection;
            c = "select"
        } else {
            h = f.lastSelection || f.noSelection;
            c = "deselect"
        }
        a = h.view || f.primaryView;
        if ((d || f.fireEvent("before" + c, f, b, h.row, h.column)) !== false && g() !== false) {
            if (e) {
                a.focusRow(b, true);
                a.onCellSelect(h)
            } else {
                a.onCellDeselect(h);
                delete f.selection
            }
            if (!d) {
                f.fireEvent(c, f, b, h.row, h.column)
            }
        }
    },
    onKeyTab          : function(d, b) {
        var c = this, f = c.getCurrentPosition(), a;
        if (f) {
            a = f.view.editingPlugin;
            if (a && c.wasEditing) {
                c.onEditorTab(a, d)
            } else {
                c.move(d.shiftKey ? "left" : "right", d)
            }
        }
    },
    onEditorTab       : function(b, f) {
        var c = this, d = f.shiftKey ? "left" : "right", a = c.move(d, f);
        if (a) {
            if (b.startEdit(a.record, a.columnHeader)) {
                c.wasEditing = false
            } else {
                c.wasEditing = true
            }
        }
    },
    refresh           : function() {
        var b = this.getCurrentPosition(), a;
        if (b && (a = this.store.indexOf(this.selected.last())) !== -1) {
            b.row = a
        }
    },
    onColumnMove      : function(d, e, b, c) {
        var a = d.up("tablepanel");
        if (a) {
            this.onViewRefresh(a.view)
        }
    },
    onUpdate          : function(a) {
        var b = this, c;
        if (b.isSelected(a)) {
            c = b.selecting ? b.nextSelection : b.selection;
            b.view.onCellSelect(c)
        }
    },
    onViewRefresh     : function(b) {
        var c = this, f = c.getCurrentPosition(), e = b.headerCt, a, d;
        if (f && f.view === b) {
            a = f.record;
            d = f.columnHeader;
            if (!d.isDescendantOf(e)) {
                d = e.queryById(d.id) || e.down('[text="' + d.text + '"]') || e.down('[dataIndex="' + d.dataIndex + '"]')
            }
            if (d && (b.store.indexOfId(a.getId()) !== -1)) {
                c.setCurrentPosition({
                    row   : a,
                    column: d,
                    view  : b
                })
            }
        }
    },
    selectByPosition  : function(a, b) {
        this.setCurrentPosition(a, b)
    }
});
Ext.define("Ext.selection.RowModel", {
    extend                   : "Ext.selection.Model",
    alias                    : "selection.rowmodel",
    requires                 : ["Ext.util.KeyNav"],
    deltaScroll              : 5,
    enableKeyNav             : true,
    ignoreRightMouseSelection: false,
    constructor              : function() {
        this.addEvents("beforedeselect", "beforeselect", "deselect", "select");
        this.views = [];
        this.callParent(arguments)
    },
    bindComponent            : function(a) {
        var b = this;
        a.on({
            itemmousedown: b.onRowMouseDown,
            itemclick    : b.onRowClick,
            scope        : b
        });
        if (b.enableKeyNav) {
            b.initKeyNav(a)
        }
    },
    initKeyNav               : function(a) {
        var b = this;
        if (!a.rendered) {
            a.on("render", Ext.Function.bind(b.initKeyNav, b, [a], 0), b, {single: true});
            return
        }
        a.el.set({tabIndex: -1});
        b.keyNav = new Ext.util.KeyNav({
            target           : a,
            ignoreInputFields: true,
            eventName        : "itemkeydown",
            processEvent     : function(d, c, g, e, f) {
                f.record      = c;
                f.recordIndex = e;
                return f
            },
            up               : b.onKeyUp,
            down             : b.onKeyDown,
            right            : b.onKeyRight,
            left             : b.onKeyLeft,
            pageDown         : b.onKeyPageDown,
            pageUp           : b.onKeyPageUp,
            home             : b.onKeyHome,
            end              : b.onKeyEnd,
            space            : b.onKeySpace,
            enter            : b.onKeyEnter,
            scope            : b
        })
    },
    onUpdate                 : function(b) {
        var d = this, a = d.view, c;
        if (a && d.isSelected(b)) {
            c = a.indexOf(b);
            a.onRowSelect(c);
            if (b === d.lastFocused) {
                a.onRowFocus(c, true)
            }
        }
    },
    getRowsVisible           : function() {
        var e = false, a = this.views[0], d = a.all.first(), b, c;
        if (d) {
            b = d.getHeight();
            c = a.el.getHeight();
            e = Math.floor(c / b)
        }
        return e
    },
    onKeyEnd                 : function(c) {
        var b = this, a = b.views[0];
        if (a.bufferedRenderer) {
            a.bufferedRenderer.scrollTo(b.store.getCount() - 1, false, function(e, d) {
                b.afterKeyNavigate(c, d)
            })
        } else {
            b.afterKeyNavigate(c, a.getRecord(a.all.getCount() - 1))
        }
    },
    onKeyHome                : function(c) {
        var b = this, a = b.views[0];
        if (a.bufferedRenderer) {
            a.bufferedRenderer.scrollTo(0, false, function(e, d) {
                b.afterKeyNavigate(c, d)
            })
        } else {
            b.afterKeyNavigate(c, a.getRecord(0))
        }
    },
    onKeyPageUp              : function(f) {
        var d = this, a = d.views[0], g = d.getRowsVisible(), c, b;
        if (g) {
            if (a.bufferedRenderer) {
                c = Math.max(f.recordIndex - g, 0);
                (d.lastKeyEvent || (d.lastKeyEvent = new Ext.EventObjectImpl())).setEvent(f.browserEvent);
                a.bufferedRenderer.scrollTo(c, false, d.afterBufferedScrollTo, d)
            } else {
                b = a.walkRecs(f.record, -g);
                d.afterKeyNavigate(f, b)
            }
        }
    },
    onKeyPageDown            : function(f) {
        var d = this, a = d.views[0], g = d.getRowsVisible(), c, b;
        if (g) {
            if (a.bufferedRenderer) {
                c = Math.min(f.recordIndex + g, d.store.getCount() - 1);
                (d.lastKeyEvent || (d.lastKeyEvent = new Ext.EventObjectImpl())).setEvent(f.browserEvent);
                a.bufferedRenderer.scrollTo(c, false, d.afterBufferedScrollTo, d)
            } else {
                b = a.walkRecs(f.record, g);
                d.afterKeyNavigate(f, b)
            }
        }
    },
    onKeySpace               : function(b) {
        var a = this.lastFocused;
        if (a) {
            this.afterKeyNavigate(b, a)
        }
    },
    onKeyEnter               : Ext.emptyFn,
    onKeyUp                  : function(b) {
        var a = this.views[0].walkRecs(b.record, -1);
        if (a) {
            this.afterKeyNavigate(b, a)
        }
    },
    onKeyDown                : function(b) {
        var a = this.views[0].walkRecs(b.record, 1);
        if (a) {
            this.afterKeyNavigate(b, a)
        }
    },
    afterBufferedScrollTo    : function(b, a) {
        this.afterKeyNavigate(this.lastKeyEvent, a)
    },
    scrollByDeltaX           : function(d) {
        var a = this.views[0], c = a.up(), b = c.horizontalScroller;
        if (b) {
            b.scrollByDeltaX(d)
        }
    },
    onKeyLeft                : function(a) {
        this.scrollByDeltaX(-this.deltaScroll)
    },
    onKeyRight               : function(a) {
        this.scrollByDeltaX(this.deltaScroll)
    },
    onRowMouseDown           : function(b, a, f, c, g) {
        var d = this;
        if (c !== -1) {
            if (!d.allowRightMouseSelection(g)) {
                return
            }
            if (!d.isSelected(a)) {
                d.mousedownAction = true;
                d.processSelection(b, a, f, c, g)
            } else {
                d.mousedownAction = false
            }
        }
    },
    onVetoUIEvent            : function(f, c, a, h, d, g, b) {
        if (f == "mousedown") {
            this.mousedownAction = !this.isSelected(b)
        }
    },
    onRowClick               : function(b, a, d, c, f) {
        if (this.mousedownAction) {
            this.mousedownAction = false
        } else {
            this.processSelection(b, a, d, c, f)
        }
    },
    processSelection         : function(b, a, d, c, f) {
        this.selectWithEvent(a, f)
    },
    allowRightMouseSelection : function(a) {
        var b = this.ignoreRightMouseSelection && a.button !== 0;
        if (b) {
            b = this.hasSelection()
        }
        return !b
    },
    onSelectChange           : function(f, c, j, a) {
        var h = this, k = h.views, d = k.length, b = k[0].indexOf(f), g = c ? "select" : "deselect", e = 0;
        if ((j || h.fireEvent("before" + g, h, f, b)) !== false && a() !== false) {
            for (; e < d; e++) {
                if (c) {
                    k[e].onRowSelect(b, j)
                } else {
                    k[e].onRowDeselect(b, j)
                }
            }
            if (!j) {
                h.fireEvent(g, h, f, b)
            }
        }
    },
    onLastFocusChanged       : function(g, c, b) {
        var a = this.views, f = a.length, e, d = 0;
        if (g) {
            e = a[0].indexOf(g);
            if (e != -1) {
                for (; d < f; d++) {
                    a[d].onRowFocus(e, false, true)
                }
            }
        }
        if (c) {
            e = a[0].indexOf(c);
            if (e != -1) {
                for (d = 0; d < f; d++) {
                    a[d].onRowFocus(e, true, b)
                }
            }
        }
        this.callParent(arguments)
    },
    onEditorTab              : function(d, h) {
        var f = this, c = f.views[0], b = d.getActiveRecord(), i = d.getActiveColumn(), a = c.getPosition(b, i), g = h.shiftKey ? "left" : "right";
        do {
            a = c.walkCells(a, g, h, f.preventWrap)
        } while (a && (!a.columnHeader.getEditor(b) || !d.startEditByPosition(a)))
    },
    getCurrentPosition       : function() {
        var a = this.selected.items[0];
        if (a) {
            return new Ext.grid.CellContext(this.view).setPosition(this.store.indexOf(a), 0)
        }
    },
    selectByPosition         : function(a) {
        this.select(this.store.getAt(a.row))
    },
    selectNext               : function(g, c) {
        var f = this, b = f.store, e = f.getSelection(), a = e[e.length - 1], d = f.views[0].indexOf(a) + 1, h;
        if (d === b.getCount() || d === 0) {
            h = false
        } else {
            f.doSelect(d, g, c);
            h = true
        }
        return h
    },
    selectPrevious           : function(f, b) {
        var e = this, d = e.getSelection(), a = d[0], c = e.views[0].indexOf(a) - 1, g;
        if (c < 0) {
            g = false
        } else {
            e.doSelect(c, f, b);
            g = true
        }
        return g
    },
    isRowSelected            : function(a, b) {
        return this.isSelected(a)
    }
});
Ext.define("Ext.selection.TreeModel", {
    extend      : "Ext.selection.RowModel",
    alias       : "selection.treemodel",
    constructor : function(a) {
        this.callParent(arguments);
        if (this.pruneRemoved) {
            this.pruneRemoved      = false;
            this.pruneRemovedNodes = true
        }
    },
    bindStore   : function(a, b) {
        var c = this;
        c.callParent(arguments);
        if (c.pruneRemovedNodes) {
            c.view.mon(c.treeStore, {
                remove: c.onNodeRemove,
                scope : c
            })
        }
    },
    onNodeRemove: function(b, c, a) {
        if (!a) {
            this.deselectDeletedRecords([c])
        }
    },
    onKeyRight  : function(b, a) {
        this.navExpand(b, a)
    },
    navExpand   : function(d, b) {
        var c = this.getLastFocused(), a = this.view;
        if (c) {
            if (c.isExpanded()) {
                this.onKeyDown(d, b)
            } else {
                if (c.isExpandable()) {
                    if (!a.isTreeView) {
                        a = a.lockingPartner
                    }
                    a.expand(c)
                }
            }
        }
    },
    onKeyLeft   : function(b, a) {
        this.navCollapse(b, a)
    },
    navCollapse : function(g, c) {
        var d = this, f = this.getLastFocused(), b = this.view, a;
        if (f) {
            a = f.parentNode;
            if (f.isExpanded()) {
                if (!b.isTreeView) {
                    b = b.lockingPartner
                }
                b.collapse(f)
            } else {
                if (a && !a.isRoot()) {
                    if (g.shiftKey) {
                        d.selectRange(a, f, g.ctrlKey, "up");
                        d.setLastFocused(a)
                    } else {
                        if (g.ctrlKey) {
                            d.setLastFocused(a)
                        } else {
                            d.select(a)
                        }
                    }
                }
            }
        }
    },
    onKeySpace  : function(b, a) {
        if (b.record.data.checked != null) {
            this.toggleCheck(b)
        } else {
            this.callParent(arguments)
        }
    },
    onKeyEnter  : function(b, a) {
        if (b.record.data.checked != null) {
            this.toggleCheck(b)
        } else {
            this.callParent(arguments)
        }
    },
    toggleCheck : function(c) {
        var a = this.view, b = this.getLastSelected();
        c.stopEvent();
        if (b) {
            if (!a.isTreeView) {
                a = a.lockingPartner
            }
            a.onCheckChange(b)
        }
    }
});
Ext.define("Ext.tree.Column", {
    extend       : "Ext.grid.column.Column",
    alias        : "widget.treecolumn",
    tdCls        : Ext.baseCSSPrefix + "grid-cell-treecolumn",
    autoLock     : true,
    lockable     : false,
    draggable    : false,
    hideable     : false,
    iconCls      : Ext.baseCSSPrefix + "tree-icon",
    checkboxCls  : Ext.baseCSSPrefix + "tree-checkbox",
    elbowCls     : Ext.baseCSSPrefix + "tree-elbow",
    expanderCls  : Ext.baseCSSPrefix + "tree-expander",
    textCls      : Ext.baseCSSPrefix + "tree-node-text",
    innerCls     : Ext.baseCSSPrefix + "grid-cell-inner-treecolumn",
    isTreeColumn : true,
    cellTpl      : ['<tpl for="lines">', '<img src="{parent.blankUrl}" class="{parent.childCls} {parent.elbowCls}-img ', '{parent.elbowCls}-<tpl if=".">line<tpl else>empty</tpl>"/>', "</tpl>", '<img src="{blankUrl}" class="{childCls} {elbowCls}-img {elbowCls}', '<tpl if="isLast">-end</tpl><tpl if="expandable">-plus {expanderCls}</tpl>"/>', '<tpl if="checked !== null">', '<input type="button" role="checkbox" <tpl if="checked">aria-checked="true" </tpl>', 'class="{childCls} {checkboxCls}<tpl if="checked"> {checkboxCls}-checked</tpl>"/>', "</tpl>", '<img src="{blankUrl}" class="{childCls} {baseIconCls} ', '{baseIconCls}-<tpl if="leaf">leaf<tpl else>parent</tpl> {iconCls}"', '<tpl if="icon">style="background-image:url({icon})"</tpl>/>', '<tpl if="href">', '<a href="{href}" target="{hrefTarget}" class="{textCls} {childCls}">{value}</a>', "<tpl else>", '<span class="{textCls} {childCls}">{value}</span>', "</tpl>"],
    initComponent: function() {
        var a          = this;
        a.origRenderer = a.renderer;
        a.origScope    = a.scope || window;
        a.renderer     = a.treeRenderer;
        a.scope        = a;
        a.callParent()
    },
    treeRenderer : function(k, a, e, b, d, l, i) {
        var h = this, n = e.get("cls"), g = h.origRenderer, c = e.data, j = e.parentNode, m = i.rootVisible, o = [], f;
        if (n) {
            a.tdCls += " " + n
        }
        while (j && (m || j.data.depth > 0)) {
            f                            = j.data;
            o[m ? f.depth : f.depth - 1] = f.isLast ? 0 : 1;
            j                            = j.parentNode
        }
        return h.getTpl("cellTpl").apply({
            record     : e,
            baseIconCls: h.iconCls,
            iconCls    : c.iconCls,
            icon       : c.icon,
            checkboxCls: h.checkboxCls,
            checked    : c.checked,
            elbowCls   : h.elbowCls,
            expanderCls: h.expanderCls,
            textCls    : h.textCls,
            leaf       : c.leaf,
            expandable : e.isExpandable(),
            isLast     : c.isLast,
            blankUrl   : Ext.BLANK_IMAGE_URL,
            href       : c.href,
            hrefTarget : c.hrefTarget,
            lines      : o,
            metaData   : a,
            childCls   : h.getChildCls ? h.getChildCls() + " " : "",
            value      : g ? g.apply(h.origScope, arguments) : k
        })
    }
});
Ext.define("Ext.selection.CheckboxModel", {
    alias                   : "selection.checkboxmodel",
    extend                  : "Ext.selection.RowModel",
    mode                    : "MULTI",
    injectCheckbox          : 0,
    checkOnly               : false,
    showHeaderCheckbox      : undefined,
    checkSelector           : "." + Ext.baseCSSPrefix + "grid-row-checker",
    headerWidth             : 24,
    checkerOnCls            : Ext.baseCSSPrefix + "grid-hd-checker-on",
    constructor             : function() {
        var a = this;
        a.callParent(arguments);
        if (a.mode === "SINGLE" && a.showHeaderCheckbox !== true) {
            a.showHeaderCheckbox = false
        }
    },
    beforeViewRender        : function(b) {
        var c = this, a;
        c.callParent(arguments);
        if (!c.hasLockedHeader() || b.headerCt.lockedCt) {
            if (c.showHeaderCheckbox !== false) {
                b.headerCt.on("headerclick", c.onHeaderClick, c)
            }
            c.addCheckbox(b, true);
            a = b.ownerCt;
            if (b.headerCt.lockedCt) {
                a = a.ownerCt
            }
            c.mon(a, "reconfigure", c.onReconfigure, c)
        }
    },
    bindComponent           : function(a) {
        var b      = this;
        b.sortable = false;
        b.callParent(arguments)
    },
    hasLockedHeader         : function() {
        var a = this.views, c = a.length, b;
        for (b = 0; b < c; b++) {
            if (a[b].headerCt.lockedCt) {
                return true
            }
        }
        return false
    },
    addCheckbox             : function(a, b) {
        var c = this, d = c.injectCheckbox, e = a.headerCt;
        if (d !== false) {
            if (d == "first") {
                d = 0
            } else {
                if (d == "last") {
                    d = e.getColumnCount()
                }
            }
            Ext.suspendLayouts();
            if (a.getStore().buffered) {
                c.showHeaderCheckbox = false
            }
            e.add(d, c.getHeaderConfig());
            Ext.resumeLayouts()
        }
        if (b !== true) {
            a.refresh()
        }
    },
    onReconfigure           : function(c, a, b) {
        if (b) {
            this.addCheckbox(this.views[0])
        }
    },
    toggleUiHeader          : function(e) {
        var b = this.views[0], d = b.headerCt, c = d.child("gridcolumn[isCheckerHd]"), a = this.checkerOnCls;
        if (c) {
            if (e) {
                c.addCls(a)
            } else {
                c.removeCls(a)
            }
        }
    },
    onHeaderClick           : function(c, f, b) {
        if (f.isCheckerHd) {
            b.stopEvent();
            var a          = this, d = f.el.hasCls(Ext.baseCSSPrefix + "grid-hd-checker-on");
            a.preventFocus = true;
            if (d) {
                a.deselectAll()
            } else {
                a.selectAll()
            }
            delete a.preventFocus
        }
    },
    getHeaderConfig         : function() {
        var a = this, b = a.showHeaderCheckbox !== false;
        return {
            isCheckerHd    : b,
            text           : "&#160;",
            clickTargetName: "el",
            width          : a.headerWidth,
            sortable       : false,
            draggable      : false,
            resizable      : false,
            hideable       : false,
            menuDisabled   : true,
            dataIndex      : "",
            cls            : b ? Ext.baseCSSPrefix + "column-header-checkbox " : "",
            renderer       : Ext.Function.bind(a.renderer, a),
            editRenderer   : a.editRenderer || a.renderEmpty,
            locked         : a.hasLockedHeader()
        }
    },
    renderEmpty             : function() {
        return "&#160;"
    },
    refresh                 : function() {
        this.callParent(arguments);
        this.updateHeaderState()
    },
    renderer                : function(g, c, b, h, e, d, a) {
        var f   = Ext.baseCSSPrefix;
        c.tdCls = f + "grid-cell-special " + f + "grid-cell-row-checker";
        return '<div class="' + f + 'grid-row-checker">&#160;</div>'
    },
    processSelection        : function(b, a, g, d, h) {
        var f = this, c = h.getTarget(f.checkSelector), i;
        if (f.checkOnly && !c) {
            return
        }
        if (c) {
            i = f.getSelectionMode();
            if (i !== "SINGLE") {
                f.setSelectionMode("SIMPLE")
            }
            f.selectWithEvent(a, h);
            f.setSelectionMode(i)
        } else {
            f.selectWithEvent(a, h)
        }
    },
    onSelectChange          : function() {
        this.callParent(arguments);
        if (!this.suspendChange) {
            this.updateHeaderState()
        }
    },
    onStoreLoad             : function() {
        this.callParent(arguments);
        this.updateHeaderState()
    },
    onStoreAdd              : function() {
        this.callParent(arguments);
        this.updateHeaderState()
    },
    onStoreRemove           : function() {
        this.callParent(arguments);
        this.updateHeaderState()
    },
    onStoreRefresh          : function() {
        this.callParent(arguments);
        this.updateHeaderState()
    },
    maybeFireSelectionChange: function(a) {
        if (a && !this.suspendChange) {
            this.updateHeaderState()
        }
        this.callParent(arguments)
    },
    resumeChanges           : function() {
        this.callParent();
        if (!this.suspendChange) {
            this.updateHeaderState()
        }
    },
    updateHeaderState       : function() {
        var f = this, g = f.store, e = g.getCount(), h = f.views, j = false, a = 0, b, d, c;
        if (!g.buffered && e > 0) {
            b = f.selected;
            j = true;
            for (c = 0, d = b.getCount(); c < d; ++c) {
                if (!f.storeHasSelected(b.getAt(c))) {
                    break
                }
                ++a
            }
            j = e === a
        }
        if (h && h.length) {
            f.toggleUiHeader(j)
        }
    }
});
Ext.define("Ext.toolbar.Spacer", {
    extend            : "Ext.Component",
    alias             : "widget.tbspacer",
    alternateClassName: "Ext.Toolbar.Spacer",
    baseCls           : Ext.baseCSSPrefix + "toolbar-spacer",
    focusable         : false
});
Ext.define("Ext.tree.Panel", {
    extend            : "Ext.panel.Table",
    alias             : "widget.treepanel",
    alternateClassName: ["Ext.tree.TreePanel", "Ext.TreePanel"],
    requires          : ["Ext.tree.View", "Ext.selection.TreeModel", "Ext.tree.Column", "Ext.data.TreeStore"],
    viewType          : "treeview",
    selType           : "treemodel",
    treeCls           : Ext.baseCSSPrefix + "tree-panel",
    deferRowRender    : false,
    rowLines          : false,
    lines             : true,
    useArrows         : false,
    singleExpand      : false,
    ddConfig          : {
        enableDrag: true,
        enableDrop: true
    },
    rootVisible       : true,
    displayField      : "text",
    root              : null,
    normalCfgCopy     : ["displayField", "root", "singleExpand", "useArrows", "lines", "rootVisible", "scroll"],
    lockedCfgCopy     : ["displayField", "root", "singleExpand", "useArrows", "lines", "rootVisible"],
    isTree            : true,
    arrowCls          : Ext.baseCSSPrefix + "tree-arrows",
    linesCls          : Ext.baseCSSPrefix + "tree-lines",
    noLinesCls        : Ext.baseCSSPrefix + "tree-no-lines",
    autoWidthCls      : Ext.baseCSSPrefix + "autowidth-table",
    constructor       : function(a) {
        a = a || {};
        if (a.animate === undefined) {
            a.animate = Ext.isBoolean(this.animate) ? this.animate : Ext.enableFx
        }
        this.enableAnimations = a.animate;
        delete a.animate;
        this.callParent([a])
    },
    initComponent     : function() {
        var d = this, b = [d.treeCls], c = d.store, a;
        if (d.useArrows) {
            b.push(d.arrowCls);
            d.lines = false
        }
        if (d.lines) {
            b.push(d.linesCls)
        } else {
            if (!d.useArrows) {
                b.push(d.noLinesCls)
            }
        }
        if (Ext.isString(c)) {
            c = d.store = Ext.StoreMgr.lookup(c)
        } else {
            if (!c || Ext.isObject(c) && !c.isStore) {
                c = d.store = new Ext.data.TreeStore(Ext.apply({
                    root      : d.root,
                    fields    : d.fields,
                    model     : d.model,
                    folderSort: d.folderSort
                }, c))
            } else {
                if (d.root) {
                    c = d.store = Ext.data.StoreManager.lookup(c);
                    c.setRootNode(d.root);
                    if (d.folderSort !== undefined) {
                        c.folderSort = d.folderSort;
                        c.sort()
                    }
                }
            }
        }
        d.viewConfig = Ext.apply({
            rootVisible : d.rootVisible,
            animate     : d.enableAnimations,
            singleExpand: d.singleExpand,
            node        : c.getRootNode(),
            hideHeaders : d.hideHeaders
        }, d.viewConfig);
        if (!d.columns) {
            if (d.initialConfig.hideHeaders === undefined) {
                d.hideHeaders = true
            }
            d.addCls(d.autoWidthCls);
            d.columns = [{
                xtype    : "treecolumn",
                text     : "Name",
                width    : Ext.isIE6 ? "100%" : 10000,
                dataIndex: d.displayField
            }]
        }
        if (d.cls) {
            b.push(d.cls)
        }
        d.cls = b.join(" ");
        d.callParent();
        d.selModel.treeStore = d.store;
        a                    = d.getView();
        d.relayEvents(a, ["checkchange", "afteritemexpand", "afteritemcollapse"]);
        if (!a.isLockingView) {
            if (!a.rootVisible && !d.getRootNode()) {
                d.setRootNode({expanded: true})
            }
        }
    },
    bindStore         : function(a, b) {
        var c            = this;
        c.store          = a;
        c.storeListeners = c.mon(a, {
            destroyable: true,
            load       : c.onStoreLoad,
            rootchange : c.onRootChange,
            clear      : c.onClear,
            scope      : c
        });
        c.storeRelayers  = c.relayEvents(a, ["beforeload", "load"]);
        c.storeRelayers1 = c.mon(a, {
            destroyable   : true,
            append        : c.createRelayer("itemappend"),
            remove        : c.createRelayer("itemremove"),
            move          : c.createRelayer("itemmove", [0, 4]),
            insert        : c.createRelayer("iteminsert"),
            beforeappend  : c.createRelayer("beforeitemappend"),
            beforeremove  : c.createRelayer("beforeitemremove"),
            beforemove    : c.createRelayer("beforeitemmove"),
            beforeinsert  : c.createRelayer("beforeiteminsert"),
            expand        : c.createRelayer("itemexpand", [0, 1]),
            collapse      : c.createRelayer("itemcollapse", [0, 1]),
            beforeexpand  : c.createRelayer("beforeitemexpand", [0, 1]),
            beforecollapse: c.createRelayer("beforeitemcollapse", [0, 1])
        });
        a.ownerTree      = c;
        if (!b) {
            c.view.setRootNode(c.getRootNode())
        }
    },
    unbindStore       : function() {
        var b = this, a = b.store;
        if (a) {
            Ext.destroy(b.storeListeners, b.storeRelayers, b.storeRelayers1);
            delete a.ownerTree
        }
    },
    onClear           : function() {
        this.view.onClear()
    },
    setRootNode       : function() {
        return this.store.setRootNode.apply(this.store, arguments)
    },
    getRootNode       : function() {
        return this.store.getRootNode()
    },
    onRootChange      : function(a) {
        this.view.setRootNode(a)
    },
    getChecked        : function() {
        return this.getView().getChecked()
    },
    isItemChecked     : function(a) {
        return a.get("checked")
    },
    expandNode        : function(b, a, d, c) {
        return this.getView().expand(b, a, d, c || this)
    },
    collapseNode      : function(b, a, d, c) {
        return this.getView().collapse(b, a, d, c || this)
    },
    expandAll         : function(e, c) {
        var d = this, a = d.getRootNode(), b = d.enableAnimations;
        if (a) {
            if (!b) {
                Ext.suspendLayouts()
            }
            a.expand(true, e, c || d);
            if (!b) {
                Ext.resumeLayouts(true)
            }
        }
    },
    collapseAll       : function(f, d) {
        var e = this, b = e.getRootNode(), c = e.enableAnimations, a = e.getView();
        if (b) {
            if (!c) {
                Ext.suspendLayouts()
            }
            d = d || e;
            if (a.rootVisible) {
                b.collapse(true, f, d)
            } else {
                b.collapseChildren(true, f, d)
            }
            if (!c) {
                Ext.resumeLayouts(true)
            }
        }
    },
    expandPath        : function(k, f, a, g, j) {
        var d = this, c = d.getRootNode(), b = 1, e = d.getView(), i, h;
        f     = f || d.getRootNode().idProperty;
        a     = a || "/";
        if (Ext.isEmpty(k)) {
            Ext.callback(g, j || d, [false, null]);
            return
        }
        i = k.split(a);
        if (c.get(f) != i[1]) {
            Ext.callback(g, j || d, [false, c]);
            return
        }
        h = function() {
            if (++b === i.length) {
                Ext.callback(g, j || d, [true, c]);
                return
            }
            var l = c.findChild(f, i[b]);
            if (!l) {
                Ext.callback(g, j || d, [false, c]);
                return
            }
            c = l;
            c.expand(false, h)
        };
        c.expand(false, h)
    },
    selectPath        : function(i, d, a, f, h) {
        var b = this, c, g, e;
        d     = d || b.getRootNode().idProperty;
        a     = a || "/";
        g     = i.split(a);
        e     = g.pop();
        if (g.length > 1) {
            b.expandPath(g.join(a), d, a, function(l, k) {
                var j = k;
                if (l && k) {
                    k = k.findChild(d, e);
                    if (k) {
                        b.getSelectionModel().select(k);
                        Ext.callback(f, h || b, [true, k]);
                        return
                    }
                }
                Ext.callback(f, h || b, [false, j])
            }, b)
        } else {
            c = b.getRootNode();
            if (c.getId() === e) {
                b.getSelectionModel().select(c);
                Ext.callback(f, h || b, [true, c])
            } else {
                Ext.callback(f, h || b, [false, null])
            }
        }
    }
});
Ext.define("Ext.view.DragZone", {
    extend         : "Ext.dd.DragZone",
    containerScroll: false,
    constructor    : function(b) {
        var e = this, a, d, c;
        Ext.apply(e, b);
        if (!e.ddGroup) {
            e.ddGroup = "view-dd-zone-" + e.view.id
        }
        a = e.view;
        d = a.ownerCt;
        if (d) {
            c = d.getTargetEl().dom
        } else {
            c = a.el.dom.parentNode
        }
        e.callParent([c]);
        e.ddel = Ext.get(document.createElement("div"));
        e.ddel.addCls(Ext.baseCSSPrefix + "grid-dd-wrap")
    },
    init           : function(c, a, b) {
        this.initTarget(c, a, b);
        this.view.mon(this.view, {
            itemmousedown: this.onItemMouseDown,
            scope        : this
        })
    },
    onValidDrop    : function(b, a, c) {
        this.callParent();
        b.el.focus()
    },
    onItemMouseDown: function(b, a, d, c, f) {
        if (!this.isPreventDrag(f, a, d, c)) {
            if (b.focusRow) {
                b.focusRow(a)
            }
            this.handleMouseDown(f)
        }
    },
    isPreventDrag  : function(a) {
        return false
    },
    getDragData    : function(c) {
        var a = this.view, b = c.getTarget(a.getItemSelector());
        if (b) {
            return {
                copy        : a.copy || (a.allowCopy && c.ctrlKey),
                event       : new Ext.EventObjectImpl(c),
                view        : a,
                ddel        : this.ddel,
                item        : b,
                records     : a.getSelectionModel().getSelection(),
                fromPosition: Ext.fly(b).getXY()
            }
        }
    },
    onInitDrag     : function(b, g) {
        var e = this, f = e.dragData, d = f.view, a = d.getSelectionModel(), c = d.getRecord(f.item);
        if (!a.isSelected(c)) {
            a.select(c, true)
        }
        f.records = a.getSelection();
        e.ddel.update(e.getDragText());
        e.proxy.update(e.ddel.dom);
        e.onStartDrag(b, g);
        return true
    },
    getDragText    : function() {
        var a = this.dragData.records.length;
        return Ext.String.format(this.dragText, a, a == 1 ? "" : "s")
    },
    getRepairXY    : function(b, a) {
        return a ? a.fromPosition : false
    }
});
Ext.define("Ext.tree.ViewDragZone", {
    extend       : "Ext.view.DragZone",
    isPreventDrag: function(b, a) {
        return (a.get("allowDrag") === false) || !!b.getTarget(this.view.expanderSelector)
    },
    getDragText  : function() {
        var a = this.dragData.records, b = a.length, d = a[0].get(this.displayField), c = "s";
        if (b === 1 && d) {
            return d
        } else {
            if (!d) {
                c = ""
            }
        }
        return Ext.String.format(this.dragText, b, c)
    },
    afterRepair  : function() {
        var g = this, a = g.view, h = a.selectedItemCls, b = g.dragData.records, f, e = b.length, c = Ext.fly, d;
        if (Ext.enableFx && g.repairHighlight) {
            for (f = 0; f < e; f++) {
                d = a.getNode(b[f]);
                c(d.firstChild).highlight(g.repairHighlightColor, {
                    listeners: {
                        beforeanimate: function() {
                            if (a.isSelected(d)) {
                                c(d).removeCls(h)
                            }
                        },
                        afteranimate : function() {
                            if (a.isSelected(d)) {
                                c(d).addCls(h)
                            }
                        }
                    }
                })
            }
        }
        g.dragging = false
    }
});
Ext.define("Ext.tree.ViewDropZone", {
    extend             : "Ext.view.DropZone",
    allowParentInserts : false,
    allowContainerDrops: false,
    appendOnly         : false,
    expandDelay        : 500,
    indicatorCls       : Ext.baseCSSPrefix + "tree-ddindicator",
    expandNode         : function(b) {
        var a             = this.view;
        this.expandProcId = false;
        if (!b.isLeaf() && !b.isExpanded()) {
            a.expand(b);
            this.expandProcId = false
        }
    },
    queueExpand        : function(a) {
        this.expandProcId = Ext.Function.defer(this.expandNode, this.expandDelay, this, [a])
    },
    cancelExpand       : function() {
        if (this.expandProcId) {
            clearTimeout(this.expandProcId);
            this.expandProcId = false
        }
    },
    getPosition        : function(f, b) {
        var i = this.view, c = i.getRecord(b), g = f.getPageY(), j = c.isLeaf(), a = false, h = Ext.fly(b).getRegion(), d;
        if (c.isRoot()) {
            return "append"
        }
        if (this.appendOnly) {
            return j ? false : "append"
        }
        if (!this.allowParentInserts) {
            a = c.hasChildNodes() && c.isExpanded()
        }
        d = (h.bottom - h.top) / (j ? 2 : 3);
        if (g >= h.top && g < (h.top + d)) {
            return "before"
        } else {
            if (!a && (j || (g >= (h.bottom - d) && g <= h.bottom))) {
                return "after"
            } else {
                return "append"
            }
        }
    },
    isValidDropPoint   : function(b, h, m, j, f) {
        if (!b || !f.item) {
            return false
        }
        var n = this.view, k = n.getRecord(b), d = f.records, a = d.length, l = d.length, c, g;
        if (!(k && h && a)) {
            return false
        }
        for (c = 0; c < l; c++) {
            g = d[c];
            if (g.isNode && g.contains(k)) {
                return false
            }
        }
        if (h === "append" && k.get("allowDrop") === false) {
            return false
        } else {
            if (h != "append" && k.parentNode.get("allowDrop") === false) {
                return false
            }
        }
        if (Ext.Array.contains(d, k)) {
            return false
        }
        return n.fireEvent("nodedragover", k, h, f, j) !== false
    },
    onNodeOver         : function(a, h, f, c) {
        var d = this.getPosition(f, a), b = this.dropNotAllowed, i = this.view, g = i.getRecord(a), j = this.getIndicator(), k = 0;
        this.cancelExpand();
        if (d == "append" && !this.expandProcId && !Ext.Array.contains(c.records, g) && !g.isLeaf() && !g.isExpanded()) {
            this.queueExpand(g)
        }
        if (this.isValidDropPoint(a, d, h, f, c)) {
            this.valid           = true;
            this.currentPosition = d;
            this.overRecord      = g;
            j.setWidth(Ext.fly(a).getWidth());
            k = Ext.fly(a).getY() - Ext.fly(i.el).getY() - 1;
            if (d == "before") {
                b = g.isFirst() ? Ext.baseCSSPrefix + "tree-drop-ok-above" : Ext.baseCSSPrefix + "tree-drop-ok-between";
                j.showAt(0, k);
                h.proxy.show()
            } else {
                if (d == "after") {
                    b = g.isLast() ? Ext.baseCSSPrefix + "tree-drop-ok-below" : Ext.baseCSSPrefix + "tree-drop-ok-between";
                    k += Ext.fly(a).getHeight();
                    j.showAt(0, k);
                    h.proxy.show()
                } else {
                    b = Ext.baseCSSPrefix + "tree-drop-ok-append";
                    j.hide()
                }
            }
        } else {
            this.valid = false
        }
        this.currentCls = b;
        return b
    },
    onNodeOut          : function(d, a, c, b) {
        this.valid = false;
        this.getIndicator().hide()
    },
    onContainerOver    : function(a, c, b) {
        return c.getTarget("." + this.indicatorCls) ? this.currentCls : this.dropNotAllowed
    },
    notifyOut          : function() {
        this.callParent(arguments);
        this.cancelExpand()
    },
    handleNodeDrop     : function(f, m, h) {
        var o = this, a = o.view, j = m ? m.parentNode : a.panel.getRootNode(), b = a.getStore().treeStore.model, c, e, l, g, d, k, n, p;
        if (f.copy) {
            c         = f.records;
            f.records = [];
            for (e = 0, l = c.length; e < l; e++) {
                g = c[e];
                if (g.isNode) {
                    f.records.push(g.copy(undefined, true))
                } else {
                    f.records.push(new b(g.data, g.getId()))
                }
            }
        }
        o.cancelExpand();
        if (h == "before") {
            d = j.insertBefore;
            k = [null, m];
            m = j
        } else {
            if (h == "after") {
                if (m.nextSibling) {
                    d = j.insertBefore;
                    k = [null, m.nextSibling]
                } else {
                    d = j.appendChild;
                    k = [null]
                }
                m = j
            } else {
                if (!(m.isExpanded() || m.isLoading())) {
                    n = true
                }
                d = m.appendChild;
                k = [null]
            }
        }
        p = function() {
            var i, q;
            Ext.suspendLayouts();
            a.getSelectionModel().clearSelections();
            for (e = 0, l = f.records.length; e < l; e++) {
                g = f.records[e];
                if (!g.isNode) {
                    if (g.isModel) {
                        g = new b(g.data, g.getId())
                    } else {
                        g = new b(g)
                    }
                    f.records[e] = g
                }
                k[0] = g;
                d.apply(m, k)
            }
            if (o.sortOnDrop) {
                m.sort(m.getOwnerTree().store.generateComparator())
            }
            Ext.resumeLayouts(true);
            if (Ext.enableFx && o.dropHighlight) {
                i = o.dropHighlightColor;
                for (e = 0; e < l; e++) {
                    q = a.getNode(f.records[e]);
                    if (q) {
                        Ext.fly(q).highlight(i)
                    }
                }
            }
        };
        if (n) {
            m.expand(false, p)
        } else {
            if (m.isLoading()) {
                m.on({
                    expand: p,
                    delay : 1,
                    single: true
                })
            } else {
                p()
            }
        }
    }
});
Ext.define("Ext.tree.plugin.TreeViewDragDrop", {
    extend               : "Ext.AbstractPlugin",
    alias                : "plugin.treeviewdragdrop",
    uses                 : ["Ext.tree.ViewDragZone", "Ext.tree.ViewDropZone"],
    dragText             : "{0} selected node{1}",
    allowParentInserts   : false,
    allowContainerDrops  : false,
    appendOnly           : false,
    ddGroup              : "TreeDD",
    containerScroll      : false,
    expandDelay          : 1000,
    enableDrop           : true,
    enableDrag           : true,
    nodeHighlightColor   : "c3daf9",
    nodeHighlightOnDrop  : Ext.enableFx,
    nodeHighlightOnRepair: Ext.enableFx,
    displayField         : "text",
    init                 : function(a) {
        a.on("render", this.onViewRender, this, {single: true})
    },
    destroy              : function() {
        Ext.destroy(this.dragZone, this.dropZone)
    },
    onViewRender         : function(a) {
        var b = this, c;
        if (b.enableDrag) {
            if (b.containerScroll) {
                c = a.getEl()
            }
            b.dragZone = new Ext.tree.ViewDragZone({
                view                : a,
                ddGroup             : b.dragGroup || b.ddGroup,
                dragText            : b.dragText,
                displayField        : b.displayField,
                repairHighlightColor: b.nodeHighlightColor,
                repairHighlight     : b.nodeHighlightOnRepair,
                scrollEl            : c
            })
        }
        if (b.enableDrop) {
            b.dropZone = new Ext.tree.ViewDropZone({
                view               : a,
                ddGroup            : b.dropGroup || b.ddGroup,
                allowContainerDrops: b.allowContainerDrops,
                appendOnly         : b.appendOnly,
                allowParentInserts : b.allowParentInserts,
                expandDelay        : b.expandDelay,
                dropHighlightColor : b.nodeHighlightColor,
                dropHighlight      : b.nodeHighlightOnDrop,
                sortOnDrop         : b.sortOnDrop,
                containerScroll    : b.containerScroll
            })
        }
    }
}, function() {
    var a                 = this.prototype;
    a.nodeHighlightOnDrop = a.nodeHighlightOnRepair = Ext.enableFx
});
Ext.define("Ext.ux.PreviewPlugin", {
    extend         : "Ext.AbstractPlugin",
    alias          : "plugin.preview",
    requires       : ["Ext.grid.feature.RowBody", "Ext.grid.feature.RowWrap"],
    hideBodyCls    : "x-grid-row-body-hidden",
    bodyField      : "",
    previewExpanded: true,
    setCmp         : function(b) {
        this.callParent(arguments);
        var a             = this.bodyField, d = this.hideBodyCls, c = [{
            ftype            : "rowbody",
            getAdditionalData: function(j, f, h, k, g) {
                var e = Ext.grid.feature.RowBody.prototype.getAdditionalData, i = {
                    rowBody   : j[a],
                    rowBodyCls: b.previewExpanded ? "" : d
                };
                if (e) {
                    Ext.apply(i, e.apply(this, arguments))
                }
                return i
            }
        }, {ftype: "rowwrap"}];
        b.previewExpanded = this.previewExpanded;
        if (!b.features) {
            b.features = []
        }
        b.features = c.concat(b.features)
    },
    toggleExpanded : function(b) {
        var a                = this.getCmp();
        this.previewExpanded = a.previewExpanded = b;
        a.refresh()
    }
});
Ext.define("am.proxy.PhpProxy", {
    extend       : "Ext.data.proxy.Ajax",
    alias        : "proxy.php",
    batchActions : false,
    actionMethods: {
        destroy: "DELETE",
        create : "PUT",
        update : "POST",
        read   : "GET"
    },
    constructor  : function(a) {
        this.callParent([a]);
        this.setReader({
            type           : "json",
            root           : "data",
            successProperty: "success"
        });
        this.setWriter({
            type           : "json",
            root           : "data",
            successProperty: "success"
        })
    }
});
Ext.define("am.model.File", {
    extend    : "Ext.data.Model",
    idProperty: "path",
    fields    : [{
        name: "path",
        type: "string"
    }, {
        name: "text",
        type: "string"
    }, {
        name: "leaf",
        type: "boolean"
    }, {
        name        : "loaded",
        type        : "boolean",
        defaultValue: false
    }, {
        name        : "expanded",
        type        : "boolean",
        defaultValue: false
    }, {
        name: "size",
        type: "int"
    }, {
        name: "iconCls",
        type: "string"
    }, {
        name: "extension",
        type: "string"
    }, {
        name: "date_modified",
        type: "date"
    }]
});
Ext.define("am.model.Text", {
    extend    : "Ext.data.Model",
    idProperty: "text_nr",
    fields    : [{
        name: "text_nr",
        type: "int"
    }, {
        name: "user_nr",
        type: "int"
    }, {
        name: "type_uid",
        type: "int"
    }, {
        name: "title",
        type: "string"
    }, {
        name: "teaser",
        type: "string"
    }, {
        name: "text",
        type: "string"
    }, {
        name: "additional_text",
        type: "string"
    }, {
        name: "evt_create",
        type: "date"
    }, {
        name: "image_path",
        type: "string"
    }]
});
Ext.define("am.store.TextsStore", {
    extend  : "Ext.data.Store",
    model   : "am.model.Text",
    storeId : "TextsStore",
    autoLoad: true,
    sorters : {
        property : "evt_create",
        direction: "desc"
    },
    proxy   : {
        type: "php",
        url : "../data/apollomin/texts.php"
    }
});
Ext.define("am.model.Event", {
    extend    : "Ext.data.Model",
    idProperty: "event_nr",
    fields    : [{
        name: "event_nr",
        type: "int"
    }, {
        name: "text_nr",
        type: "int"
    }, {
        name: "start_location",
        type: "string"
    }, {
        name: "end_location",
        type: "string"
    }, {
        name: "evt_start",
        type: "date"
    }, {
        name: "evt_end",
        type: "date"
    }, {
        name: "user_nr",
        type: "int"
    }, {
        name: "type_uid",
        type: "int"
    }, {
        name: "title",
        type: "string"
    }, {
        name: "teaser",
        type: "string"
    }, {
        name: "text",
        type: "string"
    }, {
        name: "additional_text",
        type: "string"
    }, {
        name: "evt_create",
        type: "date"
    }]
});
Ext.define("am.store.EventsStore", {
    extend  : "Ext.data.Store",
    model   : "am.model.Event",
    autoLoad: true,
    storeId : "EventsStore",
    sorters : {
        property : "evt_create",
        direction: "desc"
    },
    proxy   : {
        type: "php",
        url : "../data/apollomin/events.php"
    }
});
Ext.define("am.store.FilesStore", {
    extend             : "Ext.data.TreeStore",
    model              : "am.model.File",
    storeId            : "FilesStore",
    defaultRootProperty: "data",
    root               : {
        expanded: true,
        text    : "upload/",
        path    : "upload/"
    },
    proxy              : {
        type: "php",
        url : "../data/apollomin/files.php"
    }
});
Ext.define("am.model.User", {
    extend    : "Ext.data.Model",
    idProperty: "user_nr",
    fields    : [{
        name: "user_nr",
        type: "int"
    }, {
        name: "login",
        type: "string"
    }, {
        name: "password",
        type: "string"
    }, {
        name: "forename",
        type: "string"
    }, {
        name: "lastname",
        type: "string"
    }, {
        name: "email",
        type: "string"
    }, {
        name: "evt_create",
        type: "date"
    }]
});
Ext.define("am.store.UsersStore", {
    extend  : "Ext.data.Store",
    model   : "am.model.User",
    storeId : "UsersStore",
    autoLoad: true,
    proxy   : {
        type: "php",
        url : "../data/apollomin/users.php"
    }
});
Ext.define("am.store.ImagesStore", {
    extend : "Ext.data.TreeStore",
    model  : "am.model.File",
    storeId: "ImagesStore",
    root   : {
        expanded: true,
        text    : "upload/",
        path    : "upload/"
    },
    proxy  : {
        type         : "ajax",
        url          : "../data/apollomin/files.php",
        batchActions : false,
        actionMethods: {
            destroy: "DELETE",
            create : "PUT",
            update : "POST",
            read   : "GET"
        },
        extraParams  : {only_images: "true"},
        reader       : {
            type           : "json",
            root           : "data",
            successProperty: "success"
        },
        writer       : {
            type           : "json",
            root           : "data",
            successProperty: "success"
        }
    }
});
Ext.define("am.model.UserCode", {
    extend    : "Ext.data.Model",
    idProperty: "uc_uid",
    fields    : [{
        name: "uc_uid",
        type: "int"
    }, {
        name: "code_type",
        type: "int"
    }, {
        name: "text",
        type: "string"
    }, {
        name: "sort",
        type: "int"
    }, {
        name: "enabled",
        type: "boolean"
    }]
});
Ext.define("am.store.UserCodesStore", {
    extend       : "Ext.data.Store",
    model        : "am.model.UserCode",
    storeId      : "UserCodesStore",
    sorters      : {
        property : "sort",
        direction: "ASC"
    },
    proxy        : {
        type: "php",
        url : "../data/apollomin/usercodes.php"
    },
    isCodeEnabled: function(b) {
        var a = this.getById(b);
        return a && a.get("enabled")
    }
});
Ext.define("am.model.Navigation", {
    extend: "Ext.data.Model",
    fields: ["name", "group", "xtype", "sort", "param"]
});
Ext.define("am.view.AbstractTextListView", {
    extend                : "Ext.grid.Panel",
    requires              : ["Ext.ux.PreviewPlugin"],
    title                 : "Texts",
    autoScroll            : true,
    cls                   : "text-grid",
    rowLines              : false,
    viewConfig            : {stripeRows: false},
    plugins               : [{
        pluginId : "preview",
        ptype    : "preview",
        bodyField: "teaser",
        expanded : true
    }],
    viewTypeUid           : null,
    navigationSelectedView: function(b) {
        var a            = this.getStore();
        this.viewTypeUid = b;
        if (!this.viewTypeUid) {
            a.clearFilter(false)
        } else {
            a.clearFilter(true);
            a.filter("type_uid", this.viewTypeUid)
        }
    },
    contextMenu           : null,
    initComponent         : function() {
        var b         = this;
        var c         = Ext.create("Ext.Action", {
            text  : "Neu...",
            itemId: "newtext",
            view  : b
        });
        var d         = Ext.create("Ext.Action", {
            text    : "Bearbeiten...",
            itemId  : "edittext",
            view    : b,
            disabled: true
        });
        var a         = Ext.create("Ext.Action", {
            text    : "L\xf6schen...",
            itemId  : "deletetext",
            view    : b,
            disabled: true
        });
        b.dockedItems = [{
            xtype: "toolbar",
            items: [c, d, a]
        }];
        b.contextMenu = Ext.create("Ext.menu.Menu", {
            plain: true,
            items: [c, d, a]
        });
        b.addListener("itemcontextmenu", function(f, e, i, g, h) {
            h.stopEvent();
            b.getSelectionModel().select(g);
            b.contextMenu.showAt(h.xy)
        });
        b.addListener("containercontextmenu", function(e, f) {
            f.stopEvent();
            b.getSelectionModel().deselectAll();
            b.contextMenu.showAt(f.xy)
        });
        b.addListener("selectionchange", function(f, e) {
            d.setDisabled(f.getCount() != 1);
            a.setDisabled(f.getCount() != 1)
        });
        b.callParent(arguments)
    },
    formatTitle           : function(d, e, b) {
        var a = "";
        var c = Ext.getStore("UsersStore").getById(b.get("user_nr"));
        if (c) {
            a = "Author: " + c.get("login")
        }
        return Ext.String.format('<div class="title x-tree-icon-leaf"><b>{0}</b><span class="author">{1}</span></div>', d, a)
    },
    formatDate            : function(b) {
        if (!b) {
            return ""
        }
        var a = new Date(), e = Ext.Date.clearTime(a, true), c = Ext.Date.clearTime(b, true).getTime();
        if (c === e.getTime()) {
            return "Heute " + Ext.Date.format(b, "H:i")
        }
        e = Ext.Date.add(e, "d", -6);
        if (e.getTime() <= c) {
            return Ext.Date.format(b, "l, H:i")
        }
        return Ext.Date.format(b, "d.m.Y H:i")
    }
});
Ext.define("am.view.TextListView", {
    extend       : "am.view.AbstractTextListView",
    alias        : "widget.textlistview",
    store        : "TextsStore",
    initComponent: function() {
        this.columns = [{
            header   : "Titel",
            dataIndex: "title",
            flex     : 1,
            renderer : this.formatTitle
        }, {
            header   : "Erstellungsdatum",
            dataIndex: "evt_create",
            renderer : this.formatDate,
            align    : "right",
            width    : 180
        }];
        this.callParent(arguments)
    }
});
Ext.define("am.view.EventTextListView", {
    extend       : "am.view.AbstractTextListView",
    alias        : "widget.eventtextlistview",
    store        : "EventsStore",
    initComponent: function() {
        this.columns = [{
            header   : "Titel",
            dataIndex: "title",
            flex     : 1,
            renderer : this.formatTitle
        }, {
            header   : "Beginn",
            dataIndex: "evt_start",
            renderer : this.formatDate,
            align    : "right",
            width    : 180
        }, {
            header   : "Ende",
            dataIndex: "evt_end",
            renderer : this.formatDate,
            align    : "right",
            width    : 180
        }];
        this.callParent(arguments)
    }
});
Ext.define("Ext.ux.upload.uploader.AbstractUploader", {
    mixins     : {observable: "Ext.util.Observable"},
    config     : {
        maxFileSize   : 50000000,
        url           : "",
        timeout       : 60 * 1000,
        contentType   : "application/binary",
        filenameHeader: "X-File-Name",
        sizeHeader    : "X-File-Size",
        typeHeader    : "X-File-Type",
        params        : {},
        extraHeaders  : {}
    },
    constructor: function(a) {
        this.mixins.observable.constructor.call(this);
        this.addEvents({
            uploadfailure : true,
            uploadsuccess : true,
            uploadprogress: true
        });
        this.initConfig(a)
    },
    initHeaders: function(a) {
        var b                  = this.extraHeaders || {};
        b[this.filenameHeader] = a.getFilename();
        b[this.sizeHeader]     = a.getSize();
        b[this.typeHeader]     = a.getType();
        return b
    },
    uploadItem : function(a) {
    },
    abortUpload: function() {
    }
});
Ext.define("Ext.ux.upload.uploader.AbstractXhrUploader", {
    extend          : "Ext.ux.upload.uploader.AbstractUploader",
    onUploadSuccess : function(b, c, d) {
        var e = {
            success : false,
            message : "general error",
            response: b
        };
        if (b.responseText) {
            var a = Ext.decode(b.responseText);
            if (a && a.success) {
                Ext.apply(e, {
                    success: a.success,
                    message: a.message
                });
                this.fireEvent("uploadsuccess", d, e);
                return
            }
            Ext.apply(e, {message: a.message})
        }
        this.fireEvent("uploadfailure", d, e)
    },
    onUploadFailure : function(a, b, c) {
        var d = {
            success : false,
            message : "http error",
            response: a
        };
        this.fireEvent("uploadfailure", c, d)
    },
    onUploadProgress: function(b, a) {
        this.fireEvent("uploadprogress", a, b)
    }
});
Ext.define("Ext.ux.upload.data.Connection", {
    extend          : "Ext.data.Connection",
    progressCallback: null,
    request         : function(a) {
        var b = a.progress;
        if (b) {
            this.progressCallback = b
        }
        this.callParent(arguments)
    },
    getXhrInstance  : function() {
        var a = this.callParent(arguments);
        if (this.progressCallback) {
            a.upload.onprogress = this.progressCallback
        }
        return a
    }
});
Ext.define("Ext.ux.upload.uploader.FormDataUploader", {
    extend        : "Ext.ux.upload.uploader.AbstractXhrUploader",
    requires      : ["Ext.ux.upload.data.Connection"],
    method        : "POST",
    xhr           : null,
    initConnection: function() {
        var b = new XMLHttpRequest(), c = this.method, a = this.url;
        b.open(c, a, true);
        this.abortXhr = function() {
            this.suspendEvents();
            b.abort();
            this.resumeEvents()
        };
        return b
    },
    uploadItem    : function(d) {
        var b = d.getFileApiObject();
        d.setUploading();
        var e = new FormData();
        e.append(b.name, b);
        var f = this.initConnection();
        f.setRequestHeader(this.filenameHeader, b.name);
        f.setRequestHeader(this.sizeHeader, b.size);
        f.setRequestHeader(this.typeHeader, b.type);
        var c = Ext.Function.bind(this.onLoadEnd, this, [d], true);
        var a = Ext.Function.bind(this.onUploadProgress, this, [d], true);
        f.addEventListener("loadend", c, true);
        f.upload.addEventListener("progress", a, true);
        f.send(e)
    },
    abortUpload   : function() {
        this.abortXhr()
    },
    abortXhr      : function() {
    },
    onLoadEnd     : function(c, b) {
        var a = c.target;
        if (a.status != 200) {
            return this.onUploadFailure(a, null, b)
        }
        return this.onUploadSuccess(a, null, b)
    }
});
Ext.define("Ext.ux.upload.uploader.ExtJsUploader", {
    extend          : "Ext.ux.upload.uploader.AbstractUploader",
    requires        : ["Ext.ux.upload.data.Connection"],
    conn            : null,
    initConnection  : function() {
        var a = this.url;
        if (this.params) {
            a = Ext.urlAppend(a, Ext.urlEncode(this.params))
        }
        var b = Ext.create("Ext.ux.upload.data.Connection", {
            disableCaching: true,
            method        : this.method,
            url           : a,
            timeout       : this.timeout,
            defaultHeaders: {
                "Content-Type"    : this.contentType,
                "X-Requested-With": "XMLHttpRequest"
            }
        });
        return b
    },
    uploadItem      : function(b) {
        var a = b.getFileApiObject();
        if (!a) {
            return
        }
        b.setUploading();
        this.conn = this.initConnection();
        this.conn.request({
            scope   : this,
            headers : this.initHeaders(b),
            xmlData : a,
            success : Ext.Function.bind(this.onUploadSuccess, this, [b], true),
            failure : Ext.Function.bind(this.onUploadFailure, this, [b], true),
            progress: Ext.Function.bind(this.onUploadProgress, this, [b], true)
        })
    },
    abortUpload     : function() {
        if (this.conn) {
            this.conn.abort()
        }
    },
    onUploadSuccess : function(b, c, d) {
        var e = {
            success : false,
            message : "general error",
            response: b
        };
        if (b.responseText) {
            var a = Ext.decode(b.responseText);
            if (a && a.success) {
                Ext.apply(e, {
                    success: a.success,
                    message: a.message
                });
                this.fireEvent("uploadsuccess", d, e);
                return
            }
            Ext.apply(e, {message: a.message})
        }
        this.fireEvent("uploadfailure", d, e)
    },
    onUploadFailure : function(a, b, c) {
        var d = {
            success : false,
            message : "http error",
            response: a
        };
        this.fireEvent("uploadfailure", c, d)
    },
    onUploadProgress: function(b, a) {
        this.fireEvent("uploadprogress", a, b)
    }
});
Ext.define("Ext.ux.upload.Dialog", {
    extend       : "Ext.window.Window",
    width        : 700,
    height       : 500,
    border       : 0,
    config       : {
        dialogTitle       : "",
        synchronous       : true,
        uploadUrl         : "",
        uploadParams      : {},
        uploadExtraHeaders: {},
        uploadTimeout     : 60000,
        textClose         : "Close"
    },
    constructor  : function(a) {
        this.initConfig(a);
        return this.callParent(arguments)
    },
    initComponent: function() {
        this.addEvents({uploadcomplete: true});
        if (!Ext.isObject(this.panel)) {
            this.panel = Ext.create("Ext.ux.upload.Panel", {
                synchronous       : this.synchronous,
                uploadUrl         : this.uploadUrl,
                uploadParams      : this.uploadParams,
                uploadExtraHeaders: this.uploadExtraHeaders,
                uploadTimeout     : this.uploadTimeout
            })
        }
        this.relayEvents(this.panel, ["uploadcomplete"]);
        Ext.apply(this, {
            title      : this.dialogTitle,
            layout     : "fit",
            items      : [this.panel],
            dockedItems: [{
                xtype   : "toolbar",
                dock    : "bottom",
                ui      : "footer",
                defaults: {minWidth: this.minButtonWidth},
                items   : ["->", {
                    text   : this.textClose,
                    cls    : "x-btn-text-icon",
                    scope  : this,
                    handler: function() {
                        this.close()
                    }
                }]
            }]
        });
        this.callParent(arguments)
    }
});
Ext.define("am.view.FileTreeListView", {
    extend       : "Ext.tree.Panel",
    alias        : "widget.filetreelistview",
    requires     : ["Ext.ux.upload.uploader.FormDataUploader", "Ext.ux.upload.uploader.ExtJsUploader", "Ext.ux.upload.Dialog", "Ext.tree.plugin.TreeViewDragDrop", "Ext.data.Request"],
    store        : "FilesStore",
    title        : "Dateien",
    rootVisible  : false,
    singleExpand : true,
    viewConfig   : {
        plugins: {
            ptype          : "treeviewdragdrop",
            containerScroll: true,
            appendOnly     : true
        }
    },
    columns      : [{
        xtype    : "treecolumn",
        text     : "Name",
        flex     : 3,
        sortable : false,
        dataIndex: "text"
    }, {
        xtype    : "templatecolumn",
        text     : "Gr\xf6sse",
        flex     : 1,
        sortable : false,
        dataIndex: "size",
        align    : "center",
        tpl      : Ext.create("Ext.XTemplate", "{size:this.formatSize}", {
            formatSize: function(a) {
                if (typeof a === "number" && a > 0) {
                    var b, d, c;
                    b = ["b", "Kb", "Mb", "Gb", "Tb", "Pb", "Eb", "Zb", "Yb"];
                    d = Math.floor(Math.log(a) / Math.log(1024));
                    c = a / Math.pow(1024, d);
                    if (Math.round(c.toFixed(2)) !== c.toFixed(2)) {
                        c = c.toFixed(2)
                    }
                    return c + " " + b[d]
                } else {
                    return ""
                }
            }
        })
    }, {
        text     : "Typ",
        flex     : 1,
        dataIndex: "type",
        sortable : false
    }],
    contextMenu  : null,
    initComponent: function() {
        var e         = this;
        var d         = Ext.create("Ext.Action", {
            text  : "Dateien hochladen...",
            itemId: "uploadfiles"
        });
        var b         = Ext.create("Ext.Action", {
            text  : "Neuer Ordner...",
            itemId: "createfolder"
        });
        var a         = Ext.create("Ext.Action", {
            text    : "Umbenennen...",
            itemId  : "renamefile",
            disabled: true
        });
        var c         = Ext.create("Ext.Action", {
            text    : "L\xf6schen...",
            itemId  : "deletefile",
            disabled: true
        });
        e.dockedItems = [{
            xtype: "toolbar",
            items: [d, {xtype: "tbseparator"}, b, a, c]
        }];
        e.contextMenu = Ext.create("Ext.menu.Menu", {
            plain: true,
            items: [b, a, c, {xtype: "menuseparator"}, d]
        });
        e.addListener("itemcontextmenu", function(g, f, j, h, i) {
            i.stopEvent();
            e.getSelectionModel().select(h);
            e.contextMenu.showAt(i.xy)
        });
        e.addListener("containercontextmenu", function(f, g) {
            g.stopEvent();
            e.getSelectionModel().deselectAll();
            e.contextMenu.showAt(g.xy)
        });
        e.addListener("selectionchange", function(g, f) {
            a.setDisabled(g.getCount() != 1);
            c.setDisabled(g.getCount() != 1)
        });
        e.callParent(arguments)
    }
});
Ext.define("am.view.UserListView", {
    extend       : "Ext.grid.Panel",
    alias        : "widget.userlistview",
    title        : "Benutzer",
    autoScroll   : true,
    store        : "UsersStore",
    columns      : [{
        header   : "Login",
        dataIndex: "login",
        flex     : 1
    }, {
        header   : "Vorname",
        dataIndex: "forename",
        flex     : 1
    }, {
        header   : "Nachname",
        dataIndex: "lastname",
        flex     : 1
    }, {
        header   : "EMail",
        dataIndex: "email",
        flex     : 1,
        renderer : function(a) {
            return Ext.String.format('<a href="mailto:{0}">{1}</a>', a, a)
        }
    }],
    contextMenu  : null,
    initComponent: function() {
        var b         = this;
        var c         = Ext.create("Ext.Action", {
            text  : "Neuer Benutzer...",
            itemId: "newuser"
        });
        var d         = Ext.create("Ext.Action", {
            text    : "Bearbeiten...",
            itemId  : "edituser",
            disabled: true
        });
        var a         = Ext.create("Ext.Action", {
            text    : "L\xf6schen...",
            itemId  : "deleteuser",
            disabled: true
        });
        b.dockedItems = [{
            xtype: "toolbar",
            items: [c, d, a]
        }];
        b.contextMenu = Ext.create("Ext.menu.Menu", {
            plain: true,
            items: [c, d, a]
        });
        b.addListener("itemcontextmenu", function(f, e, i, g, h) {
            h.stopEvent();
            b.getSelectionModel().select(g);
            b.contextMenu.showAt(h.xy)
        });
        b.addListener("containercontextmenu", function(e, f) {
            f.stopEvent();
            b.getSelectionModel().deselectAll();
            b.contextMenu.showAt(f.xy)
        });
        b.addListener("selectionchange", function(f, e) {
            d.setDisabled(f.getCount() != 1);
            a.setDisabled(f.getCount() != 1)
        });
        b.callParent(arguments)
    }
});
Ext.define("am.view.EmptyListView", {
    extend: "Ext.panel.Panel",
    alias : "widget.emptylistview"
});
Ext.define("am.store.NavigationStore", {
    extend    : "Ext.data.Store",
    model     : "am.model.Navigation",
    storeId   : "NavigationStore",
    groupField: "group",
    sorters   : {
        property : "sort",
        direction: "asc"
    },
    data      : [
        {
            name : "Alle",
            group: "1Text",
            xtype: "textlistview",
            sort : 1,
            param: null
        },
        {
            name : "News",
            group: "1Text",
            xtype: "textlistview",
            sort : 2,
            param: 102
        },
        {
            name : "Portrait",
            group: "1Text",
            xtype: "textlistview",
            sort : 3,
            param: 103
        },
        {
            name : "Anschlag W\xf6lfe",
            group: "1Text",
            xtype: "eventtextlistview",
            sort : 4,
            param: 104
        },
        {
            name : "Anschlag Pfader",
            group: "1Text",
            xtype: "eventtextlistview",
            sort : 5,
            param: 105
        },
        {
            name : "Anschlag Biber",
            group: "1Text",
            xtype: "eventtextlistview",
            sort : 6,
            param: 106
        },
        {
            name : "Anschlag Pios",
            group: "1Text",
            xtype: "eventtextlistview",
            sort : 7,
            param: 107
        },
        {
            name : "Sommerfest",
            group: "1Text",
            xtype: "textlistview",
            sort : 8,
            param: 110
        },
        {
            name : "Pfadiheim",
            group: "1Text",
            xtype: "textlistview",
            sort : 9,
            param: 111
        },
        {
            name : "Dateien",
            group: "2Dateien",
            xtype: "filetreelistview",
            sort : 10,
            param: null
        },
        {
            name : "Benutzer",
            group: "3Admin",
            xtype: "userlistview",
            sort : 11,
            param: null
        },
        {
            name : "Rechte",
            group: "3Admin",
            xtype: "emptylistview",
            sort : 12,
            param: null
        }, {
            name : "Gruppen",
            group: "3Admin",
            xtype: "emptylistview",
            sort : 13,
            param: null
        }]
});
Ext.define("am.view.component.ImageComboBox", {
    extend         : "Ext.form.Picker",
    editable       : false,
    labelSeparator : "",
    matchFieldWidth: false,
    listeners      : {
        focus: function(a) {
            a.setValue(null)
        }
    },
    createPicker   : function() {
        var c = this, b, a = Ext.apply({
            pickerField: c,
            store      : "ImagesStore",
            rootVisible: false,
            width      : c.bodyEl.getWidth(),
            height     : 150,
            floating   : true,
            listeners  : {
                scope    : c,
                itemclick: c.onItemClick
            }
        }, c.treeConfig);
        b     = c.picker = Ext.create("Ext.tree.Panel", a);
        return b
    },
    onItemClick    : function(b, a, f, c, g, d) {
        this.setFieldValue(a.getId(), a.data.text);
        this.fireEvent("select", this, a.data.text);
        this.collapse()
    },
    setFieldValue  : function(b, a) {
        this.setValue(b)
    },
    setValue       : function(b) {
        var a = this, c = a.inputEl;
        if (c && a.emptyText && !Ext.isEmpty(b)) {
            c.removeCls(a.emptyCls)
        }
        a.value = b;
        a.applyEmptyText();
        this.setRawValue(b)
    },
    setRawValue    : function(a) {
        if (this.inputEl) {
            this.inputEl.dom.value = a == null ? "" : a
        }
    },
    getValue       : function() {
        return this.value
    }
});
Ext.define("am.view.component.TextHeaderGroup", {
    extend       : "Ext.container.Container",
    layout       : "anchor",
    renderTo     : Ext.getBody(),
    defaults     : {
        labelSeparator: "",
        anchor        : "100%"
    },
    initComponent: function() {
        this.items = [{
            xtype         : "combobox",
            name          : "type_uid",
            fieldLabel    : "Kategorie",
            blankText     : "Es wird eine Kategorie ben\xf6tigt",
            store         : Ext.getStore("TextTypeActiveCodeTypeStore"),
            displayField  : "text",
            valueField    : "uc_uid",
            queryMode     : "local",
            forceSelection: true,
            allowBlank    : false,
            autoSelect    : true,
            triggerAction : "all",
            typeAhead     : true,
            selectOnFocus : true
        }, {
            fieldLabel: "Erfassungsdatum",
            xtype     : "datefield",
            name      : "evt_create",
            allowBlank: false,
            blankText : "Es wird ein Erfassungsdatum ben\xf6tigt"
        }, {
            xtype        : "textfield",
            name         : "title",
            fieldLabel   : "Titel",
            allowBlank   : false,
            blankText    : "Es wird ein Titel ben\xf6tigt",
            maxLength    : 255,
            maxLengthText: "Der Titel ist zu lang"
        }];
        this.callParent(arguments)
    }
});
Ext.define("am.view.component.EventGroup", {
    extend       : "Ext.container.Container",
    layout       : "anchor",
    renderTo     : Ext.getBody(),
    defaults     : {
        labelSeparator: "",
        anchor        : "100%"
    },
    initComponent: function() {
        var b      = Ext.create("widget.datetimefield", {
            fieldLabel: "Besammlung",
            name      : "evt_start",
            allowBlank: false,
            blankText : "Es wird ein Besammlungszeipunkt ben\xf6tigt",
            minValue  : new Date()
        });
        var a      = Ext.create("widget.datetimefield", {
            fieldLabel: "Abtreten",
            name      : "evt_end",
            allowBlank: false,
            blankText : "Es wird ein Endzeitpunkt ben\xf6tigt",
            minValue  : new Date()
        });
        this.items = [b, {
            fieldLabel   : "Ort",
            xtype        : "textfield",
            name         : "start_location",
            allowBlank   : false,
            blankText    : "Es wird ein Besammlungsort ben\xf6tigt",
            maxLength    : 60,
            maxLengthText: "Der Text ist zu lang"
        }, a, {
            fieldLabel   : "Ort",
            xtype        : "textfield",
            name         : "end_location",
            allowBlank   : false,
            blankText    : "Es wird ein Abtretungsort ben\xf6tigt",
            maxLength    : 60,
            maxLengthText: "Der Text ist zu lang"
        }];
        this.callParent(arguments)
    }
});
Ext.define("am.view.window.TextWindow", {
    extend       : "Ext.window.Window",
    alias        : "widget.textwindow",
    width        : 560,
    requires     : ["Ext.form.Panel"],
    title        : "Apollomin - Text",
    layout       : "fit",
    autoShow     : true,
    initComponent: function() {
        var a = this;
        Ext.tip.QuickTipManager.init();
        a.items   = [{
            xtype   : "form",
            padding : "5 5 0 5",
            border  : false,
            style   : "background-color: #fff;",
            defaults: {
                labelSeparator: "",
                anchor        : "100%"
            },
            items   : [Ext.create("am.view.component.TextHeaderGroup", {}), Ext.create("am.view.component.EventGroup", {
                itemId  : "eventGroup",
                hidden  : true,
                disabled: true
            }), {
                xtype        : "textarea",
                name         : "teaser",
                fieldLabel   : "Teaser",
                maxLength    : 2000,
                maxLengthText: "Der Text ist zu lang"
            }, {
                xtype        : "htmleditor",
                labelAlign   : "top",
                name         : "text",
                fieldLabel   : "Text",
                height       : 200,
                enableFont   : false,
                maxLength    : 4000,
                maxLengthText: "Der Text ist zu lang"
            }, {
                xtype        : "htmleditor",
                labelAlign   : "top",
                name         : "additional_text",
                fieldLabel   : "Zusatz Text",
                enableFont   : false,
                maxLength    : 2000,
                maxLengthText: "Der Text ist zu lang",
                hidden       : true,
                disabled     : true
            }, Ext.create("am.view.component.ImageComboBox", {
                fieldLabel: "Bild",
                name      : "image_path",
                padding   : "5 0 0 0"
            })]
        }];
        a.buttons = [{
            text  : "Speichern",
            action: "save"
        }, {
            text   : "Abbrechen",
            scope  : this,
            handler: this.close
        }];
        a.keys    = [{
            key    : [Ext.EventObject.ENTER],
            handler: function() {
                var b = a.down("button[action=save]");
                b.fireEvent("click", b)
            }
        }];
        a.callParent(arguments)
    }
});
Ext.define("am.view.window.UserWindow", {
    extend       : "Ext.window.Window",
    alias        : "widget.userwindow",
    width        : 480,
    requires     : ["Ext.form.Panel"],
    title        : "Apollomin - Benutzer",
    layout       : "fit",
    autoShow     : true,
    initComponent: function() {
        var a = this;
        Ext.tip.QuickTipManager.init();
        this.items   = [{
            xtype   : "form",
            padding : "5 5 0 5",
            border  : false,
            style   : "background-color: #fff;",
            defaults: {
                labelSeparator: "",
                anchor        : "100%"
            },
            items   : [{
                xtype        : "textfield",
                name         : "login",
                fieldLabel   : "Benutzername",
                allowBlank   : false,
                blankText    : "Es wird ein Benutzername ben\xf6tigt",
                maxLength    : 60,
                maxLengthText: "Der Benutzername ist zu lang"
            }, {
                xtype     : "textfield",
                inputType : "password",
                name      : "password",
                fieldLabel: "Password",
                allowBlank: false,
                blankText : "Es wird ein Password ben\xf6tigt",
                listeners : {
                    focus: function(b) {
                        b.oldValue = b.getValue();
                        b.setRawValue(null)
                    },
                    blur : function(c) {
                        var b = c.getValue();
                        if (c.oldValue && (b == null || b == "")) {
                            c.setRawValue(c.oldValue);
                            c.isValid()
                        } else {
                            if (c.up("form").getForm().getRecord().get("password") != b) {
                                c.setRawValue(hex_md5(b))
                            }
                        }
                    }
                }
            }, {
                xtype        : "textfield",
                name         : "forename",
                fieldLabel   : "Vorname",
                allowBlank   : false,
                blankText    : "Es wird ein Vorname ben\xf6tigt",
                maxLength    : 255,
                maxLengthText: "Der Vorname ist zu lang"
            }, {
                xtype        : "textfield",
                name         : "lastname",
                fieldLabel   : "Nachname",
                allowBlank   : false,
                blankText    : "Es wird ein Nachname ben\xf6tigt",
                maxLength    : 255,
                maxLengthText: "Der Nachname ist zu lang"
            }, {
                xtype        : "textfield",
                name         : "email",
                fieldLabel   : "EMail",
                allowBlank   : false,
                blankText    : "Es wird eine EMailadresse ben\xf6tigt",
                maxLength    : 255,
                maxLengthText: "Die Emailadresse ist zu lang",
                vtype        : "email"
            }]
        }];
        this.buttons = [{
            text  : "Speichern",
            action: "save"
        }, {
            text   : "Abbrechen",
            scope  : this,
            handler: this.close
        }];
        this.keys    = [{
            key    : [Ext.EventObject.ENTER],
            handler: function() {
                var b = a.down("button[action=save]");
                b.fireEvent("click", b)
            }
        }];
        this.callParent(arguments)
    }
});
Ext.define("am.store.TextTypeCodeTypeStore", {
    extend : "am.store.UserCodesStore",
    storeId: "TextTypeCodeTypeStore",
    statics: {
        ID                      : 101,
        NEWS_ID                 : 102,
        PORTRAIT_ID             : 103,
        ANSCHLAG_WOLFE_ID       : 104,
        ANSCHLAG_PFADER_ID      : 105,
        ANSCHLAG_BIBER_ID       : 106,
        ANSCHLAG_PIOS_ID        : 107,
        SOMMERFEST_ID           : 110,
        PFADIHEIM_ID            : 111,
        isEventTextType         : function(a) {
            return a == this.ANSCHLAG_WOLFE_ID || a == this.ANSCHLAG_PFADER_ID || a == this.ANSCHLAG_BIBER_ID || a == this.ANSCHLAG_PIOS_ID
        },
        hasAdditionalText       : function(a) {
            return a == this.ANSCHLAG_WOLFE_ID || a == this.ANSCHLAG_PFADER_ID || a == this.ANSCHLAG_BIBER_ID || a == this.ANSCHLAG_PIOS_ID
        },
        additionalTextNaming    : function(a) {
            if (a == this.ANSCHLAG_WOLFE_ID || a == this.ANSCHLAG_PFADER_ID || a == this.ANSCHLAG_BIBER_ID || a == this.ANSCHLAG_PIOS_ID) {
                return "Mitnehmen"
            }
            return "Zusatz Text"
        },
        hasAdditionalTextToolbar: function(a) {
            return false
        }
    },
    filters: [{
        property: "code_type",
        value   : 101
    }]
});
Ext.define("am.store.TextTypeActiveCodeTypeStore", {
    extend : "am.store.TextTypeCodeTypeStore",
    storeId: "TextTypeActiveCodeTypeStore",
    filters: [{
        property: "code_type",
        value   : 101
    }, {
        property: "enabled",
        value   : true
    }]
});
Ext.define("am.controller.TextController", {
    extend               : "Ext.app.Controller",
    requires             : ["am.view.TextListView", "am.view.EventTextListView", "am.view.EmptyListView", "am.view.UserListView", "am.view.FileTreeListView"],
    init                 : function() {
        var d = this;
        var a = ["TextTypeActiveCodeTypeStore", "EventsStore", "TextsStore"];
        var b = 0;
        for (var c = 0; c < a.length; c++) {
            Ext.getStore(a[c]).load(function(f, e, g) {
                b = b + 1;
                if (b >= a.length) {
                    d.control({
                        '[itemId="newtext"]'                  : {click: d.onNewText},
                        '[itemId="edittext"]'                 : {click: d.onEditText},
                        '[itemId="deletetext"]'               : {click: d.onDeleteText},
                        textlistview                          : {itemdblclick: d.onEditText},
                        eventtextlistview                     : {itemdblclick: d.onEditText},
                        "textwindow button[action=save]"      : {click: d.onFormSaveText},
                        'textwindow combobox[name="type_uid"]': {change: d.onFormCategoryChanged}
                    })
                }
            })
        }
    },
    getStore             : function(a) {
        if (am.store.TextTypeCodeTypeStore.isEventTextType(a)) {
            return Ext.getStore("EventsStore")
        } else {
            return Ext.getStore("TextsStore")
        }
    },
    getView              : function(b) {
        if (b.view) {
            return b.view
        }
        var a = b.up("textlistview");
        if (!a) {
            a = b.up("eventtextlistview")
        }
        return a
    },
    resolveRecord        : function(b) {
        var c = b.get("text_nr");
        var a = this.getStore(b.get("type_uid")).queryBy(function(d) {
            if (c == d.get("text_nr")) {
                return true
            }
            return false
        });
        return a.first()
    },
    onNewText            : function(a) {
        var b = Ext.create("am.view.window.TextWindow");
        b.down('combobox[name="type_uid"]').setValue(this.getView(a).viewTypeUid);
        b.down('datefield[name="evt_create"]').setValue(new Date());
        b.show()
    },
    onEditText           : function(c) {
        var b = this.getView(c);
        var d = b.getSelectionModel().getSelection();
        if (d && d.length > 0) {
            var a = this.resolveRecord(d[0]);
            var e = Ext.create("am.view.window.TextWindow");
            e.down("form").loadRecord(a);
            e.down('combobox[name="type_uid"]').setDisabled(true);
            e.show()
        }
    },
    onDeleteText         : function(d) {
        var f = this;
        var b = this.getView(d);
        var e = b.getSelectionModel().getSelection();
        if (e && e.length > 0) {
            var a = this.resolveRecord(e[0]);
            var c = this.getStore(a.get("type_uid"));
            Ext.Msg.show({
                title  : "Eintrag L\xf6schen?",
                msg    : 'Wollen sie den Eintrag "' + a.get("title") + '" wirklich l\xf6schen?',
                buttons: Ext.Msg.OKCANCEL,
                icon   : Ext.Msg.QUESTION,
                fn     : function(g) {
                    if (g == "ok") {
                        c.remove(a);
                        f.syncStore(a.get("type_uid"))
                    }
                }
            })
        }
    },
    onFormCategoryChanged: function(j, c, a) {
        var d = j.findParentByType("form");
        var f = null;
        var i = d.query("#eventGroup");
        if (i && i.length > 0) {
            f = i[0];
            if (am.store.TextTypeCodeTypeStore.isEventTextType(c)) {
                if (!am.store.TextTypeCodeTypeStore.isEventTextType(a)) {
                    f.show();
                    f.setDisabled(false);
                    var b = d.down('datetimefield[name="evt_start"]');
                    var e = Ext.Date.clearTime(this.nextDayOfWeekDate(6));
                    e.setHours(13);
                    e.setMinutes(30);
                    if (!b.getValue()) {
                        b.setValue(e)
                    }
                    var h = d.down('datetimefield[name="evt_end"]');
                    if (!h.getValue()) {
                        var g = Ext.Date.add(e, Ext.Date.HOUR, 3);
                        g     = Ext.Date.add(g, Ext.Date.MINUTE, 30);
                        h.setValue(g)
                    }
                    setTimeout(function() {
                        d.findParentByType("window").center()
                    }, 300)
                }
            } else {
                if (am.store.TextTypeCodeTypeStore.isEventTextType(a)) {
                    f.hide();
                    f.setDisabled(true)
                }
            }
        }
        var k = d.query('[name="additional_text"]')[0];
        if (am.store.TextTypeCodeTypeStore.hasAdditionalText(c)) {
            k.show();
            k.setDisabled(false);
            k.setFieldLabel(am.store.TextTypeCodeTypeStore.additionalTextNaming(c));
            k.getToolbar().setVisible(am.store.TextTypeCodeTypeStore.hasAdditionalTextToolbar(c))
        } else {
            k.hide();
            k.setDisabled(true)
        }
    },
    nextDayOfWeekDate    : function(a, c) {
        var b = new Date(c || new Date());
        b.setDate(b.getDate() + (a - 1 - b.getDay() + 7) % 7 + 1);
        return b
    },
    onFormSaveText       : function(c) {
        var f = c.up("window");
        var e = f.down("form");
        if (e.getForm().isValid()) {
            var d = e.down('combobox[name="type_uid"]').getValue();
            var a = e.getRecord();
            var b = this.getStore(d);
            if (!a) {
                if (am.store.TextTypeCodeTypeStore.isEventTextType(d)) {
                    a = new am.model.Event()
                } else {
                    a = new am.model.Text()
                }
            }
            e.getForm().updateRecord(a);
            if (a.getId() == null || a.getId() == 0) {
                b.add(a)
            }
            this.syncStore(d);
            f.close()
        }
    },
    syncStore            : function(b) {
        var a = this.getStore(b);
        a.sync();
        if (am.store.TextTypeCodeTypeStore.isEventTextType(b)) {
            Ext.getStore("TextsStore").load()
        }
    }
});
Ext.define("am.controller.UserController", {
    extend        : "Ext.app.Controller",
    refs          : [{
        ref     : "userListView",
        selector: "userlistview"
    }],
    init          : function() {
        this.control({
            userlistview                    : {itemdblclick: this.onEditUser},
            '[itemId="newuser"]'            : {click: this.onNewUser},
            '[itemId="edituser"]'           : {click: this.onEditUser},
            '[itemId="deleteuser"]'         : {click: this.onDeleteUser},
            "userwindow button[action=save]": {click: this.onFormSaveUser}
        })
    },
    onNewUser     : function() {
        var b = Ext.create("am.view.window.UserWindow");
        var a = new am.model.User();
        a.set("evt_create", new Date());
        b.down("form").loadRecord(a);
        b.show()
    },
    onEditUser    : function() {
        var b = this.getUserListView();
        var c = b.getSelectionModel().getSelection();
        if (c && c.length > 0) {
            var a = c[0];
            var d = Ext.create("am.view.window.UserWindow");
            d.down("form").loadRecord(a);
            d.show()
        }
    },
    onDeleteUser  : function() {
        var c = this.getUserListView();
        var d = c.getSelectionModel().getSelection();
        if (d && d.length > 0) {
            var a = d[0];
            var b = c.getStore();
            Ext.Msg.show({
                title  : "Benutzer L\xf6schen?",
                msg    : 'Wollen sie den Benutzer "' + a.get("login") + '" wirklich l\xf6schen?',
                buttons: Ext.Msg.OKCANCEL,
                icon   : Ext.Msg.QUESTION,
                fn     : function(e) {
                    if (e == "ok") {
                        b.remove(a);
                        b.sync()
                    }
                }
            })
        }
    },
    onFormSaveUser: function(c) {
        var e = c.up("window");
        var d = e.down("form").getForm();
        if (d.isValid()) {
            var a = d.getRecord();
            var b = this.getUserListView().getStore();
            if (a.getId() == null || a.getId() == 0) {
                b.add(a)
            }
            d.updateRecord(a);
            b.sync();
            e.close()
        }
    }
});
Ext.define("am.controller.FileController", {
    extend        : "Ext.app.Controller",
    refs          : [{
        ref     : "fileTreeListView",
        selector: "filetreelistview"
    }],
    init          : function() {
        this.control({
            '[itemId="uploadfiles"]'        : {click: this.onUploadFiles},
            '[itemId="createfolder"]'       : {click: this.onCreateFolder},
            '[itemId="renamefile"]'         : {click: this.onRenameFile},
            '[itemId="deletefile"]'         : {click: this.onDeleteFile},
            "filewindow button[action=save]": {click: this.onFormSaveFile},
            "filetreelistview dataview"     : {
                beforedrop: this.onBeforeDrop,
                drop      : this.onMoveFiles
            }
        })
    },
    onCreateFolder: function() {
        var b = Ext.create("am.view.window.FileWindow");
        b.setTitle("Apollomin - Neuer Ordner erstellen");
        var a = new am.model.File();
        b.down("form").loadRecord(a);
        b.show()
    },
    onRenameFile  : function() {
        var b = this.getFileTreeListView();
        var c = b.getSelectionModel().getSelection();
        if (c && c.length > 0) {
            var a = c[0];
            var d = Ext.create("am.view.window.FileWindow");
            d.down("form").loadRecord(a);
            d.show()
        }
    },
    onDeleteFile  : function() {
        var d = this;
        var b = this.getFileTreeListView();
        var c = b.getSelectionModel().getSelection();
        if (c && c.length > 0) {
            var a = c[0];
            Ext.Msg.show({
                title  : "Datei L\xf6schen?",
                msg    : 'Wollen sie den Datei "' + a.get("text") + '" wirklich l\xf6schen?',
                buttons: Ext.Msg.OKCANCEL,
                icon   : Ext.Msg.QUESTION,
                fn     : function(e) {
                    if (e == "ok") {
                        a.remove();
                        d.syncData()
                    }
                }
            })
        }
    },
    onBeforeDrop  : function(d, f, e, a, c, b) {
        return true
    },
    onMoveFiles   : function(c, e, d, a, b) {
        this.syncData(e.view.getTreeStore(), d);
        return true
    },
    onUploadFiles : function() {
        var f = this;
        var b = this.getFileTreeListView();
        var e = null;
        var a = null;
        var d = b.getSelectionModel().getSelection();
        if (d && d.length > 0) {
            a = d[0];
            e = a.get("path")
        }
        if (!e) {
            e = "upload/bilder/"
        }
        var g = Ext.create("Ext.ux.upload.Panel", {
            uploader            : "Ext.ux.upload.uploader.ExtJsUploader",
            uploaderOptions     : {url: "../data/apollomin/upload.php"},
            uploadParams        : {folder: e},
            textUpload          : "Upload",
            textAbort           : "Abbrechen",
            textRemoveSelected  : "Ausgew\xe4hlte entfernen",
            textRemoveAll       : "Alle entfernen",
            textFilename        : "Dateiname",
            textSize            : "Gr\xf6sse",
            textType            : "Art",
            textStatus          : "Status",
            textProgress        : "%",
            selectionMessageText: "{0} Datei(en) ausgew\xe4hlt, {1}",
            uploadMessageText   : "Upload fortschritt {0}% ({1} of {2} soubor\u016f)",
            buttonText          : "Dateien ausw\xe4hlen..."
        });
        var c = Ext.create("Ext.ux.upload.Dialog", {
            dialogTitle: "Dateien auf den Server laden",
            textClose  : "Schliessen",
            panel      : g
        });
        c.mon(c, "uploadcomplete", function(j, i, h, k) {
            f.reload(b.getStore(), a);
            if (!k) {
                c.close()
            }
        });
        c.show()
    },
    onFormSaveFile: function(e) {
        var h = e.up("window");
        var g = h.down("form").getForm();
        if (g.isValid()) {
            var c = this.getFileTreeListView();
            var b = g.getRecord();
            var d = c.getStore();
            g.updateRecord(b);
            if (b.getId() == null || b.getId() == 0) {
                var f = c.getSelectionModel().getSelection();
                if (f && f.length > 0) {
                    var a = f[0];
                    a.appendChild(b)
                } else {
                    d.getRootNode().appendChild(b)
                }
                this.syncData(d)
            } else {
                this.syncData(d, b.parentNode)
            }
            h.close()
        }
    },
    syncData      : function(a, c) {
        var b = this;
        if (!a) {
            a = this.getFileTreeListView().getStore()
        }
        a.sync({
            success: function() {
                if (c) {
                    b.reload(a, c)
                }
            },
            failure: function() {
                b.reload(a, null)
            }
        })
    },
    reload        : function(a, b) {
        if (!a) {
            a = this.getFileTreeListView().getStore()
        }
        if (!b) {
            b = a.getRootNode()
        }
        a.load({node: b})
    }
});
Ext.define("am.view.NavigationPanel", {
    extend         : "Ext.grid.Panel",
    alias          : "widget.navpanel",
    requires       : ["Ext.grid.feature.Grouping"],
    title          : "Apollomin",
    id             : "navigationpanel",
    collapsible    : true,
    sortableColumns: false,
    hideHeaders    : true,
    viewConfig     : {stripeRows: false},
    features       : [{
        ftype            : "grouping",
        groupHeaderTpl   : ["<div>{name:this.formatName}</div>", {
            formatName: function(a) {
                return a.substr(1, a.lenght)
            }
        }],
        hideGroupedHeader: true,
        startCollapsed   : false
    }],
    dockedItems    : [{
        dock  : "top",
        xtype : "toolbar",
        height: 93,
        style : "padding-top: 0px;padding-left: 0px;",
        layout: {type: "absolute"},
        items : [Ext.create("Ext.Component", {
            x   : 0,
            y   : 0,
            html: '<a href="/apollomin/"><img src="resources/apollomin.jpg" alt="ApolloGraphic" /></a>'
        })]
    }],
    initComponent  : function() {
        this.store   = new am.store.NavigationStore();
        this.columns = [{
            text     : "Name",
            flex     : 1,
            dataIndex: "name"
        }, {
            text     : "Gruppe",
            flex     : 1,
            dataIndex: "group"
        }];
        this.callParent(arguments)
    }
});
Ext.define("am.controller.NavigationController", {
    extend                          : "Ext.app.Controller",
    requires                        : ["am.view.NavigationPanel"],
    refs                            : [{
        ref     : "contentArea",
        selector: "#contentArea"
    }, {
        ref     : "textNavigationList",
        selector: "#textnavigationlist"
    }],
    init                            : function() {
        this.control({
            "#navigationpanel": {
                viewready: this.onViewReady,
                deselect : this.onDeselect,
                select   : this.onSelect
            }
        })
    },
    getView                         : function(a) {
        var b = Ext.ComponentQuery.query(a.get("xtype"));
        if (b && b.length > 0) {
            return b[0]
        }
        return null
    },
    viewToHide                      : null,
    onDeselect                      : function(b, a) {
        this.viewToHide = this.getView(a)
    },
    onSelect                        : function(c, b) {
        Ext.suspendLayouts();
        try {
            if (this.viewToHide) {
                this.viewToHide.hide();
                this.viewToHide = null
            }
            var a = this.getView(b);
            if (!a) {
                this.getContentArea().add(this.getListViewConfig(b.get("xtype")))
            }
            a = this.getView(b);
            if (a.navigationSelectedView) {
                a.navigationSelectedView(b.get("param"))
            }
            if (a) {
                a.setTitle(b.get("name"));
                a.show()
            }
        } finally {
            Ext.resumeLayouts(true)
        }
    },
    onViewReady                     : function(a) {
        a.getSelectionModel().select(a.store.first())
    },
    onNavigationPanelExpand         : function(a) {
        this.changeContentArea(a.getSelectionModel().getSelection())
    },
    onNavigationPanelSelectionChange: function(a, b) {
        this.changeContentArea(b)
    },
    changeContentAreaOld            : function(c) {
        var e = Ext.ComponentQuery.query("#contentArea > [hidden=false]");
        if (e && e.length > 0) {
            e[0].hide();
            e = null
        }
        var a = null;
        if (c && c.length > 0) {
            a = c[0];
            if (a.get("uc_uid")) {
                if (am.store.TextTypeCodeTypeStore.isEventTextType(a.getId())) {
                    e = this.getEventTextListView()
                } else {
                    if (!this.getTextListView()) {
                        this.getContentArea().add(this.getListViewConfig("textlistview"));
                        this.getContentArea().doLayout()
                    }
                    e = this.getTextListView()
                }
                var b = e.getStore();
                if (a.getId() == a.get("code_type")) {
                    b.clearFilter(false)
                } else {
                    b.clearFilter(true);
                    b.filter("type_uid", a.getId())
                }
            } else {
                var d = a.get("xtype");
                if (Ext.ComponentQuery.query(d).length == 0) {
                    this.getContentArea().add(this.getListViewConfig(d));
                    this.getContentArea().doLayout()
                }
                e = Ext.ComponentQuery.query(d)[0]
            }
            e.setTitle(a.get("text"));
            e.show()
        }
    },
    getListViewConfig               : function(a) {
        return {
            xtype : a,
            flex  : 1,
            hidden: true
        }
    }
});
Ext.define("am.view.Viewport", {
    extend               : "Ext.container.Viewport",
    layout               : "fit",
    requires             : ["Ext.layout.container.Border"],
    initComponent        : function() {
        this.items = {
            layout: {
                type   : "border",
                split  : true,
                padding: 5
            },
            items : [this.createNavigationPanel(), {
                title    : "Logout",
                xtype    : "panel",
                region   : "south",
                height   : 34,
                listeners: {
                    render: function(a) {
                        a.header.on("click", function() {
                            window.location = "login.html"
                        })
                    }
                }
            }, {
                id    : "contentArea",
                xtype : "container",
                region: "center",
                frame : true,
                layout: {
                    type : "vbox",
                    align: "stretch"
                }
            }]
        };
        this.callParent()
    },
    createNavigationPanel: function() {
        this.navigationPanel = Ext.create("widget.navpanel", {
            region: "west",
            width : 220,
            frame : true
        });
        return this.navigationPanel
    }
});
Ext.define("am.Application", {
    extend     : "Ext.app.Application",
    name       : "am",
    requires   : ["am.proxy.PhpProxy", "am.model.File", "am.store.TextsStore", "am.store.EventsStore", "am.store.FilesStore", "am.store.UsersStore", "am.store.ImagesStore", "am.store.UserCodesStore", "am.store.NavigationStore", "am.view.component.ImageComboBox", "am.view.component.TextHeaderGroup", "am.view.component.EventGroup", "am.view.window.TextWindow", "am.view.window.UserWindow", "Ext.data.Request", "Ext.data.reader.Json", "am.store.TextTypeCodeTypeStore", "am.store.TextTypeActiveCodeTypeStore", "Ext.toolbar.Spacer", "Ext.grid.column.Template", "Ext.form.field.ComboBox", "Ext.form.field.Date", "Ext.form.field.Time", "Ext.form.field.HtmlEditor"],
    views      : ["Viewport"],
    controllers: ["TextController", "UserController", "FileController", "NavigationController"],
    stores     : ["TextsStore", "EventsStore", "FilesStore", "ImagesStore", "UsersStore", "UserCodesStore", "TextTypeCodeTypeStore", "NavigationStore", "TextTypeActiveCodeTypeStore"],
    launch     : function() {
        Ext.Ajax.on("requestexception", function(c, a, b) {
            if (a.status === 401 || a.status === 403) {
                window.location = "login.html"
            } else {
                if (request.aborted) {
                } else {
                    if (request.timedout) {
                        Ext.MessageBox.show({
                            title  : "Fehler",
                            msg    : "Der Server kann nicht erreicht werden",
                            buttons: Ext.Msg.OK,
                            icon   : Ext.MessageBox.ERROR
                        })
                    } else {
                        Ext.MessageBox.show({
                            title  : "Unbekannter Fehler",
                            msg    : "HTTP " + a.status,
                            buttons: Ext.Msg.OK,
                            icon   : Ext.MessageBox.ERROR
                        })
                    }
                }
            }
        });
        Ext.Ajax.on("requestcomplete", function(d, a, b) {
            if (a.status === 200) {
                var c = Ext.decode(a.responseText);
                if (!c.success) {
                    Ext.MessageBox.show({
                        title  : "Fehler",
                        msg    : c.message,
                        buttons: Ext.Msg.OK,
                        icon   : Ext.MessageBox.ERROR
                    })
                }
            }
        })
    }
});
Ext.application({
    name              : "am",
    extend            : "am.Application",
    autoCreateViewport: true
});
Ext.define("Ext.ux.form.field.DateTime", {
    extend            : "Ext.form.FieldContainer",
    mixins            : {field: "Ext.form.field.Field"},
    alias             : "widget.datetimefield",
    layout            : "hbox",
    combineErrors     : true,
    msgTarget         : "side",
    readOnly          : false,
    dateValue         : null,
    dateField         : null,
    timeField         : null,
    initComponent     : function() {
        var d       = this, b, c;
        d.items     = d.items || [];
        d.dateField = Ext.create("Ext.form.field.Date", {
            flex       : 1,
            isFormField: false,
            submitValue: false
        });
        d.items.push(d.dateField);
        d.timeField = Ext.create("Ext.form.field.Time", {
            flex       : 1,
            isFormField: false,
            submitValue: false
        });
        d.items.push(d.timeField);
        for (var a = 0; a < d.items.length; a++) {
            d.items[a].on("focus", Ext.bind(d.onItemFocus, d));
            d.items[a].on("blur", Ext.bind(d.onItemBlur, d));
            d.items[a].on("specialkey", function(f, e) {
                b = e.getKey();
                c = (b == e.TAB);
                if (c && d.focussedItem == d.dateField) {
                    e.stopEvent();
                    d.timeField.focus();
                    return
                }
                d.fireEvent("specialkey", f, e)
            })
        }
        d.callParent();
        d.initField()
    },
    focus             : function() {
        this.callParent();
        this.dateField.focus()
    },
    onItemFocus       : function(a) {
        if (this.blurTask) {
            this.blurTask.cancel()
        }
        this.focussedItem = a
    },
    onItemBlur        : function(b) {
        var a = this;
        if (b != a.focussedItem) {
            return
        }
        a.blurTask = new Ext.util.DelayedTask(function() {
            a.fireEvent("blur", a)
        });
        a.blurTask.delay(100)
    },
    getValue          : function() {
        var b = null, a = this.dateField.getSubmitValue(), d = this.timeField.getSubmitValue();
        if (a) {
            if (d) {
                var c = this.getFormat();
                b     = Ext.Date.parse(a + " " + d, c)
            } else {
                b = this.dateField.getValue()
            }
        }
        return b
    },
    setValue          : function(a) {
        if (Ext.isString(a)) {
            a = Ext.Date.parse(a, this.getFormat())
        }
        this.dateField.setValue(a);
        this.timeField.setValue(a)
    },
    resetOriginalValue: function() {
        this.originalValue = this.getValue();
        this.dateField.resetOriginalValue();
        this.timeField.resetOriginalValue();
        this.checkDirty()
    },
    getSubmitValue    : function() {
        var a = this.getValue();
        return a ? Ext.Date.format(a, this.getFormat()) : null
    },
    getFormat         : function() {
        return (this.dateField.submitFormat || this.dateField.format) + " " + (this.timeField.submitFormat || this.timeField.format)
    },
    setMinValue       : function(a) {
        this.dateField.setMinValue(a)
    },
    setMaxValue       : function(a) {
        this.dateField.setMaxValue(a)
    },
    validate          : function() {
        return this.dateField.validate()
    }
});
Ext.define("Ext.ux.upload.BrowseButton", {
    extend         : "Ext.form.field.File",
    buttonOnly     : true,
    iconCls        : "ux-mu-icon-action-browse",
    buttonText     : "Browse...",
    initComponent  : function() {
        this.addEvents({fileselected: true});
        Ext.apply(this, {
            buttonConfig: {
                iconCls: this.iconCls,
                text   : this.buttonText
            }
        });
        this.on("afterrender", function() {
            if (this.iconCls) {
            }
            this.fileInputEl.dom.setAttribute("multiple", "1")
        }, this);
        this.on("change", function(d, c, a) {
            var b = this.fileInputEl.dom.files;
            if (b) {
                this.fireEvent("fileselected", this, b)
            }
        }, this);
        this.callParent(arguments)
    },
    createFileInput: function() {
        this.callParent(arguments);
        this.fileInputEl.dom.setAttribute("multiple", "1")
    }
});
Ext.define("Ext.ux.upload.Item", {
    mixins               : {observable: "Ext.util.Observable"},
    STATUS_READY         : "ready",
    STATUS_UPLOADING     : "uploading",
    STATUS_UPLOADED      : "uploaded",
    STATUS_UPLOAD_ERROR  : "uploaderror",
    config               : {
        fileApiObject     : null,
        uploadErrorMessage: ""
    },
    constructor          : function(a) {
        this.mixins.observable.constructor.call(this);
        this.addEvents({
            changestatus  : true,
            progressupdate: true
        });
        this.initConfig(a);
        Ext.apply(this, {
            status  : this.STATUS_READY,
            progress: 0
        })
    },
    reset                : function() {
        this.uploadErrorMessage = "";
        this.setStatus(this.STATUS_READY);
        this.setProgress(0)
    },
    getFileApiObject     : function() {
        return this.fileApiObject
    },
    getId                : function() {
        return this.getFilename()
    },
    getName              : function() {
        return this.getProperty("name")
    },
    getFilename          : function() {
        return this.getName()
    },
    getSize              : function() {
        return this.getProperty("size")
    },
    getType              : function() {
        return this.getProperty("type")
    },
    getProperty          : function(a) {
        if (this.fileApiObject) {
            return this.fileApiObject[a]
        }
        return null
    },
    getProgress          : function() {
        return this.progress
    },
    getProgressPercent   : function() {
        var a = this.getProgress();
        if (!a) {
            return 0
        }
        var b = Ext.util.Format.number((a / this.getSize()) * 100, "0");
        if (b > 100) {
            b = 100
        }
        return b
    },
    setProgress          : function(a) {
        this.progress = a;
        this.fireEvent("progressupdate", this)
    },
    getStatus            : function() {
        return this.status
    },
    setStatus            : function(a) {
        this.status = a;
        this.fireEvent("changestatus", this, a)
    },
    isReady              : function() {
        return (this.status == this.STATUS_READY)
    },
    isUploaded           : function() {
        return (this.status == this.STATUS_UPLOADED)
    },
    setUploaded          : function() {
        this.setProgress(this.getSize());
        this.setStatus(this.STATUS_UPLOADED)
    },
    isUploadError        : function() {
        return (this.status == this.STATUS_UPLOAD_ERROR)
    },
    getUploadErrorMessage: function() {
        return this.uploadErrorMessage
    },
    setUploadError       : function(a) {
        this.uploadErrorMessage = a;
        this.setStatus(this.STATUS_UPLOAD_ERROR)
    },
    setUploading         : function() {
        this.setStatus(this.STATUS_UPLOADING)
    }
});
Ext.define("Ext.ux.upload.Store", {
    extend: "Ext.data.Store",
    fields: [{
        name: "filename",
        type: "string"
    }, {
        name: "size",
        type: "integer"
    }, {
        name: "type",
        type: "string"
    }, {
        name: "status",
        type: "string"
    }, {
        name: "message",
        type: "string"
    }],
    proxy : {
        type  : "memory",
        reader: {
            type      : "array",
            idProperty: "filename"
        }
    }
});
Ext.define("Ext.ux.upload.ItemGridPanel", {
    extend                   : "Ext.grid.Panel",
    requires                 : ["Ext.selection.CheckboxModel", "Ext.ux.upload.Store"],
    layout                   : "fit",
    border                   : 0,
    viewConfig               : {scrollOffset: 40},
    config                   : {
        queue       : null,
        textFilename: "Filename",
        textSize    : "Size",
        textType    : "Type",
        textStatus  : "Status",
        textProgress: "%"
    },
    constructor              : function(a) {
        this.initConfig(a);
        return this.callParent(arguments)
    },
    initComponent            : function() {
        if (this.queue) {
            this.queue.on("queuechange", this.onQueueChange, this);
            this.queue.on("itemchangestatus", this.onQueueItemChangeStatus, this);
            this.queue.on("itemprogressupdate", this.onQueueItemProgressUpdate, this)
        }
        Ext.apply(this, {
            store   : Ext.create("Ext.ux.upload.Store"),
            selModel: Ext.create("Ext.selection.CheckboxModel", {checkOnly: true}),
            columns : [{
                xtype: "rownumberer",
                width: 50
            }, {
                dataIndex: "filename",
                header   : this.textFilename,
                flex     : 1
            }, {
                dataIndex: "size",
                header   : this.textSize,
                width    : 100,
                renderer : function(a) {
                    return Ext.util.Format.fileSize(a)
                }
            }, {
                dataIndex: "type",
                header   : this.textType,
                width    : 150
            }, {
                dataIndex: "status",
                header   : this.textStatus,
                width    : 50,
                align    : "right",
                renderer : this.statusRenderer
            }, {
                dataIndex: "progress",
                header   : this.textProgress,
                width    : 50,
                align    : "right",
                renderer : function(a) {
                    if (!a) {
                        a = 0
                    }
                    return a + "%"
                }
            }, {
                dataIndex: "message",
                width    : 1,
                hidden   : true
            }]
        });
        this.callParent(arguments)
    },
    onQueueChange            : function(a) {
        this.loadQueueItems(a.getItems())
    },
    onQueueItemChangeStatus  : function(a, c, b) {
        this.updateStatus(c)
    },
    onQueueItemProgressUpdate: function(a, b) {
        this.updateStatus(b)
    },
    loadQueueItems           : function(a) {
        var c = [];
        var b;
        for (b = 0; b < a.length; b++) {
            c.push([a[b].getFilename(), a[b].getSize(), a[b].getType(), a[b].getStatus(), a[b].getProgressPercent()])
        }
        this.loadStoreData(c)
    },
    loadStoreData            : function(b, a) {
        this.store.loadData(b, a)
    },
    getSelectedRecords       : function() {
        return this.getSelectionModel().getSelection()
    },
    updateStatus             : function(c) {
        var b = this.getRecordByFilename(c.getFilename());
        if (!b) {
            return
        }
        var a = c.getStatus();
        if (a != b.get("status")) {
            this.scrollIntoView(b);
            b.set("status", c.getStatus());
            if (c.isUploadError()) {
                b.set("tooltip", c.getUploadErrorMessage())
            }
        }
        b.set("progress", c.getProgressPercent());
        b.commit()
    },
    getRecordByFilename      : function(a) {
        var b = this.store.findExact("filename", a);
        if (-1 == b) {
            return null
        }
        return this.store.getAt(b)
    },
    getIndexByRecord         : function(a) {
        return this.store.findExact("filename", a.get("filename"))
    },
    statusRenderer           : function(g, b, a, h, d, c) {
        var e = "ux-mu-icon-upload-" + g;
        var f = a.get("tooltip");
        if (f) {
            g = f
        } else {
            "upload_status_" + g
        }
        g = '<span class="ux-mu-status-value ' + e + '" data-qtip="' + g + '" />';
        return g
    },
    scrollIntoView           : function(a) {
        var c = this.getIndexByRecord(a);
        if (-1 == c) {
            return
        }
        this.getView().focusRow(c);
        return;
        var b = Ext.get(this.getView().getRow(c));
        if (!b) {
            return
        }
        var d = this.getEl();
        if (b.getBottom() > d.getBottom()) {
            b.dom.scrollIntoView(d)
        }
    }
});
Ext.define("Ext.ux.upload.Manager", {
    mixins                : {observable: "Ext.util.Observable"},
    requires              : ["Ext.ux.upload.uploader.AbstractUploader"],
    config                : {
        uploader       : null,
        uploaderOptions: null,
        synchronous    : true
    },
    DEFAULT_UPLOADER_CLASS: "Ext.ux.upload.uploader.ExtJsUploader",
    constructor           : function(c) {
        this.mixins.observable.constructor.call(this);
        this.addEvents({
            beforeupload     : true,
            uploadcomplete   : true,
            abortupload      : true,
            itemuploadsuccess: true,
            itemuploadfailure: true
        });
        this.initConfig(c);
        if (!(this.uploader instanceof Ext.ux.upload.uploader.AbstractUploader)) {
            var a = this.DEFAULT_UPLOADER_CLASS;
            if (Ext.isString(this.uploader)) {
                a = this.uploader
            }
            var b = this.getUploaderOptions() || {};
            Ext.applyIf(b, {
                success : this.onUploadSuccess,
                failure : this.onUploadFailure,
                progress: this.onUploadProgress
            });
            this.uploader = Ext.create(a, b)
        }
        this.mon(this.uploader, "uploadsuccess", this.onUploadSuccess, this);
        this.mon(this.uploader, "uploadfailure", this.onUploadFailure, this);
        this.mon(this.uploader, "uploadprogress", this.onUploadProgress, this);
        Ext.apply(this, {
            syncQueue   : null,
            currentQueue: null,
            uploadActive: false,
            errorCount  : 0
        })
    },
    uploadQueue           : function(a) {
        if (this.uploadActive) {
            return
        }
        this.startUpload(a);
        a.reset();
        if (this.synchronous) {
            this.uploadQueueSync(a);
            return
        }
        this.uploadQueueAsync(a)
    },
    uploadQueueSync       : function(a) {
        this.uploadNextItemSync()
    },
    uploadNextItemSync    : function() {
        if (!this.uploadActive) {
            return
        }
        var a = this.currentQueue.getFirstReadyItem();
        if (!a) {
            return
        }
        this.uploader.uploadItem(a)
    },
    uploadQueueAsync      : function(a) {
        var c;
        var b = a.getCount();
        for (c = 0; c < b; c++) {
            this.uploader.uploadItem(a.getAt(c))
        }
    },
    startUpload           : function(a) {
        this.uploadActive = true;
        this.currentQueue = a;
        this.fireEvent("beforeupload", this, a)
    },
    finishUpload          : function() {
        this.fireEvent("uploadcomplete", this, this.currentQueue, this.errorCount)
    },
    resetUpload           : function() {
        this.currentQueue = null;
        this.uploadActive = false;
        this.errorCount   = 0
    },
    abortUpload           : function() {
        this.uploader.abortUpload();
        this.currentQueue.recoverAfterAbort();
        this.resetUpload();
        this.fireEvent("abortupload", this, this.currentQueue)
    },
    afterItemUpload       : function(a, b) {
        if (this.synchronous) {
            this.uploadNextItemSync()
        }
        if (this.currentQueue.isLast(a)) {
            this.finishUpload()
        }
    },
    onUploadSuccess       : function(a, b) {
        a.setUploaded();
        this.fireEvent("itemuploadsuccess", this, a, b);
        this.afterItemUpload(a, b)
    },
    onUploadFailure       : function(a, b) {
        a.setUploadError(b.message);
        this.fireEvent("itemuploadfailure", this, a, b);
        this.errorCount++;
        this.afterItemUpload(a, b)
    },
    onUploadProgress      : function(b, a) {
        b.setProgress(a.loaded)
    }
});
Ext.define("Ext.ux.upload.StatusBar", {
    extend             : "Ext.toolbar.Toolbar",
    config             : {
        selectionMessageText: "Selected {0} file(s), {1}",
        uploadMessageText   : "Upload progress {0}% ({1} of {2} file(s))",
        textComponentId     : "mu-status-text"
    },
    constructor        : function(a) {
        this.initConfig(a);
        return this.callParent(arguments)
    },
    initComponent      : function() {
        Ext.apply(this, {
            items: [{
                xtype : "tbtext",
                itemId: this.textComponentId,
                text  : "&nbsp;"
            }]
        });
        this.callParent(arguments)
    },
    setText            : function(a) {
        this.getComponent(this.textComponentId).setText(a)
    },
    setSelectionMessage: function(b, a) {
        this.setText(Ext.String.format(this.selectionMessageText, b, Ext.util.Format.fileSize(a)))
    },
    setUploadMessage   : function(c, a, b) {
        this.setText(Ext.String.format(this.uploadMessageText, c, a, b))
    }
});
Ext.define("Ext.ux.upload.Queue", {
    extend              : "Ext.util.MixedCollection",
    requires            : ["Ext.ux.upload.Item"],
    constructor         : function(a) {
        this.callParent(arguments);
        this.addEvents({
            multiadd          : true,
            multiremove       : true,
            queuechange       : true,
            itemchangestatus  : true,
            itemprogressupdate: true
        });
        this.on("clear", function() {
            this.fireEvent("queuechange", this)
        }, this)
    },
    addFiles            : function(c) {
        var d;
        var a = [];
        var b = c.length;
        if (!b) {
            return
        }
        for (d = 0; d < b; d++) {
            a.push(this.createItem(c[d]))
        }
        this.addAll(a);
        this.fireEvent("multiadd", this, a);
        this.fireEvent("queuechange", this)
    },
    reset               : function() {
        this.clearUploadedItems();
        this.each(function(a) {
            a.reset()
        }, this)
    },
    getItems            : function() {
        return this.getRange()
    },
    getUploadedItems    : function() {
        var d = [];
        var a = this.getCount();
        var b;
        for (b = 0; b < a; b++) {
            var c = this.getAt(b);
            if (c.isUploaded()) {
                d.push(c)
            }
        }
        return d
    },
    getFirstReadyItem   : function() {
        var a = this.getRange();
        var b = this.getCount();
        var c;
        for (c = 0; c < b; c++) {
            if (a[c].isReady()) {
                return a[c]
            }
        }
        return null
    },
    clearItems          : function() {
        this.clear()
    },
    clearUploadedItems  : function() {
        this.removeItems(this.getUploadedItems())
    },
    removeItems         : function(a) {
        var b = a.length;
        var c;
        if (!b) {
            return
        }
        for (c = 0; c < b; c++) {
            this.remove(a[c])
        }
        this.fireEvent("queuechange", this)
    },
    removeItemsByKey    : function(c) {
        var b;
        var a = c.length;
        if (!a) {
            return
        }
        for (b = 0; b < a; b++) {
            this.removeItemByKey(c[b])
        }
        this.fireEvent("multiremove", this, c);
        this.fireEvent("queuechange", this)
    },
    removeItemByKey     : function(a) {
        this.removeAtKey(a)
    },
    recoverAfterAbort   : function() {
        this.each(function(a) {
            if (!a.isUploaded() && !a.isReady()) {
                a.reset()
            }
        })
    },
    createItem          : function(a) {
        var b = Ext.create("Ext.ux.upload.Item", {fileApiObject: a});
        b.on("changestatus", this.onItemChangeStatus, this);
        b.on("progressupdate", this.onItemProgressUpdate, this);
        return b
    },
    getKey              : function(a) {
        return a.getId()
    },
    onItemChangeStatus  : function(b, a) {
        this.fireEvent("itemchangestatus", this, b, a)
    },
    onItemProgressUpdate: function(a) {
        this.fireEvent("itemprogressupdate", this, a)
    },
    isLast              : function(b) {
        var a = this.last();
        if (a && b.getId() == a.getId()) {
            return true
        }
        return false
    },
    getTotalBytes       : function() {
        var a = 0;
        this.each(function(d, b, c) {
            a += d.getSize()
        }, this);
        return a
    }
});
Ext.define("Ext.ux.upload.Panel", {
    extend             : "Ext.panel.Panel",
    requires           : ["Ext.ux.upload.ItemGridPanel", "Ext.ux.upload.Manager", "Ext.ux.upload.StatusBar", "Ext.ux.upload.BrowseButton", "Ext.ux.upload.Queue"],
    config             : {
        uploader            : null,
        uploaderOptions     : null,
        synchronous         : true,
        uploadUrl           : "",
        uploadParams        : {},
        uploadExtraHeaders  : {},
        uploadTimeout       : 60000,
        textOk              : "OK",
        textUpload          : "Upload",
        textBrowse          : "Browse",
        textAbort           : "Abort",
        textRemoveSelected  : "Remove selected",
        textRemoveAll       : "Remove all",
        textFilename        : "Filename",
        textSize            : "Size",
        textType            : "Type",
        textStatus          : "Status",
        textProgress        : "%",
        selectionMessageText: "Selected {0} file(s), {1}",
        uploadMessageText   : "Upload progress {0}% ({1} of {2} soubor\u016f)",
        buttonText          : "Browse..."
    },
    queue              : null,
    grid               : null,
    uploadManager      : null,
    statusBar          : null,
    browseButton       : null,
    constructor        : function(a) {
        this.initConfig(a);
        return this.callParent(arguments)
    },
    initComponent      : function() {
        this.addEvents({uploadcomplete: true});
        this.queue         = this.initQueue();
        this.grid          = Ext.create("Ext.ux.upload.ItemGridPanel", {
            queue       : this.queue,
            textFilename: this.textFilename,
            textSize    : this.textSize,
            textType    : this.textType,
            textStatus  : this.textStatus,
            textProgress: this.textProgress
        });
        this.uploadManager = this.createUploadManager();
        this.uploadManager.on("uploadcomplete", this.onUploadComplete, this);
        this.uploadManager.on("itemuploadsuccess", this.onItemUploadSuccess, this);
        this.uploadManager.on("itemuploadfailure", this.onItemUploadFailure, this);
        this.statusBar = Ext.create("Ext.ux.upload.StatusBar", {
            dock                : "bottom",
            selectionMessageText: this.selectionMessageText,
            uploadMessageText   : this.uploadMessageText
        });
        Ext.apply(this, {
            title      : this.dialogTitle,
            autoScroll : true,
            layout     : "fit",
            uploading  : false,
            items      : [this.grid],
            dockedItems: [this.getTopToolbarConfig(), this.statusBar]
        });
        this.on("afterrender", function() {
            this.stateInit()
        }, this);
        this.callParent(arguments)
    },
    createUploadManager: function() {
        var b = this.getUploaderOptions() || {};
        Ext.applyIf(b, {
            url         : this.uploadUrl,
            params      : this.uploadParams,
            extraHeaders: this.uploadExtraHeaders,
            timeout     : this.uploadTimeout
        });
        var a = Ext.create("Ext.ux.upload.Manager", {
            uploader       : this.uploader,
            uploaderOptions: b,
            synchronous    : this.getSynchronous()
        });
        return a
    },
    getTopToolbarConfig: function() {
        this.browseButton = Ext.create("Ext.ux.upload.BrowseButton", {
            itemId    : "button_browse",
            buttonText: this.buttonText
        });
        this.browseButton.on("fileselected", this.onFileSelection, this);
        return {
            xtype: "toolbar",
            dock : "top",
            items: [this.browseButton, "-", {
                itemId : "button_upload",
                text   : this.textUpload,
                iconCls: "ux-mu-icon-action-upload",
                scope  : this,
                handler: this.onInitUpload
            }, "-", {
                itemId  : "button_abort",
                text    : this.textAbort,
                iconCls : "ux-mu-icon-action-abort",
                scope   : this,
                handler : this.onAbortUpload,
                disabled: true
            }, "->", {
                itemId : "button_remove_selected",
                text   : this.textRemoveSelected,
                iconCls: "ux-mu-icon-action-remove",
                scope  : this,
                handler: this.onMultipleRemove
            }, "-", {
                itemId : "button_remove_all",
                text   : this.textRemoveAll,
                iconCls: "ux-mu-icon-action-remove",
                scope  : this,
                handler: this.onRemoveAll
            }]
        }
    },
    initQueue          : function() {
        var a = Ext.create("Ext.ux.upload.Queue");
        a.on("queuechange", this.onQueueChange, this);
        return a
    },
    onInitUpload       : function() {
        if (!this.queue.getCount()) {
            return
        }
        this.stateUpload();
        this.startUpload()
    },
    onAbortUpload      : function() {
        this.uploadManager.abortUpload();
        this.finishUpload();
        this.switchState()
    },
    onUploadComplete   : function(b, a, c) {
        this.finishUpload();
        this.stateInit();
        this.fireEvent("uploadcomplete", this, b, a.getUploadedItems(), c);
        b.resetUpload()
    },
    onFileSelection    : function(a, b) {
        this.queue.clearUploadedItems();
        this.queue.addFiles(b);
        this.browseButton.reset()
    },
    onQueueChange      : function(a) {
        this.updateStatusBar();
        this.switchState()
    },
    onMultipleRemove   : function() {
        var a = this.grid.getSelectedRecords();
        if (!a.length) {
            return
        }
        var d = [];
        var c;
        var b = a.length;
        for (c = 0; c < b; c++) {
            d.push(a[c].get("filename"))
        }
        this.queue.removeItemsByKey(d)
    },
    onRemoveAll        : function() {
        this.queue.clearItems()
    },
    onItemUploadSuccess: function(a, b, c) {
    },
    onItemUploadFailure: function(a, b, c) {
    },
    startUpload        : function() {
        this.uploading = true;
        this.uploadManager.uploadQueue(this.queue)
    },
    finishUpload       : function() {
        this.uploading = false
    },
    isUploadActive     : function() {
        return this.uploading
    },
    updateStatusBar    : function() {
        if (!this.statusBar) {
            return
        }
        this.statusBar.setSelectionMessage(this.queue.getCount(), this.queue.getTotalBytes())
    },
    getButton          : function(a) {
        return Ext.ComponentMgr.get(a)
    },
    switchButtons      : function(a) {
        for (id in a) {
            this.switchButton(id, a[id])
        }
    },
    switchButton       : function(c, a) {
        var b = this.getButton(c);
        if (b) {
            if (a) {
                b.enable()
            } else {
                b.disable()
            }
        }
    },
    switchState        : function() {
        if (this.uploading) {
            this.stateUpload()
        } else {
            if (this.queue.getCount()) {
                this.stateQueue()
            } else {
                this.stateInit()
            }
        }
    },
    stateInit          : function() {
        this.switchButtons({
            button_browse         : 1,
            button_upload         : 0,
            button_abort          : 0,
            button_remove_all     : 1,
            button_remove_selected: 1
        })
    },
    stateQueue         : function() {
        this.switchButtons({
            button_browse         : 1,
            button_upload         : 1,
            button_abort          : 0,
            button_remove_all     : 1,
            button_remove_selected: 1
        })
    },
    stateUpload        : function() {
        this.switchButtons({
            button_browse         : 0,
            button_upload         : 0,
            button_abort          : 1,
            button_remove_all     : 1,
            button_remove_selected: 1
        })
    }
});
Ext.define("am.view.window.FileWindow", {
    extend       : "Ext.window.Window",
    alias        : "widget.filewindow",
    width        : 420,
    requires     : ["Ext.form.Panel"],
    title        : "Apollomin - Datei umbenennen",
    layout       : "fit",
    autoShow     : true,
    initComponent: function() {
        var a = this;
        Ext.tip.QuickTipManager.init();
        this.items   = [{
            xtype   : "form",
            padding : "5 5 0 5",
            border  : false,
            style   : "background-color: #fff;",
            defaults: {
                labelSeparator: "",
                anchor        : "100%"
            },
            items   : [{
                xtype        : "textfield",
                name         : "text",
                fieldLabel   : "Name",
                allowBlank   : false,
                blankText    : "Es wird ein Name ben\xf6tigt",
                maxLength    : 60,
                maxLengthText: "Der Name ist zu lang"
            }]
        }];
        this.buttons = [{
            text  : "Speichern",
            action: "save"
        }, {
            text   : "Abbrechen",
            scope  : this,
            handler: this.close
        }];
        this.keys    = [{
            key    : [Ext.EventObject.ENTER],
            handler: function() {
                var b = a.down("button[action=save]");
                b.fireEvent("click", b)
            }
        }];
        this.callParent(arguments)
    }
});